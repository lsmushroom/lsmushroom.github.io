<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Yarn 资源管理与分配 | Mushroom&#39;s blog</title>
  <meta name="author" content="Yuan Linsi">
  
  <meta name="description" content="hadoop,yarn,mapreduce,linux kernel">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Yarn 资源管理与分配"/>
  <meta property="og:site_name" content="Mushroom&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Mushroom&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<!--script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'true']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script-->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-46104206-1', 'lsmushroom.github.io');
    ga('send', 'pageview');
</script>
<script type="text/javascript">
    var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F048b20646e05afe9255eeb7c85739b79' type='text/javascript'%3E%3C/script%3E"));
</script>


</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Mushroom&#39;s blog</a></h1>
  <h2><a href="/">吾尝终日而思矣，不如须臾之所学也</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
    <li><a href="/atom.xml">RSS</a></li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-01T02:33:27.000Z"><a href="/2014/06/01/yarn-资源管理与分配/">6月 1 2014</a></time>
      
      
  
    <h1 class="title">Yarn 资源管理与分配</h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Scheduler_-521d-59cb-5316-">Scheduler 初始化</h2>
<p>在RM启动时将依据用户配置来初始化调度器，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>serviceInit()
    <span class="keyword">...</span>
    this.scheduler = createScheduler();
    <span class="keyword">...</span>
    //创建ApplicationMasterService，用以相应MRAppMaster的请求
    masterService = createApplicationMasterService();
    <span class="keyword">...</span>

createScheduler()
    String schedulerClassName = conf.get(YarnConfiguration.RM_SCHEDULER, YarnConfiguration.DEFAULT_RM_SCHEDULER);
</pre></td></tr></table></figure>

<h2 id="Job_-63d0-4ea4-81f3-8c03-5ea6-961f-5217-">Job 提交至调度队列</h2>
<p>RM中使用FiCaSchedulerNode类来描述一个NM slave结点上的资源使用情况， 用FiCaSchedulerApp 类来描述一个提交到RM的job，跟踪与维护job的运行时信息</p>
<p>CapacityScheduler.java:<br>handle()<br>    —&gt;addNode(nodeAddedEvent.getAddedRMNode()); handle NODE_ADDED 事件,创建NM对应的FiCaSchedulerNode对象用以管理NM中当前可用的资源,相关处理代码如下<br>    —&gt;addApplication() //handle APP_ADDED 事件<br>        LeafQueue.java:<br>        —&gt;submitApplication()//将job提交至叶子节点的队列，对其做相关的权限检查，确认后方将job提交至队列中</p>
<p>CapacityScheduler.java:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>  private synchronized void addNode(RMNode nodeManager) {
    //RM中全局的NM使用一个ConcurrentMap处理，存储NM ID及其对应的FiCaSchedulerNode
    //对象,创建FiCaSchedulerNode对象并添加至全局的nodes中
    this<span class="preprocessor">.nodes</span><span class="preprocessor">.put</span>(nodeManager<span class="preprocessor">.getNodeID</span>(), new FiCaSchedulerNode(nodeManager, usePortForNodeName))<span class="comment">; </span>
    Resources<span class="preprocessor">.addTo</span>(clusterResource, nodeManager<span class="preprocessor">.getTotalCapability</span>())<span class="comment">;</span>
    root<span class="preprocessor">.updateClusterResource</span>(clusterResource)<span class="comment">;</span>
    ++numNodeManagers<span class="comment">; //更新全局的NM个数</span>
    LOG<span class="preprocessor">.info</span>(<span class="string">"Added node "</span> + nodeManager<span class="preprocessor">.getNodeAddress</span>() + 
        <span class="string">" clusterResource: "</span> + clusterResource)<span class="comment">;</span>
  }
</pre></td></tr></table></figure>

<h2 id="-8d44-6e90-5206-914d-ff1a-">资源分配：</h2>
<p>RM中的资源分配过程时间上分为两大步骤：</p>
<ul>
<li>1）RM接收NM的心跳信息，处理各个结点上新启动的或已运行完成需要释放的Container，随后会对当前集群中的可用资源做一个分配，并将分配的结果存储在一个内存结构中</li>
<li>2）AM定期向RM发送心跳信息来获取新分配的Container，ApplicationMasterService将负责响应RPC请求，并从已分配的Container中将可用资源分发给AM</li>
</ul>
<h3 id="RM_-5206-914d-53ef-7528-8d44-6e90-">RM 分配可用资源</h3>
<p>nodeUpdate()<br>    —&gt;处理新启动的container列表,对每个可用的container发送LAUNCHED事件<br>    —&gt;处理已完成的释放的container列表<br>    —&gt;root.assignContainers(clusterResource, node); //从根队列开始遍历每个子队列分配资源<br>       —&gt;assignContainersToChildQueues()//遍历子队列列表,子队列列表本身使用TreeSet结构来管理与维护，多个队列间以队列可用容量来排序<br>        // Try to assign to most ‘under-served’ sub-queue<br>        for (Iterator<CSQueue> iter=childQueues.iterator(); iter.hasNext();) { }//由当前可用资源量最多的开始<br>            —&gt;assignment = childQueue.assignContainers(cluster, node);//在子队列上分配资源<br>            // Try to assign containers to applications in order<br>            for (FiCaSchedulerApp application : activeApplications) { //同一子队列上提交的早的先被调度<br>                // Schedule in priority order<br>                for (Priority priority : application.getPriorities()) { //同一个job发出的多个资源请求中，从优先级高的开始<br>                }<br>            }</p>
<p>队列间使用的比较器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>  this<span class="preprocessor">.queueComparator</span> = cs<span class="preprocessor">.getQueueComparator</span>()<span class="comment">;</span>
  this<span class="preprocessor">.childQueues</span> = new TreeSet&lt;CSQueue&gt;(queueComparator)<span class="comment">;</span>

子队列间插入TreeSet中时所使用的比较器，选择比较队列已经使用的容量大小，当大小一样时，将比较队列名称的名字长队  
  static final Comparator&lt;CSQueue&gt; queueComparator = new Comparator&lt;CSQueue&gt;() {
    @Override
    public int compare(CSQueue q1, CSQueue q2) {
      if (q1<span class="preprocessor">.getUsedCapacity</span>() &lt; q2<span class="preprocessor">.getUsedCapacity</span>()) {
        return -<span class="number">1</span><span class="comment">;</span>
      } else if (q1<span class="preprocessor">.getUsedCapacity</span>() &gt; q2<span class="preprocessor">.getUsedCapacity</span>()) {
        return <span class="number">1</span><span class="comment">;</span>
      }

      return q1<span class="preprocessor">.getQueuePath</span>()<span class="preprocessor">.compareTo</span>(q2<span class="preprocessor">.getQueuePath</span>())<span class="comment">;</span>
    }
  }<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>由根队列开始分配Container：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="code"><pre>  <span class="comment">//收到某个NM结点发来的心跳信息后，尝试在NM结点上分配container，</span>
  <span class="comment">//而实际的调度是发生在将可用的资源如何分配各不同的队列，同一队</span>
  <span class="comment">//列上的不同job，同一job中的不同task</span>
  public synchronized CSAssignment assignContainers(
      Resource clusterResource, FiCaSchedulerNode node) {
    CSAssignment assignment = 
        new CSAssignment(<span class="transposed_variable">Resources.</span>createResource(<span class="number">0</span>, <span class="number">0</span>), <span class="transposed_variable">NodeType.</span>NODE_LOCAL);
   
    <span class="comment">//检查当前NM上的可用资源是否能够满足最低分配额，</span>
    <span class="comment">//若不能，则放弃在当前NM上分配资源</span>
    while (canAssign(clusterResource, node)) {
      ...

      <span class="comment">// Are we over maximum-capacity for this queue?</span>
      <span class="comment">//检查当前已使用的资源占总资源的占比是否超过所</span>
      <span class="comment">//允许的最大值</span>
      <span class="keyword">if</span> (!assignToQueue(clusterResource)) {
        <span class="keyword">break</span>;
      }
      
      <span class="comment">// Schedule</span>
      <span class="comment">//在当前队列的各个子队列上分配资源</span>
      CSAssignment assignedToChild = 
          assignContainersToChildQueues(clusterResource, node);
      <span class="transposed_variable">assignment.</span>setType(<span class="transposed_variable">assignedToChild.</span>getType());
      
      <span class="comment">// Done if no child-queue assigned anything</span>
      <span class="comment">//检查在子队列上是否分配成功，若失败则直接跳出，</span>
      <span class="comment">//因分配过程是依据资源的使用量来调度的，当前的失败</span>
      <span class="comment">//后后续的亦不会成功</span>
      <span class="keyword">if</span> (<span class="transposed_variable">Resources.</span>greaterThan(
              resourceCalculator, clusterResource, 
              <span class="transposed_variable">assignedToChild.</span>getResource(), <span class="transposed_variable">Resources.</span>none())) {
        <span class="comment">// Track resource utilization for the parent-queue</span>
        <span class="comment">//更新集群资源统计</span>
        allocateResource(clusterResource, <span class="transposed_variable">assignedToChild.</span>getResource());
        
        <span class="comment">// Track resource utilization in this pass of the scheduler</span>
        <span class="transposed_variable">Resources.</span>addTo(<span class="transposed_variable">assignment.</span>getResource(), <span class="transposed_variable">assignedToChild.</span>getResource());

      } <span class="keyword">else</span> {
        <span class="keyword">break</span>;
      }

      <span class="comment">// Do not assign more than one container if this isn't the root queue</span>
      <span class="comment">// or if we've already assigned an off-switch container</span>
      <span class="keyword">if</span> (!rootQueue || <span class="transposed_variable">assignment.</span>getType() == <span class="transposed_variable">NodeType.</span>OFF_SWITCH) {
        <span class="keyword">if</span> (<span class="transposed_variable">LOG.</span>isDebugEnabled()) {
          <span class="keyword">if</span> (rootQueue && <span class="transposed_variable">assignment.</span>getType() == <span class="transposed_variable">NodeType.</span>OFF_SWITCH) {
            <span class="transposed_variable">LOG.</span>debug(<span class="string">"Not assigning more than one off-switch container,"</span> +
                <span class="string">" assignments so far: "</span> + assignment);
          }
        }
        <span class="keyword">break</span>;
      }
    }
    
    <span class="keyword">return</span> assignment;
  }
</pre></td></tr></table></figure>

<p>在多个叶子队列上分配资源：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>  synchronized CSAssignment assignContainersToChildQueues(Resource cluster, 
      FiCaSchedulerNode node) {
    CSAssignment assignment = 
        new CSAssignment(Resources.createResource(<span class="number">0</span>, <span class="number">0</span>), NodeType.NODE_LOCAL);
    
    // Try to assign to most <span class="string">'under-served'</span> sub-queue
    <span class="keyword">for</span> (Iterator&lt;CSQueue&gt; iter=childQueues.iterator(); iter.hasNext();) {
      CSQueue childQueue = iter.next();
      <span class="keyword">...</span> 
      assignment = childQueue.assignContainers(cluster, node);
      <span class="keyword">...</span>

      // If we do assign, remove the queue and re-insert <span class="keyword">in</span>-order to re-sort
      //检查是否在子队列上分配container成功
      <span class="keyword">if</span> (Resources.greaterThan(
              resourceCalculator, cluster, 
              assignment.getResource(), Resources.none())) { 
        // Remove and re-insert to sort
        //若成功，则意味着当前子队列的资源使用量有改动，将其从
        //TreeSet中移除，再从新插入，以此来实现更新多个子队列的
        //资源使用量的排序
        iter.remove();
        childQueues.add(childQueue);
        <span class="keyword">break</span>;
      }
    }
    
    <span class="keyword">return</span> assignment;
  }
</pre></td></tr></table></figure>

<p>同一队列上的多个job间使用的排序比较器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>Comparator&lt;FiCaSchedulerApp&gt; applicationComparator = cs.getApplicationComparator();
<span class="keyword">this</span>.pendingApplications = <span class="keyword">new</span> TreeSet&lt;FiCaSchedulerApp&gt;(applicationComparator);
<span class="keyword">this</span>.activeApplications = <span class="keyword">new</span> TreeSet&lt;FiCaSchedulerApp&gt;(applicationComparator);

同一子队列上，多个job插入队列时所使用的比较器，选择比较job的 ApplicationId 大小,
ApplicationId大小对应着job的提交时间，提交的时间越晚则ID值越大

<span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;FiCaSchedulerApp&gt; applicationComparator = 
    <span class="keyword">new</span> Comparator&lt;FiCaSchedulerApp&gt;() {
    <span class="keyword">@Override</span>
    <span class="keyword">public</span> <span class="keyword">int</span> compare(FiCaSchedulerApp a1, FiCaSchedulerApp a2) {
      <span class="keyword">return</span> a1.getApplicationId().compareTo(a2.getApplicationId());
    }
  };
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
</pre></td><td class="code"><pre>  public synchronized CSAssignment 
  assignContainers(Resource clusterResource, FiCaSchedulerNode node) {

    <span class="comment">// Check for reserved resources</span>
    RMContainer reservedContainer = <span class="transposed_variable">node.</span>getReservedContainer();
    <span class="keyword">if</span> (reservedContainer != null) {
      FiCaSchedulerApp application = 
          getApplication(<span class="transposed_variable">reservedContainer.</span>getApplicationAttemptId());
      synchronized (application) {
        <span class="keyword">return</span> assignReservedContainer(application, node, reservedContainer,
          clusterResource);
      }
    }
    
    <span class="comment">// Try to assign containers to applications in order</span>
    <span class="comment">//依据插入队列的时间先后顺序处理同一队列上的多个job</span>
    <span class="keyword">for</span> (FiCaSchedulerApp application : activeApplications) {

      synchronized (application) {
        <span class="comment">// Check if this resource is on the blacklist</span>
        <span class="comment">//检查当前NM 结点是否上了当前job的黑名单，若是则跳过当前job</span>
        <span class="comment">//不为当前job分配资源</span>
        <span class="keyword">if</span> (<span class="transposed_variable">FiCaSchedulerUtils.</span>isBlacklisted(application, node, LOG)) {
          <span class="keyword">continue</span>;
        }
        
        <span class="comment">// Schedule in priority order</span>
        <span class="keyword">for</span> (Priority priority : <span class="transposed_variable">application.</span>getPriorities()) {
          <span class="comment">// Required resource</span>
          Resource required = 
              <span class="transposed_variable">application.</span>getResourceRequest(
                  priority, <span class="transposed_variable">ResourceRequest.</span>ANY).getCapability();

          <span class="comment">// Do we need containers at this 'priority'?</span>
          <span class="keyword">if</span> (!needContainers(application, priority, required)) {
            <span class="keyword">continue</span>;
          }

          Resource userLimit = 
              computeUserLimitAndSetHeadroom(application, clusterResource, 
                  required);          
          
          <span class="comment">// Check queue max-capacity limit</span>
          <span class="comment">//检查即将分配的资源是否会超过是否超过上限值（由maximun-capacity指定）</span>
          <span class="keyword">if</span> (!assignToQueue(clusterResource, required)) {
            <span class="keyword">return</span> NULL_ASSIGNMENT;
          }

          <span class="comment">// Check user limit</span>
          <span class="comment">//检查是否超过用户的使用上限</span>
          <span class="keyword">if</span> (!assignToUser(
              clusterResource, <span class="transposed_variable">application.</span>getUser(), userLimit)) {
              <span class="keyword">break</span>; 
          }

          <span class="comment">// Inform the application it is about to get a scheduling opportunity</span>
          <span class="transposed_variable">application.</span>addSchedulingOpportunity(priority);
          
          <span class="comment">// Try to schedule</span>
          <span class="comment">//尝试对选定的job的指定优先级进行分配container</span>
          CSAssignment assignment =  
            assignContainersOnNode(clusterResource, node, application, priority, 
                null);

          <span class="comment">// Did the application skip this node?</span>
          <span class="keyword">if</span> (<span class="transposed_variable">assignment.</span>getSkipped()) {
            <span class="comment">// Don't count 'skipped nodes' as a scheduling opportunity!</span>
            <span class="transposed_variable">application.</span>subtractSchedulingOpportunity(priority);
            <span class="keyword">continue</span>;
          }
          
          <span class="comment">// Did we schedule or reserve a container?</span>
          Resource assigned = <span class="transposed_variable">assignment.</span>getResource();
          <span class="comment">//检查是否成功分配资源</span>
          <span class="keyword">if</span> (<span class="transposed_variable">Resources.</span>greaterThan(
              resourceCalculator, clusterResource, assigned, <span class="transposed_variable">Resources.</span>none())) {

            <span class="comment">// Book-keeping </span>
            <span class="comment">// Note: Update headroom to account for current allocation too...</span>
            allocateResource(clusterResource, application, assigned);
            
            <span class="comment">// Don't reset scheduling opportunities for non-local assignments</span>
            <span class="comment">// otherwise the app will be delayed for each non-local assignment.</span>
            <span class="comment">// This helps apps with many off-cluster requests schedule faster.</span>
            <span class="keyword">if</span> (<span class="transposed_variable">assignment.</span>getType() != <span class="transposed_variable">NodeType.</span>OFF_SWITCH) {
              <span class="transposed_variable">application.</span>resetSchedulingOpportunities(priority);
            }
            
            <span class="comment">// Done</span>
            <span class="keyword">return</span> assignment;
          } <span class="keyword">else</span> {
            <span class="comment">// Do not assign out of order w.r.t priorities</span>
            <span class="keyword">break</span>;
          }
        }
      }

      <span class="keyword">if</span>(<span class="transposed_variable">LOG.</span>isDebugEnabled()) {
        <span class="transposed_variable">LOG.</span>debug(<span class="string">"post-assignContainers for application "</span>
          + <span class="transposed_variable">application.</span>getApplicationId());
      }
      <span class="transposed_variable">application.</span>showRequests();
    }
  
    <span class="keyword">return</span> NULL_ASSIGNMENT;

  }
</pre></td></tr></table></figure>

<p>同一个job的多个container请求间使用的比较器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="label">AppSchedulingInfo.java:</span>
  final <span class="keyword">Set</span>&lt;Priority&gt; priorities = new TreeSet&lt;Priority&gt;(
      new org<span class="preprocessor">.apache</span><span class="preprocessor">.hadoop</span><span class="preprocessor">.yarn</span><span class="preprocessor">.server</span><span class="preprocessor">.resourcemanager</span><span class="preprocessor">.resource</span><span class="preprocessor">.Priority</span><span class="preprocessor">.Comparator</span>())<span class="comment">;</span>

每个job中提交的资源请求在入到TreeSet结构中时所使用的比较器：
  public static class Comparator 
  implements java<span class="preprocessor">.util</span><span class="preprocessor">.Comparator</span>&lt;org<span class="preprocessor">.apache</span><span class="preprocessor">.hadoop</span><span class="preprocessor">.yarn</span><span class="preprocessor">.api</span><span class="preprocessor">.records</span><span class="preprocessor">.Priority</span>&gt; {
    @Override
    public int compare(org<span class="preprocessor">.apache</span><span class="preprocessor">.hadoop</span><span class="preprocessor">.yarn</span><span class="preprocessor">.api</span><span class="preprocessor">.records</span><span class="preprocessor">.Priority</span> o1, org<span class="preprocessor">.apache</span><span class="preprocessor">.hadoop</span><span class="preprocessor">.yarn</span><span class="preprocessor">.api</span><span class="preprocessor">.records</span><span class="preprocessor">.Priority</span> o2) {
      return o1<span class="preprocessor">.getPriority</span>() - o2<span class="preprocessor">.getPriority</span>()<span class="comment">;</span>
    }
  }
</pre></td></tr></table></figure>

<p>在确定了job及优先级后，尝试在结点上分配资源：<br>assignContainers()<br>    —&gt;assignContainersOnNode() //按照 Data-local ,Rack-local , Off-switch顺序分配job<br>        —&gt;assignNodeLocalContainers()<br>            —&gt;assignContainer() //在结点上完成job的分配</p>
<p>LeafQueue.java:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre>  private CSAssignment assignContainersOnNode(Resource clusterResource, 
      FiCaSchedulerNode node, FiCaSchedulerApp application, 
      Priority priority, RMContainer reservedContainer) {

    Resource assigned = Resources.none();

    // Data-local
    //AppSchedulingInfo类中requests成员记录每个job中所请求的资源类型
    //通过资源的优先级与资源的location信息(Data-local,Rack-local,Off-<span class="keyword">switch</span>
    //来索引资源的请求
    //Map&lt;Priority, Map&lt;String, ResourceRequest&gt;&gt; requests
    
    //依次获取选定的job中在当前优先级下请求的Data-local，
    //Rack-local，Off-<span class="keyword">switch</span>的资源,有限本地分配
    ResourceRequest nodeLocalResourceRequest =
        application.getResourceRequest(priority, node.getNodeName());
    <span class="keyword">if</span> (nodeLocalResourceRequest != null) {
      assigned = 
          assignNodeLocalContainers(clusterResource, nodeLocalResourceRequest, 
              node, application, priority, reservedContainer); 
      <span class="keyword">if</span> (Resources.greaterThan(resourceCalculator, clusterResource, 
          assigned, Resources.none())) {
        <span class="keyword">return</span> new CSAssignment(assigned, NodeType.NODE_LOCAL);
      }
    }

    // Rack-local
    ResourceRequest rackLocalResourceRequest =
        application.getResourceRequest(priority, node.getRackName());
    <span class="keyword">if</span> (rackLocalResourceRequest != null) {
        <span class="keyword">...</span>
    }
    
    // Off-<span class="keyword">switch</span>
    ResourceRequest offSwitchResourceRequest =
        application.getResourceRequest(priority, ResourceRequest.ANY);
    <span class="keyword">if</span> (offSwitchResourceRequest != null) {
        <span class="keyword">...</span> 
    }
    
    <span class="keyword">return</span> SKIP_ASSIGNMENT;
  }
</pre></td></tr></table></figure>

<p>对选定的job在指定location上分配container</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre></td><td class="code"><pre>  <span class="keyword">private</span> Resource assignContainer(Resource clusterResource, FiCaSchedulerNode node, 
      FiCaSchedulerApp application, Priority priority, 
      ResourceRequest request, NodeType <span class="class"><span class="keyword">type</span>, <span class="title">RMContainer</span> <span class="title">rmContainer</span>) {</span>

    <span class="comment">//获取当前的请求，结点上的可用资源，结点的总资源</span>
    Resource capability = request.getCapability();
    Resource available = node.getAvailableResource();
    Resource totalResource = node.getTotalResource();

    <span class="comment">//如果请求资源量超过了结点的总资源量，则直接放弃</span>
    <span class="keyword">if</span> (!Resources.fitsIn(capability, totalResource)) {
      LOG.warn(<span class="string">"Node : "</span> + node.getNodeID()
          + <span class="string">" does not have sufficient resource for request : "</span> + request
          + <span class="string">" node total capability : "</span> + node.getTotalResource());
      <span class="keyword">return</span> Resources.none();
    }
    <span class="comment">//确认当前结点上有可用的资源</span>
    <span class="keyword">assert</span> Resources.greaterThan(
        resourceCalculator, clusterResource, available, Resources.none());

    <span class="comment">//使用Container对象来描述资源分配，</span>
    <span class="comment">//其中包含资源大小，优先级及资源所在的NM结点</span>
    /* 
        Container container = recordFactory.newRecordInstance(Container.<span class="keyword">class</span>);
        container.setId(containerId);
        container.setNodeId(nodeId);
        container.setNodeHttpAddress(nodeHttpAddress);
        container.setResource(resource);
        container.setPriority(priority);
        container.setContainerToken(containerToken);
    */
    Container container = 
        getContainer(rmContainer, application, node, capability, priority);
  
    <span class="comment">// Can we allocate a container on this node?</span>
    <span class="comment">// 确认当前的可用资源是否可以满足需求</span>
    int availableContainers = 
        resourceCalculator.computeAvailableContainers(available, capability);
    <span class="keyword">if</span> (availableContainers &gt; <span class="number">0</span>) {
      <span class="comment">// Allocate...</span>

      <span class="comment">// Did we previously reserve containers at this 'priority'?</span>
      <span class="keyword">if</span> (rmContainer != <span class="keyword">null</span>){
        unreserve(application, priority, node, rmContainer);
      }

      Token containerToken =
          createContainerToken(application, container);
      <span class="keyword">if</span> (containerToken == <span class="keyword">null</span>) {
        <span class="comment">// Something went wrong...</span>
        <span class="keyword">return</span> Resources.none();
      }
      container.setContainerToken(containerToken);
      
      <span class="comment">// Inform the application</span>
      RMContainer allocatedContainer = 
          application.allocate(<span class="class"><span class="keyword">type</span>, <span class="title">node</span>, <span class="title">priority</span>, <span class="title">request</span>, <span class="title">container</span>);</span>

      <span class="comment">// Does the application need this resource?</span>
      <span class="keyword">if</span> (allocatedContainer == <span class="keyword">null</span>) {
        <span class="keyword">return</span> Resources.none();
      }

      <span class="comment">// Inform the node</span>
      node.allocateContainer(application.getApplicationId(), 
          allocatedContainer);

      <span class="keyword">return</span> container.getResource();
    } <span class="keyword">else</span> {
      <span class="comment">// Reserve by 'charging' in advance...</span>
      <span class="comment">// 当前结点上的可用资源无法一次性满足需求时，将为job预留资源</span>
      <span class="comment">// 直至有足够的资源</span>
      reserve(application, priority, node, rmContainer, container);

      <span class="keyword">return</span> request.getCapability();
    }
  }
</pre></td></tr></table></figure>

<p>分配container：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre>  synchronized <span class="keyword">public</span> RMContainer allocate(NodeType <span class="class"><span class="keyword">type</span>, <span class="title">FiCaSchedulerNode</span> <span class="title">node</span>,</span>
      Priority priority, ResourceRequest request, 
      Container container) {
    ... 

    <span class="comment">// Create RMContainer</span>
    RMContainer rmContainer = <span class="keyword">new</span> RMContainerImpl(container, this
        .getApplicationAttemptId(), node.getNodeID(), this.rmContext
        .getDispatcher().getEventHandler(), this.rmContext
        .getContainerAllocationExpirer());

    <span class="comment">// Add it to allContainers list.</span>
    <span class="comment">// KEY:</span>
    <span class="comment">//将分配出的Container添加至新分配的container链表</span>
    <span class="comment">//newlyAllocatedContainers中，后续AM获取container</span>
    <span class="comment">//时将从其中获取已分配的container</span>
    newlyAllocatedContainers.add(rmContainer);
    <span class="comment">//将新分配的container添加至liveContainers集合中，其中</span>
    <span class="comment">//包含的是当前所有活动的container</span>
    liveContainers.put(container.getId(), rmContainer);    

    <span class="comment">// Update consumption and track allocations</span>
    <span class="comment">// 更新资源使用统计</span>
    appSchedulingInfo.allocate(<span class="class"><span class="keyword">type</span>, <span class="title">node</span>, <span class="title">priority</span>, <span class="title">request</span>, <span class="title">container</span>);</span>
    Resources.addTo(currentConsumption, container.getResource());

    <span class="comment">// Inform the container</span>
    <span class="comment">// 完成创建后触发RMContainerEventType.START事件</span>
    rmContainer.handle(
        <span class="keyword">new</span> RMContainerEvent(container.getId(), RMContainerEventType.START));

    ...
    <span class="keyword">return</span> rmContainer;
  }
</pre></td></tr></table></figure>

<p>在RM完成container的分配后，更新NM结点上的资源使用统计信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>  <span class="javadoc">/**
   * The Scheduler has allocated containers on this node to the 
   * given application.
   * 
   *<span class="javadoctag"> @param</span> applicationId application
   *<span class="javadoctag"> @param</span> rmContainer allocated container
   */</span>
  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> allocateContainer(ApplicationId applicationId, 
      RMContainer rmContainer) {
    Container container = rmContainer.getContainer();
    <span class="comment">//更新当前NM结点上的资源量</span>
    deductAvailableResource(container.getResource());
    <span class="comment">//更新NM上已分配的container个数统计</span>
    ++numContainers;
    
    <span class="comment">//将新分配的container添加至全局map中，以container的ID</span>
    <span class="comment">//为key值，供后续AM申请资源时使用</span>
    launchedContainers.put(container.getId(), rmContainer);
    ...
  }
</pre></td></tr></table></figure>

<h4 id="AM_-83b7-53d6-5df2-5206-914d-Container-5217-8868-">AM 获取已分配Container列表</h4>
<p>ApplicationMasterService用于响应来自AMs的RPC请求。主要负责新AM的注册，AM运行结束后终止运行等请求，接收来自AMs的容器分配与释放请求并将这些请求转发至调度器YarnScheduler。</p>
<p>ApplicationMasterService在收到AM的心跳信息后将从RM的已经分配的container链表中依据AM请求的资源来返回container</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
</pre></td><td class="code"><pre>ApplicationMasterService.java:
  <span class="keyword">public</span> AllocateResponse allocate(AllocateRequest request)
      <span class="keyword">throws</span> YarnException, IOException {
      ...
      <span class="comment">//使用指定的调度器分配资源</span>
      <span class="comment">//Send new requests to appAttempt.</span>
      Allocation allocation =
          this.rScheduler.allocate(appAttemptId, ask, release, 
              blacklistAdditions, blacklistRemovals);
      ...
 }

  <span class="keyword">public</span> AllocateResponse allocate(AllocateRequest request)
      <span class="keyword">throws</span> YarnException, IOException {

    <span class="comment">//由请求中获取当前需要分配资源的appAttemptId</span>
    ApplicationAttemptId appAttemptId = authorizeRequest();

    this.amLivelinessMonitor.receivedPing(appAttemptId);

    <span class="comment">/* check if its in cache */</span>
    AllocateResponse lastResponse = responseMap.get(appAttemptId);
    <span class="keyword">if</span> (lastResponse == <span class="keyword">null</span>) {
      LOG.error(<span class="string">"AppAttemptId doesnt exist in cache "</span> + appAttemptId);
      <span class="keyword">return</span> resync;
    }
    <span class="comment">//AM 请求资源分为两步：首先提交job至用户指定的队列，完成job在RM上的注册</span>
    <span class="comment">//随后在RM收到NM的心跳后会将NM上的空闲资源依据已经提交至队列上的job所请求</span>
    <span class="comment">//的资源数来划分container，并将其缓存至链表中，最后AM通过心跳信息来与RM</span>
    <span class="comment">//请求资源时，将从RM已经分配的container列表返回job所请求的对应的container</span>

    <span class="comment">//在此需检查当前所请求资源appAttemptId是否已经被注册过,若没有则异常返回</span>
    <span class="keyword">if</span> (!hasApplicationMasterRegistered(appAttemptId)) {
        ...
    }

    <span class="keyword">if</span> ((request.getResponseId() + <span class="number">1</span>) == lastResponse.getResponseId()) {
      <span class="comment">/* old heartbeat */</span>
      <span class="keyword">return</span> lastResponse;
    } <span class="keyword">else</span> <span class="keyword">if</span> (request.getResponseId() + <span class="number">1</span> &lt; lastResponse.getResponseId()) {
      LOG.error(<span class="string">"Invalid responseid from appAttemptId "</span> + appAttemptId);
      <span class="comment">// Oh damn! Sending reboot isn't enough. RM state is corrupted. TODO:</span>
      <span class="comment">// Reboot is not useful since after AM reboots, it will send register and </span>
      <span class="comment">// get an exception. Might as well throw an exception here.</span>
      <span class="keyword">return</span> resync;
    } 
    
    <span class="comment">// Allow only one thread in AM to do heartbeat at a time.</span>
    <span class="keyword">synchronized</span> (lastResponse) {

      <span class="comment">// Send the status update to the appAttempt.</span>
      this.rmContext.getDispatcher().getEventHandler().handle(
          <span class="keyword">new</span> RMAppAttemptStatusupdateEvent(appAttemptId, request
              .getProgress()));

      <span class="comment">//获取AM提交的job资源请求列表及资源释放列表</span>
      List&lt;ResourceRequest&gt; ask = request.getAskList();
      List&lt;ContainerId&gt; release = request.getReleaseList();
 
      <span class="comment">//黑名单增删</span>
      ResourceBlacklistRequest blacklistRequest = request.getResourceBlacklistRequest();
      List&lt;String&gt; blacklistAdditions = 
          (blacklistRequest != <span class="keyword">null</span>) ? 
              blacklistRequest.getBlacklistAdditions() : <span class="keyword">null</span>;
      List&lt;String&gt; blacklistRemovals = 
          (blacklistRequest != <span class="keyword">null</span>) ? 
              blacklistRequest.getBlacklistRemovals() : <span class="keyword">null</span>;
      
      
      <span class="comment">//使用指定的调度器来获取资源</span>
      Allocation allocation =
          this.rScheduler.allocate(appAttemptId, ask, release, 
              blacklistAdditions, blacklistRemovals);

      RMApp app = this.rmContext.getRMApps().get(
          appAttemptId.getApplicationId());
      RMAppAttempt appAttempt = app.getRMAppAttempt(appAttemptId);
      
      AllocateResponse allocateResponse =
          recordFactory.newRecordInstance(AllocateResponse.<span class="class"><span class="keyword">class</span>);

      ...

      <span class="title">allocateResponse</span>.<span class="title">setAllocatedContainers</span>(<span class="title">allocation</span>.<span class="title">getContainers</span>());
      <span class="title">allocateResponse</span>.<span class="title">setCompletedContainersStatuses</span>(<span class="title">appAttempt</span>
          .<span class="title">pullJustFinishedContainers</span>());
      <span class="title">allocateResponse</span>.<span class="title">setResponseId</span>(<span class="title">lastResponse</span>.<span class="title">getResponseId</span>() + 1);
      <span class="title">allocateResponse</span>.<span class="title">setAvailableResources</span>(<span class="title">allocation</span>.<span class="title">getResourceLimit</span>());
      
      <span class="title">allocateResponse</span>.<span class="title">setNumClusterNodes</span>(<span class="title">this</span>.<span class="title">rScheduler</span>.<span class="title">getNumClusterNodes</span>());
   
      // <span class="title">add</span> <span class="title">preemption</span> <span class="title">to</span> <span class="title">the</span> <span class="title">allocateResponse</span> <span class="title">message</span> (<span class="title">if</span> <span class="title">any</span>)
      <span class="title">allocateResponse</span>.<span class="title">setPreemptionMessage</span>(<span class="title">generatePreemptionMessage</span>(<span class="title">allocation</span>));

      // <span class="title">Adding</span> <span class="title">NMTokens</span> <span class="title">for</span> <span class="title">allocated</span> <span class="title">containers</span>.
      <span class="title">if</span> (!<span class="title">allocation</span>.<span class="title">getContainers</span>().<span class="title">isEmpty</span>()) </span>{
        allocateResponse.setNMTokens(rmContext.getNMTokenSecretManager()
            .createAndGetNMTokens(app.getUser(), appAttemptId,
                allocation.getContainers()));
      }

      <span class="comment">// before returning response, verify in sync</span>
      AllocateResponse oldResponse =
          responseMap.put(appAttemptId, allocateResponse);
      <span class="keyword">if</span> (oldResponse == <span class="keyword">null</span>) {
        <span class="comment">// appAttempt got unregistered, remove it back out</span>
        responseMap.remove(appAttemptId);
        String message = <span class="string">"App Attempt removed from the cache during allocate"</span>
            + appAttemptId;
        LOG.error(message);
        <span class="keyword">return</span> resync;
      }

      <span class="keyword">return</span> allocateResponse;
    }
  }
</pre></td></tr></table></figure>

<p>CapacityScheduler.java:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre></td><td class="code"><pre>  public Allocation allocate(ApplicationAttemptId applicationAttemptId,
      List&lt;ResourceRequest&gt; ask, List&lt;ContainerId&gt; release, 
      List&lt;String&gt; blacklistAdditions, List&lt;String&gt; blacklistRemovals) {

    FiCaSchedulerApp application = getApplication(applicationAttemptId)<span class="comment">;</span>
    
    // Sanity check
    //将job请求的资源归一化，以最小分配资源量为步长
    SchedulerUtils<span class="preprocessor">.normalizeRequests</span>(
        ask, getResourceCalculator(), getClusterResources(),
        getMinimumResourceCapability(), maximumAllocation)<span class="comment">;</span>

    // Release containers
    for (ContainerId releasedContainerId : release) {
      RMContainer rmContainer = getRMContainer(releasedContainerId)<span class="comment">;</span>
      if (rmContainer == null) {
         RMAuditLogger<span class="preprocessor">.logFailure</span>(application<span class="preprocessor">.getUser</span>(),
             AuditConstants<span class="preprocessor">.RELEASE</span>_CONTAINER, 
             <span class="string">"Unauthorized access or invalid container"</span>, <span class="string">"CapacityScheduler"</span>,
             <span class="string">"Trying to release container not owned by app or with invalid id"</span>,
             application<span class="preprocessor">.getApplicationId</span>(), releasedContainerId)<span class="comment">;</span>
      }
      completedContainer(rmContainer,
          SchedulerUtils<span class="preprocessor">.createAbnormalContainerStatus</span>(
              releasedContainerId, 
              SchedulerUtils<span class="preprocessor">.RELEASED</span>_CONTAINER),
          RMContainerEventType<span class="preprocessor">.RELEASED</span>)<span class="comment">;</span>
    }

    synchronized (application) {

      // 确保在为job申请资源时，job本身没有被停止或删除
      if (application<span class="preprocessor">.isStopped</span>()) {
        LOG<span class="preprocessor">.info</span>(<span class="string">"Calling allocate on a stopped "</span> +
            <span class="string">"application "</span> + applicationAttemptId)<span class="comment">;</span>
        return EMPTY_ALLOCATION<span class="comment">;</span>
      }

      if (!ask<span class="preprocessor">.isEmpty</span>()) {

        if(LOG<span class="preprocessor">.isDebugEnabled</span>()) {
          LOG<span class="preprocessor">.debug</span>(<span class="string">"allocate: pre-update"</span> +
            <span class="string">" applicationAttemptId="</span> + applicationAttemptId + 
            <span class="string">" application="</span> + application)<span class="comment">;</span>
        }
        application<span class="preprocessor">.showRequests</span>()<span class="comment">;</span>
  
        // Update application requests
        application<span class="preprocessor">.updateResourceRequests</span>(ask)<span class="comment">;</span>
  
        LOG<span class="preprocessor">.debug</span>(<span class="string">"allocate: post-update"</span>)<span class="comment">;</span>
        application<span class="preprocessor">.showRequests</span>()<span class="comment">;</span>
      }

      if(LOG<span class="preprocessor">.isDebugEnabled</span>()) {
        LOG<span class="preprocessor">.debug</span>(<span class="string">"allocate:"</span> +
          <span class="string">" applicationAttemptId="</span> + applicationAttemptId + 
          <span class="string">" #ask="</span> + ask<span class="preprocessor">.size</span>())<span class="comment">;</span>
      }

      application<span class="preprocessor">.updateBlacklist</span>(blacklistAdditions, blacklistRemovals)<span class="comment">;</span>

      return application<span class="preprocessor">.getAllocation</span>(getResourceCalculator(),
                   clusterResource, getMinimumResourceCapability())<span class="comment">;</span>
    }
  }
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre>  <span class="keyword">public</span> <span class="keyword">synchronized</span> Allocation getAllocation(ResourceCalculator rc,
      Resource clusterResource, Resource minimumAllocation) {

    Set&lt;ContainerId&gt; currentContPreemption = Collections.unmodifiableSet(
        <span class="keyword">new</span> HashSet&lt;ContainerId&gt;(containersToPreempt));
    containersToPreempt.clear();
    Resource tot = Resource.newInstance(<span class="number">0</span>, <span class="number">0</span>);

    <span class="comment">//currentContPreemption集合中的container为可被抢占的</span>
    <span class="comment">//遍历获取其ContainerId 并从liveContainers中获得其对应</span>
    <span class="comment">//的资源，将其添加至</span>
    <span class="keyword">for</span>(ContainerId c : currentContPreemption){
      Resources.addTo(tot,
          liveContainers.get(c).getContainer().getResource());
    }
    <span class="comment">//以最小分配额为步长，计算当前总的可用的资源中可分配多少个container</span>
    <span class="comment">//对多个维度的资源来说，将选取mem与cpu中占总资源量较大者为主资源，</span>
    <span class="keyword">int</span> numCont = (<span class="keyword">int</span>) Math.ceil(
        Resources.divide(rc, clusterResource, tot, minimumAllocation));
    ResourceRequest rr = ResourceRequest.newInstance(
        Priority.UNDEFINED, ResourceRequest.ANY,
        minimumAllocation, numCont);
    <span class="keyword">return</span> <span class="keyword">new</span> Allocation(pullNewlyAllocatedContainers(), getHeadroom(),
                          <span class="keyword">null</span>, currentContPreemption,
                          Collections.singletonList(rr));
  }

ResourceRequest.java:
  <span class="keyword">public</span> <span class="keyword">static</span> ResourceRequest newInstance(Priority priority, String hostName,
      Resource capability, <span class="keyword">int</span> numContainers, <span class="keyword">boolean</span> relaxLocality) {
    ResourceRequest request = Records.newRecord(ResourceRequest.<span class="class"><span class="keyword">class</span>);
    <span class="title">request</span>.<span class="title">setPriority</span>(<span class="title">priority</span>);
    <span class="title">request</span>.<span class="title">setResourceName</span>(<span class="title">hostName</span>);
    <span class="title">request</span>.<span class="title">setCapability</span>(<span class="title">capability</span>);
    <span class="title">request</span>.<span class="title">setNumContainers</span>(<span class="title">numContainers</span>);
    <span class="title">request</span>.<span class="title">setRelaxLocality</span>(<span class="title">relaxLocality</span>);
    <span class="title">return</span> <span class="title">request</span>;
  }</span>
</pre></td></tr></table></figure>

<p>allocate()<br>    —&gt;SchedulerUtils.normalizeRequests()<br>        —&gt;SchedulerUtils.normalizeRequest()<br>            —&gt;normalize()</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre>  <span class="comment">//对每个用户的资源请求归一化</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> normalizeRequests(
    List&lt;ResourceRequest&gt; asks,
    ResourceCalculator resourceCalculator,
    Resource clusterResource,
    Resource minimumResource,
    Resource maximumResource) {
    <span class="keyword">for</span> (ResourceRequest ask : asks) {
      normalizeRequest(
        ask, resourceCalculator, clusterResource, minimumResource,
        maximumResource, minimumResource);
    }
  }

  <span class="javadoc">/**
   * Utility method to normalize a resource request, by insuring that the
   * requested memory is a multiple of minMemory and is not zero.
   */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> normalizeRequest(
    ResourceRequest ask,
    ResourceCalculator resourceCalculator,
    Resource clusterResource,
    Resource minimumResource,
    Resource maximumResource) {
    Resource normalized =
      Resources.normalize(
        resourceCalculator, ask.getCapability(), minimumResource,
        maximumResource, minimumResource);
    ask.setCapability(normalized);
  }

DominantResourceCalculator.java:
  <span class="keyword">public</span> Resource normalize(Resource r, Resource minimumResource,
                            Resource maximumResource, Resource stepFactor) {

    <span class="comment">//首先以一定的步长将请求资源量取整，然后取用户请求</span>
    <span class="comment">//量与允许的最大资源量中较小的</span>
    <span class="comment">//步长为最小分配资源量</span>
    <span class="keyword">int</span> normalizedMemory = Math.min(
      roundUp(
        Math.max(r.getMemory(), minimumResource.getMemory()),
        stepFactor.getMemory()),
      maximumResource.getMemory());
    <span class="keyword">int</span> normalizedCores = Math.min(
      roundUp(
        Math.max(r.getVirtualCores(), minimumResource.getVirtualCores()),
        stepFactor.getVirtualCores()),
      maximumResource.getVirtualCores());
    <span class="keyword">return</span> Resources.createResource(normalizedMemory,
      normalizedCores);
  }
</pre></td></tr></table></figure>

<h4 id="AM_-7aef-7684-7533-8bf7-">AM 端的申请</h4>
<p>RMContainerAllocator是MRAppMaster中负责资源申请与分配的模块，其通过周期性心跳信息获取RM中当前已分配的Container，并对获得的资源看其是否可以满足当前的任务需求，若满足则将对资源做进一步的分配，分配给具体的task，并启动相应的container。</p>
<p>其本身将启动一个线程，每间隔一段时间会向RM发送心跳信息，其中时间间隔的大小取决于MRAppMaster与RM间的心跳时间间隔”yarn.app.mapreduce.am.scheduler.heartbeat.interval-ms” , 默认值为1000ms。</p>
<p>RMCommunicator.java:<br>startAllocatorThread()<br>    —&gt;heartbeat()</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="label">RMContainerAllocator.java:</span>
  protected synchronized void heartbeat() throws Exception {
    scheduleStats<span class="preprocessor">.updateAndLogIfChanged</span>(<span class="string">"Before Scheduling: "</span>)<span class="comment">;</span>
    //用以周期性的向RM发送心跳信息
    List&lt;Container&gt; allocatedContainers = getResources()<span class="comment">;</span>
    if (allocatedContainers<span class="preprocessor">.size</span>() &gt; <span class="number">0</span>) {
      //对获取到的资源进行再分配，将资源分配给具体的task，如map或者reduce
      scheduledRequests<span class="preprocessor">.assign</span>(allocatedContainers)<span class="comment">;</span>
    }

    int completedMaps = getJob()<span class="preprocessor">.getCompletedMaps</span>()<span class="comment">;</span>
    int completedTasks = completedMaps + getJob()<span class="preprocessor">.getCompletedReduces</span>()<span class="comment">;</span>
    if (lastCompletedTasks != completedTasks) {
      lastCompletedTasks = completedTasks<span class="comment">;</span>
      recalculateReduceSchedule = true<span class="comment">;</span>
    }

    if (recalculateReduceSchedule) {
      preemptReducesIfNeeded()<span class="comment">;</span>
      scheduleReduces(
          getJob()<span class="preprocessor">.getTotalMaps</span>(), completedMaps,
          scheduledRequests<span class="preprocessor">.maps</span><span class="preprocessor">.size</span>(), scheduledRequests<span class="preprocessor">.reduces</span><span class="preprocessor">.size</span>(), 
          assignedRequests<span class="preprocessor">.maps</span><span class="preprocessor">.size</span>(), assignedRequests<span class="preprocessor">.reduces</span><span class="preprocessor">.size</span>(),
          mapResourceReqt, reduceResourceReqt,
          pendingReduces<span class="preprocessor">.size</span>(), 
          maxReduceRampupLimit, reduceSlowStart)<span class="comment">;</span>
      recalculateReduceSchedule = false<span class="comment">;</span>
    }

    scheduleStats<span class="preprocessor">.updateAndLogIfChanged</span>(<span class="string">"After Scheduling: "</span>)<span class="comment">;</span>
  }
</pre></td></tr></table></figure>

<p>heartbeat()<br>    —&gt;getResources()<br>    —&gt;assign()</p>
<p>RMContainerAllocator.java:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
</pre></td><td class="code"><pre>    private void assign(List&lt;Container&gt; allocatedContainers) {
      Iterator&lt;Container&gt; it = allocatedContainers<span class="preprocessor">.iterator</span>()<span class="comment">;</span>
      LOG<span class="preprocessor">.info</span>(<span class="string">"Got allocated containers "</span> + allocatedContainers<span class="preprocessor">.size</span>())<span class="comment">;</span>
      containersAllocated += allocatedContainers<span class="preprocessor">.size</span>()<span class="comment">;</span>
      while (it<span class="preprocessor">.hasNext</span>()) {
        Container allocated = it<span class="preprocessor">.next</span>()<span class="comment">;</span>
        if (LOG<span class="preprocessor">.isDebugEnabled</span>()) {
          LOG<span class="preprocessor">.debug</span>(<span class="string">"Assigning container "</span> + allocated<span class="preprocessor">.getId</span>()
              + <span class="string">" with priority "</span> + allocated<span class="preprocessor">.getPriority</span>() + <span class="string">" to NM "</span>
              + allocated<span class="preprocessor">.getNodeId</span>())<span class="comment">;</span>
        }
        
        // check if allocated container meets memory requirements 
        // <span class="keyword">and</span> whether we have any scheduled tasks that need 
        // a container to be assigned
        boolean isAssignable = true<span class="comment">;</span>
        Priority priority = allocated<span class="preprocessor">.getPriority</span>()<span class="comment">;</span>
        int allocatedMemory = allocated<span class="preprocessor">.getResource</span>()<span class="preprocessor">.getMemory</span>()<span class="comment">;</span>
        if (PRIORITY_FAST_FAIL_MAP<span class="preprocessor">.equals</span>(priority) 
            || PRIORITY_MAP<span class="preprocessor">.equals</span>(priority)) {
          if (allocatedMemory &lt; mapResourceReqt
              || maps<span class="preprocessor">.isEmpty</span>()) {
            LOG<span class="preprocessor">.info</span>(<span class="string">"Cannot assign container "</span> + allocated 
                + <span class="string">" for a map as either "</span>
                + <span class="string">" container memory less than required "</span> + mapResourceReqt
                + <span class="string">" or no pending map tasks - maps.isEmpty="</span> 
                + maps<span class="preprocessor">.isEmpty</span>())<span class="comment">; </span>
            isAssignable = false<span class="comment">; </span>
          }
        } 
        else if (PRIORITY_REDUCE<span class="preprocessor">.equals</span>(priority)) {
          if (allocatedMemory &lt; reduceResourceReqt
              || reduces<span class="preprocessor">.isEmpty</span>()) {
            LOG<span class="preprocessor">.info</span>(<span class="string">"Cannot assign container "</span> + allocated 
                + <span class="string">" for a reduce as either "</span>
                + <span class="string">" container memory less than required "</span> + reduceResourceReqt
                + <span class="string">" or no pending reduce tasks - reduces.isEmpty="</span> 
                + reduces<span class="preprocessor">.isEmpty</span>())<span class="comment">; </span>
            isAssignable = false<span class="comment">;</span>
          }
        } else {
          LOG<span class="preprocessor">.warn</span>(<span class="string">"Container allocated at unwanted priority: "</span> + priority + 
              <span class="string">". Returning to RM..."</span>)<span class="comment">;</span>
          isAssignable = false<span class="comment">;</span>
        }
        
        if(!isAssignable) {
          // release container if we could not assign it 
          containerNotAssigned(allocated)<span class="comment">;</span>
          it<span class="preprocessor">.remove</span>()<span class="comment">;</span>
          continue<span class="comment">;</span>
        }
        
        // do not assign if allocated container is on a  
        // blacklisted host
        String allocatedHost = allocated<span class="preprocessor">.getNodeId</span>()<span class="preprocessor">.getHost</span>()<span class="comment">;</span>
        if (isNodeBlacklisted(allocatedHost)) {
          // we need to request for a new container 
          // <span class="keyword">and</span> release the current one
          LOG<span class="preprocessor">.info</span>(<span class="string">"Got allocated container on a blacklisted "</span>
              + <span class="string">" host "</span>+allocatedHost
              +<span class="string">". Releasing container "</span> + allocated)<span class="comment">;</span>

          // find the request matching this allocated container 
          // <span class="keyword">and</span> replace it with a new one 
          ContainerRequest toBeReplacedReq = 
              getContainerReqToReplace(allocated)<span class="comment">;</span>
          if (toBeReplacedReq != null) {
            LOG<span class="preprocessor">.info</span>(<span class="string">"Placing a new container request for task attempt "</span> 
                + toBeReplacedReq<span class="preprocessor">.attemptID</span>)<span class="comment">;</span>
            ContainerRequest newReq = 
                getFilteredContainerRequest(toBeReplacedReq)<span class="comment">;</span>
            decContainerReq(toBeReplacedReq)<span class="comment">;</span>
            if (toBeReplacedReq<span class="preprocessor">.attemptID</span><span class="preprocessor">.getTaskId</span>()<span class="preprocessor">.getTaskType</span>() ==
                TaskType<span class="preprocessor">.MAP</span>) {
              maps<span class="preprocessor">.put</span>(newReq<span class="preprocessor">.attemptID</span>, newReq)<span class="comment">;</span>
            }
            else {
              reduces<span class="preprocessor">.put</span>(newReq<span class="preprocessor">.attemptID</span>, newReq)<span class="comment">;</span>
            }
            addContainerReq(newReq)<span class="comment">;</span>
          }
          else {
            LOG<span class="preprocessor">.info</span>(<span class="string">"Could not map allocated container to a valid request."</span>
                + <span class="string">" Releasing allocated container "</span> + allocated)<span class="comment">;</span>
          }
          
          // release container if we could not assign it 
          containerNotAssigned(allocated)<span class="comment">;</span>
          it<span class="preprocessor">.remove</span>()<span class="comment">;</span>
          continue<span class="comment">;</span>
        }
      }

      assignContainers(allocatedContainers)<span class="comment">;</span>
       
      // release container if we could not assign it 
      it = allocatedContainers<span class="preprocessor">.iterator</span>()<span class="comment">;</span>
      while (it<span class="preprocessor">.hasNext</span>()) {
        Container allocated = it<span class="preprocessor">.next</span>()<span class="comment">;</span>
        LOG<span class="preprocessor">.info</span>(<span class="string">"Releasing unassigned and invalid container "</span> 
            + allocated + <span class="string">". RM may have assignment issues"</span>)<span class="comment">;</span>
        containerNotAssigned(allocated)<span class="comment">;</span>
      }
    }
</pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/yarn/">yarn</a>
  </div>

        <!-- Baidu Button BEGIN -->
        <div id="bdshare" class="bdshare_t bds_tools_32 get-codes-bdshare">
        <a class="bds_tsina"></a>
        <a class="bds_sqq"></a>
        <a class="bds_douban"></a>
        <a class="bds_tqq"></a>
        <a class="bds_qzone"></a>
        <a class="bds_renren"></a>
        <a class="bds_tsohu"></a>
        <a class="bds_t163"></a>
        <span class="bds_more"></span>
        <a class="shareCount"></a>
        </div>
        <script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=6878295" ></script>
        <script type="text/javascript" id="bdshell_js"></script>
        <script type="text/javascript">
        document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
        </script>
        <!-- Baidu Button END -->
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
    <!-- Duoshuo Comment BEGIN -->
    <div class="ds-thread"></div>
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"lsmushroom"};
    (function() {
         var ds = document.createElement('script');
         ds.type = 'text/javascript';ds.async = true;
         ds.src = 'http://static.duoshuo.com/embed.js';
         ds.charset = 'UTF-8';
         (document.getElementsByTagName('head')[0] 
          || document.getElementsByTagName('body')[0]).appendChild(ds);
     })();
    </script>
    <!-- Duoshuo Comment END -->
</section>


</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:lsmushroom.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/git/">git</a><small>1</small></li>
  
    <li><a href="/categories/hadoop/">hadoop</a><small>1</small></li>
  
    <li><a href="/categories/java/">java</a><small>1</small></li>
  
    <li><a href="/categories/kernel/">kernel</a><small>10</small></li>
  
    <li><a href="/categories/vim/">vim</a><small>1</small></li>
  
    <li><a href="/categories/yarn/">yarn</a><small>15</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/api/">api</a><small>1</small></li>
  
    <li><a href="/tags/chm/">chm</a><small>1</small></li>
  
    <li><a href="/tags/git/">git</a><small>1</small></li>
  
    <li><a href="/tags/hadoop/">hadoop</a><small>6</small></li>
  
    <li><a href="/tags/hexo/">hexo</a><small>1</small></li>
  
    <li><a href="/tags/java/">java</a><small>1</small></li>
  
    <li><a href="/tags/kernel/">kernel</a><small>16</small></li>
  
    <li><a href="/tags/pig/">pig</a><small>1</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>1</small></li>
  
    <li><a href="/tags/storm/">storm</a><small>1</small></li>
  
    <li><a href="/tags/vim/">vim</a><small>1</small></li>
  
    <li><a href="/tags/yarn/">yarn</a><small>19</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/api/" style="font-size: 10.00px;">api</a><a href="/tags/chm/" style="font-size: 10.00px;">chm</a><a href="/tags/git/" style="font-size: 10.00px;">git</a><a href="/tags/hadoop/" style="font-size: 13.33px;">hadoop</a><a href="/tags/hexo/" style="font-size: 10.00px;">hexo</a><a href="/tags/java/" style="font-size: 10.00px;">java</a><a href="/tags/kernel/" style="font-size: 16.67px;">kernel</a><a href="/tags/pig/" style="font-size: 10.00px;">pig</a><a href="/tags/shell/" style="font-size: 10.00px;">shell</a><a href="/tags/storm/" style="font-size: 10.00px;">storm</a><a href="/tags/vim/" style="font-size: 10.00px;">vim</a><a href="/tags/yarn/" style="font-size: 20.00px;">yarn</a>
  </div>
</div>


  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=1&ptype=1&speed=0&skin=5&isTitle=1&noborder=1&isWeibo=1&isFans=0&uid=1632605594&verifier=ff6d468c&dpc=1"></iframe>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 Yuan Linsi
  
</div>
<div class="clearfix"></div>
</footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>