<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mushroom&#39;s blog</title>
  <meta name="author" content="Yuan Linsi">
  
  <meta name="description" content="hadoop,yarn,mapreduce,linux kernel">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Mushroom&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Mushroom&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<!--script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'true']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script-->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-46104206-1', 'lsmushroom.github.io');
    ga('send', 'pageview');
</script>
<script type="text/javascript">
    var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F048b20646e05afe9255eeb7c85739b79' type='text/javascript'%3E%3C/script%3E"));
</script>


</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Mushroom&#39;s blog</a></h1>
  <h2><a href="/">入行久久，未逢敌手，专业贴膜，祖传秘方</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
    <li><a href="/atom.xml">RSS</a></li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-10T13:13:53.000Z"><a href="/2014/06/10/cfs-scheduler/">6月 10 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/10/cfs-scheduler/">cfs scheduler</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="sysctl_-914d-7f6e-">sysctl 配置</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="comment">//当前系统中可运行进程的运行周期，在这个时间里系统中所有可运行</span>
<span class="comment">//进程都能运行一次，也即在这个时间里所有可运行进程按自身权重来</span>
<span class="comment">//分配这个时间。</span>
<span class="keyword">unsigned</span> <span class="keyword">int</span> sysctl_sched_latency = <span class="number">5000000U</span>LL; 

<span class="comment">//保证一个进程运行的最短时间，也就是说队列上有再多的进程也要保</span>
<span class="comment">//证一个进程一旦运行了就至少要运行sysctl_sched_min_granularity</span>
<span class="comment">//所规定这么长的时间，这避免了频繁的进程切换导致的开销</span>
<span class="keyword">unsigned</span> <span class="keyword">int</span> sysctl_sched_min_granularity = <span class="number">1000000U</span>LL;

<span class="comment">/*
 * is kept at sysctl_sched_latency / sysctl_sched_min_granularity
 */</span>
<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> sched_nr_latency = <span class="number">5</span>;
</pre></td></tr></table></figure>

<p>可运行进程的运行周期决定了一个进程最长能运行的时间不能超过sysctl_sched_latency，而sysctl_sched_min_granularity又保证了一个进程运行的时间不能少于sysctl_sched_min_granularity，根据这两个值可看出系统中可运行进程数的最大值是：</p>
<p>sched_nr_latency = sysctl_sched_latency / sysctl_sched_min_granularity</p>
<p>变量sched_nr_latency就存储了系统中可运行进程数的最大数目，该变量在文件kernel/sched/fair.c中定义，如下：<br>static unsigned int sched_nr_latency = 8;<br>上面三个变量在系统中都有其初始值，也可以在/proc中设置这些值。这三个值只是提供了一个比例关系。系统中它们各自所代表的那种概念的值是变化的。比如系统中运行进程的数目完全可以超过sched_nr_latency中所定义的值，如果这样它对应的周期值也会线性地扩展。</p>
<p>周期 = 可运行进程的数目 * sysctl_sched_min_granularity</p>
<p>/*</p>
<ul>
<li>After fork, child runs first. If set to 0 (default) then</li>
<li>parent will (try to) run first.<br>*/<br>//新进程创建后子进程先运行，为0则为父进程先运行<br>unsigned int sysctl_sched_child_runs_first __read_mostly;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="code"><pre><span class="comment">/*
 * The idea is to set a period in which each task runs once.
 *
 * When there are too many tasks (sysctl_sched_nr_latency) we have to stretch
 * this period because otherwise the slices get too small.
 *
 * p = (nr &lt;= nl) ? l : l*nr/nl
 */</span>
<span class="comment">//依据当前系统中可运行进程的数目，返回调度周期，此为物理时间，非虚拟时间</span>
<span class="comment">//p = nr_running * sysctl_sched_min_granularity</span>
<span class="keyword">static</span> <span class="keyword">u64</span> <span class="number">__</span>sched_period(unsigned long nr_running)
{
	<span class="keyword">u64</span> period = sysctl_sched_latency;
	unsigned long nr_latency = sched_nr_latency;

	<span class="keyword">if</span> (unlikely(nr_running &gt; nr_latency)) {
		period = sysctl_sched_min_granularity;
		period *= nr_running;
	}

	<span class="keyword">return</span> period;
}

<span class="comment">//依据se的权重，求得其应占用队列调度周期中的时间</span>
<span class="keyword">static</span> <span class="keyword">u64</span> sched_slice(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *se)
{
    <span class="comment">//获得当前的调度周期</span>
	<span class="keyword">u64</span> slice = <span class="number">__</span>sched_period(cfs_rq-&gt;nr_running + !se-&gt;on_rq);

	for_each_sched_entity(se) {
		<span class="keyword">struct</span> load_weight *load;
		<span class="keyword">struct</span> load_weight lw;

		cfs_rq = cfs_rq_of(se);
		load = &cfs_rq-&gt;load;

		<span class="keyword">if</span> (unlikely(!se-&gt;on_rq)) {
			lw = cfs_rq-&gt;load;

			update_load_add(&lw, se-&gt;load.weight);
			load = &lw;
		}
        <span class="comment">//依据权重计算se可用的时间长度</span>
		slice = calc_delta_mine(slice, se-&gt;load.weight, load);
	}
	<span class="keyword">return</span> slice;
}

<span class="comment">/*
 * We calculate the vruntime slice of a to be inserted task
 *
 * vs = s/w
 */</span>
<span class="comment">//计算se的虚拟运行时间，对普通进程而言，其值与物理时间时间同步，</span>
<span class="comment">//非普通进程，则需考虑其权重</span>
<span class="keyword">static</span> <span class="keyword">u64</span> sched_vslice(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *se)
{
	<span class="keyword">return</span> calc_delta_fair(sched_slice(cfs_rq, se), se);
}
</pre></td></tr></table></figure>

<h3 id="vruntime-865a-62df-65f6-949f-7684-6ea2-51fa-95ee-9898-">vruntime虚拟时钟的溢出问题</h3>
<p>进程的虚拟时间是一个递增的正值，因此它不会是负数，但是它有它的上限，就是unsigned long所能表示的最大值，如果溢出了，那么它就会从0开始回滚，而vruntime本身的作用就是推进虚拟时钟，并没有别的用处，它可以不在乎， 但在插入rbtree中时就必须考虑key值大小的问题。由此在插入rbtree中时，将与cfs_rq-&gt;min_vruntime的差值作为key，且将差值转为有符号的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre><span class="comment">//key: rbtree中结点的key值</span>
static <span class="keyword">inline</span> s64 entity_key(struct cfs_rq <span class="subst">*</span>cfs_rq, struct sched_entity <span class="subst">*</span>se)
{
    <span class="comment">//注意se-&gt;vruntime与cfs_rq-&gt;min_vruntime均为无符号的，而返回值为有符号的</span>
	<span class="keyword">return</span> se<span class="subst">-&gt;</span>vruntime <span class="subst">-</span> cfs_rq<span class="subst">-&gt;</span>min_vruntime;
}

<span class="comment">//更新队列的cfs_rq-&gt;min_vruntime时间</span>
static <span class="literal">void</span> update_min_vruntime(struct cfs_rq <span class="subst">*</span>cfs_rq)
{
	u64 vruntime <span class="subst">=</span> cfs_rq<span class="subst">-&gt;</span>min_vruntime;

	<span class="keyword">if</span> (cfs_rq<span class="subst">-&gt;</span>curr)
		vruntime <span class="subst">=</span> cfs_rq<span class="subst">-&gt;</span>curr<span class="subst">-&gt;</span>vruntime;

	<span class="keyword">if</span> (cfs_rq<span class="subst">-&gt;</span>rb_leftmost) {
		struct sched_entity <span class="subst">*</span>se <span class="subst">=</span> rb_entry(cfs_rq<span class="subst">-&gt;</span>rb_leftmost,
						   struct sched_entity,
						   run_node);

		<span class="keyword">if</span> (<span class="subst">!</span>cfs_rq<span class="subst">-&gt;</span>curr)
			vruntime <span class="subst">=</span> se<span class="subst">-&gt;</span>vruntime;
		<span class="keyword">else</span>
			vruntime <span class="subst">=</span> min_vruntime(vruntime, se<span class="subst">-&gt;</span>vruntime);
	}

    <span class="comment">//以上比较rbtree中几个含有最小vruntime的结点的值，选取最小的vruntime，但在实际更新vruntime时</span>
    <span class="comment">//为保证cfs_rq-&gt;min_vruntime始终是单调递增的，仅当运行队列中有vruntime大于原有的值时才更新</span>
	cfs_rq<span class="subst">-&gt;</span>min_vruntime <span class="subst">=</span> max_vruntime(cfs_rq<span class="subst">-&gt;</span>min_vruntime, vruntime);
}

static <span class="keyword">inline</span> u64 max_vruntime(u64 min_vruntime, u64 vruntime)
{
    <span class="comment">//注意此处将原有的无符号数转为有符号数</span>
    <span class="comment">//由于cfq的min_vruntime始终是单调递增的，当min_vruntime最高位未置位，而vruntime</span>
    <span class="comment">//最高位置位时，表示min_vruntime已经溢出，又从零开始，而vruntime作为无符号数虽</span>
    <span class="comment">//大于min_vruntime,但实际上表示其已落后min_vruntime，仍小于min_vruntime。</span>
    <span class="comment">//将二者的差值转变为有符号的数，可以保证即使在min_vruntime溢出后仍然保持比较结果</span>
    <span class="comment">//的正确性:当二者最高位同时置位时，有符号与无符号结果一致，当仅有一个最高位置位时</span>
    <span class="comment">//表示有一个已经溢出，差值结果会将最高位视为符号位。</span>
	s64 delta <span class="subst">=</span> (s64)(vruntime <span class="subst">-</span> min_vruntime);
	<span class="keyword">if</span> (delta <span class="subst">&gt;</span> <span class="number">0</span>)
		min_vruntime <span class="subst">=</span> vruntime;

	<span class="keyword">return</span> min_vruntime;
}

static <span class="keyword">inline</span> u64 min_vruntime(u64 min_vruntime, u64 vruntime)
{
    <span class="comment">//注意此处将原有的无符号数转为有符号数</span>
	s64 delta <span class="subst">=</span> (s64)(vruntime <span class="subst">-</span> min_vruntime);
	<span class="keyword">if</span> (delta <span class="subst">&lt;</span> <span class="number">0</span>)
		min_vruntime <span class="subst">=</span> vruntime;

	<span class="keyword">return</span> min_vruntime;
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre>static void update_curr(struct cfs_rq *cfs_rq)
{
	struct sched_entity *curr = cfs_rq-&gt;curr;
	u64 now = rq_of(cfs_rq)-&gt;clock;
	unsigned long delta_exec;

	if (unlikely(!curr))
		return;

	/*
	 * Get the amount of time the current task was running
	 * since the last time we changed load (this cannot
	 * overflow on 32 bits):
	 */
    //获取当前时钟已经执行的时间
	delta_exec = (unsigned long)(now - curr-&gt;exec_start);
	if (!delta_exec)
		return;

	__update_curr(cfs_rq, curr, delta_exec);
	curr-&gt;exec_start = now;

	if (entity_is_task(curr)) {
		struct task_struct *curtask = task_of(curr);

		trace_sched_stat_runtime(curtask, delta_exec, curr-&gt;vruntime);
		cpuacct_charge(curtask, delta_exec);
		account_group_exec_runtime(curtask, delta_exec);
	}

	account_cfs_rq_runtime(cfs_rq, delta_exec);
}

/*
 * Update the current task's runtime statistics. Skip current tasks that
 * are not in our scheduling class.
 */
static inline void
__update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,
	      unsigned long delta_exec)
{
	unsigned long delta_exec_weighted;

	schedstat_set(curr-&gt;exec_max, max((u64)delta_exec, curr-&gt;exec_max));

    //更新进程总的运行时间
	curr-&gt;sum_exec_runtime += delta_exec;
	schedstat_add(cfs_rq, exec_clock, delta_exec);
    //依据进程的权重值来更新进程的虚拟时间
	delta_exec_weighted = calc_delta_fair(delta_exec, curr);

	curr-&gt;vruntime += delta_exec_weighted;
	update_min_vruntime(cfs_rq);

<span class="comment">#if defined CONFIG_SMP && defined CONFIG_FAIR_GROUP_SCHED</span>
	cfs_rq-&gt;load_unacc_exec_time += delta_exec;
<span class="comment">#endif</span>
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>/*
 * The idea <span class="keyword">is</span> <span class="keyword">to</span> <span class="keyword">set</span> a period <span class="keyword">in</span> which each task runs once.
 *
 * When there are too many tasks (sysctl_sched_nr_latency) we have <span class="keyword">to</span> stretch
 * this period because otherwise <span class="keyword">the</span> slices <span class="keyword">get</span> too small.
 *
 * p = (nr &lt;= nl) ? l : l*nr/nl
 */
static u64 __sched_period(unsigned long nr_running)
{
	u64 period = sysctl_sched_latency;
	unsigned long nr_latency = sched_nr_latency;

	<span class="keyword">if</span> (unlikely(nr_running &gt; nr_latency)) {
		period = sysctl_sched_min_granularity;
		period *= nr_running;
	}
<span class="command">
	return</span> period;
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="code"><pre><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>
calc_delta_fair(<span class="keyword">unsigned</span> <span class="keyword">long</span> delta, <span class="keyword">struct</span> sched_entity *se)
{
    <span class="comment">//对于普通的进程，优先级为120的，虚拟时间与实际运行时间同步</span>
	<span class="keyword">if</span> (unlikely(se-&gt;load<span class="variable">.weight</span> != NICE_0_LOAD))
        <span class="comment">//非普通进程，将依据其权重值更新</span>
		delta = calc_delta_mine(delta, NICE_0_LOAD, &se-&gt;load);

	<span class="keyword">return</span> delta;
}

<span class="preprocessor">#if BITS_PER_LONG == 32</span>
<span class="preprocessor"># define WMULT_CONST	(~0UL)</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"># define WMULT_CONST	(1UL &lt;&lt; 32)</span>
<span class="preprocessor">#endif</span>

<span class="preprocessor">#define WMULT_SHIFT	32</span>

<span class="comment">/*
 * Shift right and round:
 */</span>
<span class="preprocessor">#define SRR(x, y) (((x) + (1UL &lt;&lt; ((y) - 1))) &gt;&gt; (y))</span>

<span class="comment">/*
 * delta *= weight / lw
 */</span>
<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>
calc_delta_mine(<span class="keyword">unsigned</span> <span class="keyword">long</span> delta_exec, <span class="keyword">unsigned</span> <span class="keyword">long</span> weight,
		<span class="keyword">struct</span> load_weight *lw)
{
	u64 tmp;

	<span class="keyword">if</span> (!lw-&gt;inv_weight) {
		<span class="keyword">if</span> (BITS_PER_LONG &gt; <span class="number">32</span> && unlikely(lw-&gt;weight &gt;= WMULT_CONST))
			lw-&gt;inv_weight = <span class="number">1</span>;
		<span class="keyword">else</span>
			lw-&gt;inv_weight = <span class="number">1</span> + (WMULT_CONST-lw-&gt;weight/<span class="number">2</span>)
				/ (lw-&gt;weight+<span class="number">1</span>);
	}

	tmp = (u64)delta_exec * weight;
	<span class="comment">/*
	 * Check whether we'd overflow the 64-bit multiplication:
	 */</span>
	<span class="keyword">if</span> (unlikely(tmp &gt; WMULT_CONST))
		tmp = SRR(SRR(tmp, WMULT_SHIFT/<span class="number">2</span>) * lw-&gt;inv_weight,
			WMULT_SHIFT/<span class="number">2</span>);
	<span class="keyword">else</span>
		tmp = SRR(tmp * lw-&gt;inv_weight, WMULT_SHIFT);

	<span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)min(tmp, (u64)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)LONG_MAX);
}
[exp](http:<span class="comment">//stackoverflow.com/questions/17776451/explanation-of-the-calc-delta-mine-function)</span>
</pre></td></tr></table></figure>

<h3 id="vruntime_-66f4-65b0-">vruntime 更新</h3>
<p>每次时钟中断到来时，触发scheduler_tick()执行<br>update_process_times()<br>    —&gt; scheduler_tick(): curr-&gt;sched_class-&gt;task_tick(rq, curr, 0); //依据调度类更新当前进程时钟<br>            —&gt; task_tick_fair() //遍历运行队列中的每个调度实体，更新其虚拟时钟<br>                —&gt;entity_tick()<br>                    —&gt;update_curr() //计算出当前进程运行的实际物理时间<br>                        —&gt; __update_curr() //结合当前进程优先级，考虑其权重大小，更新当前进程的虚拟时钟 ,普通进程与物理时钟同步<br>                            —&gt;update_min_vruntime() //更新队列的min_vruntime大小<br>                    —&gt;check_preempt_tick() //检查是否可抢占当前运行的进程</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre>static <span class="reserved">void</span>
check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)
{
	unsigned long ideal_runtime, delta_exec;
    
    <span class="regexp">//</span>结合当前进程在运行队列中所占用的权重，计算其应占用
    <span class="regexp">//</span>当前调度周期中的时间片大小，此时间为物理时间
	ideal_runtime = sched_slice(cfs_rq, curr);

    <span class="regexp">//</span>计算当前进程实际已经运行的物理时间
	delta_exec = curr<span class="function">-&gt;</span>sum_exec_runtime - curr<span class="function">-&gt;</span>prev_sum_exec_runtime;

    <span class="regexp">//</span>如果超过应占用时间片的大小，则触发一次抢占,让当前运行的进程让出CPU
	<span class="keyword">if</span> (delta_exec &gt; ideal_runtime) {
		resched_task<span class="function"><span class="params">(rq_of(cfs_rq)-&gt;curr)</span>;
		/*
		 * <span class="title">The</span> <span class="title">current</span> <span class="title">task</span> <span class="title">ran</span> <span class="title">long</span> <span class="title">enough</span>, <span class="title">ensure</span> <span class="title">it</span> <span class="title">doesn</span>'<span class="title">t</span> <span class="title">get</span>
		 * <span class="title">re</span>-<span class="title">elected</span> <span class="title">due</span> <span class="title">to</span> <span class="title">buddy</span> <span class="title">favours</span>.
		 */
		<span class="title">clear_buddies</span><span class="params">(cfs_rq, curr)</span>;
		<span class="title">return</span>;
	}

	/*
	 * <span class="title">Ensure</span> <span class="title">that</span> <span class="title">a</span> <span class="title">task</span> <span class="title">that</span> <span class="title">missed</span> <span class="title">wakeup</span> <span class="title">preemption</span> <span class="title">by</span> <span class="title">a</span>
	 * <span class="title">narrow</span> <span class="title">margin</span> <span class="title">doesn</span>'<span class="title">t</span> <span class="title">have</span> <span class="title">to</span> <span class="title">wait</span> <span class="title">for</span> <span class="title">a</span> <span class="title">full</span> <span class="title">slice</span>.
	 * <span class="title">This</span> <span class="title">also</span> <span class="title">mitigates</span> <span class="title">buddy</span> <span class="title">induced</span> <span class="title">latencies</span> <span class="title">under</span> <span class="title">load</span>.
	 */
	<span class="title">if</span> <span class="params">(!sched_feat(WAKEUP_PREEMPT))</span>
		<span class="title">return</span>;

    //如果当前进程实际运行时间小于最小的调度时间，则放弃抢占，让其继续运行
	<span class="title">if</span> <span class="params">(delta_exec &lt; sysctl_sched_min_granularity)</span>
		<span class="title">return</span>;

    //检查运行队列中是否有更应该被调度的进程
	<span class="title">if</span> <span class="params">(cfs_rq-&gt;nr_running &gt; <span class="number">1</span>)</span> {
        //取<span class="title">rbtree</span>中最左边的结点，即<span class="title">key</span>最小的
		<span class="title">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> = <span class="title">__pick_first_entity</span><span class="params">(cfs_rq)</span>;
		<span class="title">s64</span> <span class="title">delta</span> = <span class="title">curr</span>-&gt;</span>vruntime - se<span class="function">-&gt;</span>vruntime;

		<span class="keyword">if</span> (delta &lt; <span class="number">0</span>)
			<span class="keyword">return</span>;

        <span class="regexp">//</span>仅在当前进程vruntime超出最左结点的vruntime ideal_runtime时
        <span class="regexp">//</span>触发抢占
		<span class="keyword">if</span> (delta &gt; ideal_runtime)
			resched_task<span class="function"><span class="params">(rq_of(cfs_rq)-&gt;curr)</span>;
	}
}</span>
</pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-09T12:02:41.000Z"><a href="/2014/06/09/yarn-counter/">6月 9 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/09/yarn-counter/">Yarn counter</a></h1>
  

    </header>
    <div class="entry">
      
        <p>更新进程资源使用统计,</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="code"><pre>  <span class="comment">/**
   * Construct the ProcessInfo using the process' PID and procfs rooted at the
   * specified directory and return the same. It is provided mainly to assist
   * testing purposes.
   *
   * Returns null on failing to read from procfs,
   *
   * @param pinfo ProcessInfo that needs to be updated
   * @param procfsDir root of the proc file system
   * @return updated ProcessInfo, null on errors.
   */</span>
  private static ProcessInfo constructProcessInfo(ProcessInfo pinfo,
                                                    String procfsDir) {
    ProcessInfo <span class="keyword">ret</span> = null<span class="comment">;</span>
    // Read <span class="string">"procfsDir/&lt;pid&gt;/stat"</span> file - typically /proc/&lt;pid&gt;/stat
    BufferedReader <span class="keyword">in</span> = null<span class="comment">;</span>
    FileReader fReader = null<span class="comment">;</span>
    try {
      File pidDir = new File(procfsDir, pinfo<span class="preprocessor">.getPid</span>())<span class="comment">;</span>
      fReader = new FileReader(new File(pidDir, PROCFS_STAT_FILE))<span class="comment">;</span>
      <span class="keyword">in</span> = new BufferedReader(fReader)<span class="comment">;</span>
    } catch (FileNotFoundException f) {
      // The process vanished <span class="keyword">in</span> the interim!
      return <span class="keyword">ret</span><span class="comment">;</span>
    }

    <span class="keyword">ret</span> = pinfo<span class="comment">;</span>
    try {
      String str = <span class="keyword">in</span><span class="preprocessor">.readLine</span>()<span class="comment">; // only one line</span>
      Matcher m = PROCFS_STAT_FILE_FORMAT<span class="preprocessor">.matcher</span>(str)<span class="comment">;</span>
      boolean mat = m<span class="preprocessor">.find</span>()<span class="comment">;</span>
      if (mat) {
        // <span class="keyword">Set</span> (name) (ppid) (pgrpId) (session) (utime) (stime) (vsize) (rss)
        pinfo<span class="preprocessor">.updateProcessInfo</span>(m<span class="preprocessor">.group</span>(<span class="number">2</span>), m<span class="preprocessor">.group</span>(<span class="number">3</span>),
                Integer<span class="preprocessor">.parseInt</span>(m<span class="preprocessor">.group</span>(<span class="number">4</span>)), Integer<span class="preprocessor">.parseInt</span>(m<span class="preprocessor">.group</span>(<span class="number">5</span>)),
                Long<span class="preprocessor">.parseLong</span>(m<span class="preprocessor">.group</span>(<span class="number">7</span>)), new BigInteger(m<span class="preprocessor">.group</span>(<span class="number">8</span>)),
                Long<span class="preprocessor">.parseLong</span>(m<span class="preprocessor">.group</span>(<span class="number">10</span>)), Long<span class="preprocessor">.parseLong</span>(m<span class="preprocessor">.group</span>(<span class="number">11</span>)))<span class="comment">;</span>
      } else {
        LOG<span class="preprocessor">.warn</span>(<span class="string">"Unexpected: procfs stat file is not in the expected format"</span>
            + <span class="string">" for process with pid "</span> + pinfo<span class="preprocessor">.getPid</span>())<span class="comment">;</span>
        <span class="keyword">ret</span> = null<span class="comment">;</span>
      }
    } catch (IOException io) {
      LOG<span class="preprocessor">.warn</span>(<span class="string">"Error reading the stream "</span> + io)<span class="comment">;</span>
      <span class="keyword">ret</span> = null<span class="comment">;</span>
    } finally {
      // Close the streams
      try {
        fReader<span class="preprocessor">.close</span>()<span class="comment">;</span>
        try {
          <span class="keyword">in</span><span class="preprocessor">.close</span>()<span class="comment">;</span>
        } catch (IOException i) {
          LOG<span class="preprocessor">.warn</span>(<span class="string">"Error closing the stream "</span> + <span class="keyword">in</span>)<span class="comment">;</span>
        }
      } catch (IOException i) {
        LOG<span class="preprocessor">.warn</span>(<span class="string">"Error closing the stream "</span> + fReader)<span class="comment">;</span>
      }
    }

    return <span class="keyword">ret</span><span class="comment">;</span>
  }
</pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-06T06:34:31.000Z"><a href="/2014/06/06/hadoop-rpc/">6月 6 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/06/hadoop-rpc/">Hadoop RPC</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="Server">Server</h3>
<p>Server() 构造函数中将完成类的初始化工作，包括读取配置文件，设置Reader线程池中线程个数等操作。</p>
<p>涉及到的相关配置项如下：<br>callQueue 队列的大小：ipc.server.handler.queue.size：def: 100<br>reader线程中线程的个数： ipc.server.read.threadpool.size: def：1<br>是否关闭Nagle算法：ipc.server.tcpnodelay:false</p>
<p>同时Server()构造函数中将创建Listener()与Responder()两个线程对象，在service启动时启动两个线程并创建Handler线程。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre> public synchronized void <span class="operator"><span class="keyword">start</span>() {
     responder.<span class="keyword">start</span>();</span>
     listener.<span class="operator"><span class="keyword">start</span>();</span>
     handlers = new <span class="operator"><span class="keyword">Handler</span>[handlerCount];</span>

     for (int i = 0; i &lt; handlerCount; i++) {
         handlers[i] = new <span class="operator"><span class="keyword">Handler</span>(i);</span>
         handlers[i].<span class="operator"><span class="keyword">start</span>();</span>
     }
 }
</pre></td></tr></table></figure>

<h3 id="Listener">Listener</h3>
<p>构造函数中将完成常规的饿socket server完成的job，并依据配置创建相应个数的Reader线程对象并启动。</p>
<p>核心线程处理函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre>    public void run() {
      while (running) {
        SelectionKey key = null<span class="comment">;</span>
        try {
          getSelector()<span class="preprocessor">.select</span>()<span class="comment">;//等待事件的到来</span>
          Iterator&lt;SelectionKey&gt; iter = getSelector()<span class="preprocessor">.selectedKeys</span>()<span class="preprocessor">.iterator</span>()<span class="comment">;</span>
          while (iter<span class="preprocessor">.hasNext</span>()) {
            key = iter<span class="preprocessor">.next</span>()<span class="comment">;</span>
            iter<span class="preprocessor">.remove</span>()<span class="comment">;</span>
            try {
              if (key<span class="preprocessor">.isValid</span>()) {
                if (key<span class="preprocessor">.isAcceptable</span>())
                  doAccept(key)<span class="comment">; //循环处理每个连接</span>
              }
              ...
    
    void doAccept(SelectionKey key) throws IOException,  OutOfMemoryError {
      Connection c = null<span class="comment">;</span>
      ServerSocketChannel server = (ServerSocketChannel) key<span class="preprocessor">.channel</span>()<span class="comment">;</span>
      SocketChannel channel<span class="comment">;</span>
      while ((channel = server<span class="preprocessor">.accept</span>()) != null) {

        channel<span class="preprocessor">.configureBlocking</span>(false)<span class="comment">;</span>
        channel<span class="preprocessor">.socket</span>()<span class="preprocessor">.setTcpNoDelay</span>(tcpNoDelay)<span class="comment">;</span>
        
        Reader reader = getReader()<span class="comment">; //以RR 的方式将新建的连接交给Reader ThreadPool中的线程处理</span>
        try {
          reader<span class="preprocessor">.startAdd</span>()<span class="comment">;//</span>
          SelectionKey readKey = reader<span class="preprocessor">.registerChannel</span>(channel)<span class="comment">;//将新建连接添加至被选中的Reader线程的事件集中</span>
          c = new Connection(readKey, channel, Time<span class="preprocessor">.now</span>())<span class="comment">;</span>
          readKey<span class="preprocessor">.attach</span>(c)<span class="comment">;</span>
          synchronized (connectionList) {
            connectionList<span class="preprocessor">.add</span>(numConnections, c)<span class="comment">;</span>
            numConnections++<span class="comment">;</span>
          }
          if (LOG<span class="preprocessor">.isDebugEnabled</span>())
            LOG<span class="preprocessor">.debug</span>(<span class="string">"Server connection from "</span> + c<span class="preprocessor">.toString</span>() +
                <span class="string">"; # active connections: "</span> + numConnections +
                <span class="string">"; # queued calls: "</span> + callQueue<span class="preprocessor">.size</span>())<span class="comment">;          </span>
        } finally {
          reader<span class="preprocessor">.finishAdd</span>()<span class="comment">; //通知Reader线程事件的添加已经结束，可以开始处理</span>
        }
      }
    }
</pre></td></tr></table></figure>

<h3 id="Reader">Reader</h3>
<p>核心线程处理函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>      private synchronized void doRunLoop() {
        while (running) {
          SelectionKey key = null<span class="comment">;</span>
          try {
            readSelector<span class="preprocessor">.select</span>()<span class="comment">;</span>
            while (adding) { //在次等待Listener线程添加完事件
              this<span class="preprocessor">.wait</span>(<span class="number">1000</span>)<span class="comment">;</span>
            }              

            Iterator&lt;SelectionKey&gt; iter = readSelector<span class="preprocessor">.selectedKeys</span>()<span class="preprocessor">.iterator</span>()<span class="comment">;</span>
            while (iter<span class="preprocessor">.hasNext</span>()) {
              key = iter<span class="preprocessor">.next</span>()<span class="comment">;</span>
              iter<span class="preprocessor">.remove</span>()<span class="comment">;</span>
              if (key<span class="preprocessor">.isValid</span>()) {
                if (key<span class="preprocessor">.isReadable</span>()) {
                  doRead(key)<span class="comment">;</span>
                }
              }
              key = null<span class="comment">;</span>
            }
            ...
      }
</pre></td></tr></table></figure>

<p>doRead()<br>    —&gt;readAndProcess()</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="code"><pre>    public int readAndProcess()
        throws WrappedRpcServerException, IOException, InterruptedException {
      while (true) {
        <span class="comment">/* Read at most one RPC. If the header is not read completely yet
         * then iterate until we read first RPC or until there is no data left.
         */</span>    
        <span class="comment">/* 首先读取RPC Header并做相关的检查及处理*/</span>
        int count = -<span class="number">1</span><span class="comment">;</span>
        if (dataLengthBuffer<span class="preprocessor">.remaining</span>() &gt; <span class="number">0</span>) {
          count = channelRead(channel, dataLengthBuffer)<span class="comment">;       </span>
          if (count &lt; <span class="number">0</span> || dataLengthBuffer<span class="preprocessor">.remaining</span>() &gt; <span class="number">0</span>) 
            return count<span class="comment">;</span>
        }
        
        if (!connectionHeaderRead) {
          //Every connection is expected to send the header.
          if (connectionHeaderBuf == null) {
            connectionHeaderBuf = ByteBuffer<span class="preprocessor">.allocate</span>(<span class="number">3</span>)<span class="comment">;</span>
          }
          count = channelRead(channel, connectionHeaderBuf)<span class="comment">;</span>
          if (count &lt; <span class="number">0</span> || connectionHeaderBuf<span class="preprocessor">.remaining</span>() &gt; <span class="number">0</span>) {
            return count<span class="comment">;</span>
          }

          int version = connectionHeaderBuf<span class="preprocessor">.get</span>(<span class="number">0</span>)<span class="comment">;</span>
          // TODO we should <span class="keyword">add</span> handler for service class later
          this<span class="preprocessor">.setServiceClass</span>(connectionHeaderBuf<span class="preprocessor">.get</span>(<span class="number">1</span>))<span class="comment">;</span>
          dataLengthBuffer<span class="preprocessor">.flip</span>()<span class="comment">;</span>
          
          // Check if it looks like the user is hitting an IPC port
          // with an HTTP GET - this is a common error, so we can
          // send back a simple string indicating as much.
          if (HTTP_GET_BYTES<span class="preprocessor">.equals</span>(dataLengthBuffer)) {
            setupHttpRequestOnIpcPortResponse()<span class="comment">;</span>
            return -<span class="number">1</span><span class="comment">;</span>
          }
          
          continue<span class="comment">;</span>
        }
        
        if (data == null) {
          dataLengthBuffer<span class="preprocessor">.flip</span>()<span class="comment">;</span>
          dataLength = dataLengthBuffer<span class="preprocessor">.getInt</span>()<span class="comment">;</span>
          checkDataLength(dataLength)<span class="comment">;</span>
          data = ByteBuffer<span class="preprocessor">.allocate</span>(dataLength)<span class="comment">;</span>
        }
        
        <span class="comment">/*读取RPC请求的body段并处理*/</span>
        count = channelRead(channel, data)<span class="comment">;</span>
        
        if (data<span class="preprocessor">.remaining</span>() == <span class="number">0</span>) {
          dataLengthBuffer<span class="preprocessor">.clear</span>()<span class="comment">;</span>
          data<span class="preprocessor">.flip</span>()<span class="comment">;</span>
          boolean isHeaderRead = connectionContextRead<span class="comment">;</span>
          processOneRpc(data<span class="preprocessor">.array</span>())<span class="comment">;</span>
          data = null<span class="comment">;</span>
          if (!isHeaderRead) {
            continue<span class="comment">;</span>
          }
        } 
        return count<span class="comment">;</span>
      }
    }
</pre></td></tr></table></figure>

<p>以上的处理均基于RPC中的数据格式，具体定义如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="comment">hadoop</span><span class="literal">-</span><span class="comment">2</span><span class="string">.</span><span class="comment">2</span><span class="string">.</span><span class="comment">0/hadoop</span><span class="literal">-</span><span class="comment">common</span><span class="literal">-</span><span class="comment">project/hadoop</span><span class="literal">-</span><span class="comment">common/src/main/proto/RpcHeader</span><span class="string">.</span><span class="comment">prot:</span>
<span class="comment">/**</span>
 <span class="comment">*</span> <span class="comment">This</span> <span class="comment">is</span> <span class="comment">the</span> <span class="comment">rpc</span> <span class="comment">request</span> <span class="comment">header</span><span class="string">.</span> <span class="comment">It</span> <span class="comment">is</span> <span class="comment">sent</span> <span class="comment">with</span> <span class="comment">every</span> <span class="comment">rpc</span> <span class="comment">call</span><span class="string">.</span>
 <span class="comment">*</span> 
 <span class="comment">*</span> <span class="comment">The</span> <span class="comment">format</span> <span class="comment">of</span> <span class="comment">RPC</span> <span class="comment">call</span> <span class="comment">is</span> <span class="comment">as</span> <span class="comment">follows:</span>
 <span class="comment">*</span> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">*</span> <span class="comment">|</span> <span class="comment">Rpc</span> <span class="comment">length</span> <span class="comment">in</span> <span class="comment">bytes</span> <span class="comment">(4</span> <span class="comment">bytes</span> <span class="comment">int)</span> <span class="comment">sum</span> <span class="comment">of</span> <span class="comment">next</span> <span class="comment">two</span> <span class="comment">parts</span>      <span class="comment">|</span>
 <span class="comment">*</span> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">*</span> <span class="comment">|</span> <span class="comment">RpcRequestHeaderProto</span> <span class="literal">-</span> <span class="comment">serialized</span> <span class="comment">delimited</span> <span class="comment">ie</span> <span class="comment">has</span> <span class="comment">len</span>      <span class="comment">|</span>
 <span class="comment">*</span> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">*</span> <span class="comment">|</span> <span class="comment">RpcRequest</span> <span class="comment">The</span> <span class="comment">actual</span> <span class="comment">rpc</span> <span class="comment">request</span>                            <span class="comment">|</span>
 <span class="comment">*</span> <span class="comment">|</span> <span class="comment">This</span> <span class="comment">request</span> <span class="comment">is</span> <span class="comment">serialized</span> <span class="comment">based</span> <span class="comment">on</span> <span class="comment">RpcKindProto</span>             <span class="comment">|</span>
 <span class="comment">*</span> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">*</span>
 <span class="comment">*/</span>
</pre></td></tr></table></figure>

<p>处理一个RPC请求：<br>processOneRpc() //首先处理RPC头<br>    —&gt;processRpcRequest() //RPC body部分的处理</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>    <span class="keyword">private</span> void processRpcRequest(RpcRequestHeaderProto header,
        DataInputStream dis) throws WrappedRpcServerException,
        InterruptedException {
      <span class="class"><span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> <span class="title">Writable</span>&gt; <span class="title">rpcRequestClass</span> = 
          <span class="title">getRpcRequestWrapper</span>(<span class="title">header</span>.<span class="title">getRpcKind</span>());
      ...

      <span class="title">Writable</span> <span class="title">rpcRequest</span>;
      <span class="title">try</span> {</span> <span class="comment">//Read the rpc request</span>
        <span class="comment">//基于反射机制创建相应的对象</span>
        rpcRequest = ReflectionUtils.newInstance(rpcRequestClass, conf);
        rpcRequest.readFields(dis);
      } <span class="keyword">catch</span> (Throwable t) { <span class="comment">// includes runtime exception from newInstance</span>
        ...
      }
      
      <span class="comment">/*将请求封装如Call对象，并插入callQueue中 , 待Handler线程来处理*/</span>
      Call call = <span class="keyword">new</span> Call(header.getCallId(), header.getRetryCount(),
          rpcRequest, <span class="keyword">this</span>, ProtoUtil.convert(header.getRpcKind()), header
              .getClientId().toByteArray());
      callQueue.put(call);              <span class="comment">// queue the call; maybe blocked here</span>
      incRpcCount();  <span class="comment">// Increment the rpc count</span>
    }
</pre></td></tr></table></figure>

<p>其中callQueue的定义为:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>callQueue  = new LinkedBlockingQueue&lt;<span class="operator"><span class="keyword">Call</span>&gt;(maxQueueSize);</span>
</pre></td></tr></table></figure>

<p>LinkedBlockingQueue：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt;<span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;<span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></span>
</pre></td></tr></table></figure>

<p>其实现了BlockingQueue接口,提供两个操作是：获取元素时等待队列变为非空，以及存储元素时等待空间变得可用。由此Reader线程与Handler线程间的通讯就可全部交由LinkedBlockingQueue类型的callQueue队列来完成， 想想Java开发的确是方便,有大量封装好的类可直接使用。</p>
<h3 id="Handler">Handler</h3>
<p>线程处理函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="code"><pre>    public void run() {
      <span class="transposed_variable">LOG.</span>debug(getName() + <span class="string">": starting"</span>);
      <span class="transposed_variable">SERVER.</span>set(<span class="transposed_variable">Server.</span>this);
      ByteArrayOutputStream buf = 
        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
      while (running) {
        <span class="keyword">try</span> {
          <span class="comment">//从callQueue队列中取一个待处理的元素</span>
          final Call call = <span class="transposed_variable">callQueue.</span>take(); <span class="comment">// pop the queue; maybe blocked here</span>
          ...

          <span class="transposed_variable">CurCall.</span>set(call);
          <span class="keyword">try</span> {
            <span class="comment">// Make the call as the user via Subject.doAs, thus associating</span>
            <span class="comment">// the call with the Subject</span>
            <span class="keyword">if</span> (<span class="transposed_variable">call.</span><span class="transposed_variable">connection.</span>user == null) {
              <span class="comment">//执行RPC function</span>
              value = call(<span class="transposed_variable">call.</span>rpcKind, <span class="transposed_variable">call.</span><span class="transposed_variable">connection.</span>protocolName, <span class="transposed_variable">call.</span>rpcRequest, 
                           <span class="transposed_variable">call.</span>timestamp);
            } <span class="keyword">else</span> {
              value = 
                <span class="transposed_variable">call.</span><span class="transposed_variable">connection.</span><span class="transposed_variable">user.</span>doAs
                  (new PrivilegedExceptionAction&lt;Writable&gt;() {
                     @Override
                     public Writable run() throws Exception {
                       <span class="comment">// make the call</span>
                       <span class="comment">//执行RPC function</span>
                       <span class="keyword">return</span> call(<span class="transposed_variable">call.</span>rpcKind, <span class="transposed_variable">call.</span><span class="transposed_variable">connection.</span>protocolName, 
                                   <span class="transposed_variable">call.</span>rpcRequest, <span class="transposed_variable">call.</span>timestamp);

                     }
                   }
                  );
            }
          }
          ...

          <span class="transposed_variable">CurCall.</span>set(null);
          synchronized (<span class="transposed_variable">call.</span><span class="transposed_variable">connection.</span>responseQueue) {
            <span class="comment">// setupResponse() needs to be sync'ed together with </span>
            <span class="comment">// responder.doResponse() since setupResponse may use</span>
            <span class="comment">// SASL to encrypt response data and SASL enforces</span>
            <span class="comment">// its own message ordering.</span>

            <span class="comment">//基于call 的执行结果封装创建Response结构体</span>
            setupResponse(buf, call, returnStatus, detailedErr, 
                value, errorClass, error);
            
            <span class="comment">// Discard the large buf and reset it back to smaller size </span>
            <span class="comment">// to free up heap</span>
            <span class="keyword">if</span> (<span class="transposed_variable">buf.</span><span class="built_in">size</span>() &gt; maxRespSize) {
              <span class="transposed_variable">LOG.</span>warn(<span class="string">"Large response size "</span> + <span class="transposed_variable">buf.</span><span class="built_in">size</span>() + <span class="string">" for call "</span>
                  + <span class="transposed_variable">call.</span>toString());
              buf = new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
            }
            <span class="transposed_variable">responder.</span>doRespond(call);
          }
        }
        ...
      }
      <span class="transposed_variable">LOG.</span>debug(getName() + <span class="string">": exiting"</span>);
    }
</pre></td></tr></table></figure>

<p>Responder</p>
<p>此处同样是将call添加至队列中，有responder线程循环处理队列中的每个元素，线程模型与前面的类似</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>    void doRespond(<span class="keyword">Call</span> <span class="keyword">call</span>) throws IOException {
      synchronized (<span class="keyword">call</span><span class="preprocessor">.connection</span><span class="preprocessor">.responseQueue</span>) {
        <span class="keyword">call</span><span class="preprocessor">.connection</span><span class="preprocessor">.responseQueue</span><span class="preprocessor">.addLast</span>(<span class="keyword">call</span>)<span class="comment">;</span>
        if (<span class="keyword">call</span><span class="preprocessor">.connection</span><span class="preprocessor">.responseQueue</span><span class="preprocessor">.size</span>() == <span class="number">1</span>) {
          processResponse(<span class="keyword">call</span><span class="preprocessor">.connection</span><span class="preprocessor">.responseQueue</span>, true)<span class="comment">;</span>
        }
      }
    }
</pre></td></tr></table></figure>

<p>核心的response处理函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre></td><td class="code"><pre>    private boolean processResponse(LinkedList&lt;<span class="keyword">Call</span>&gt; responseQueue,
                                    boolean inHandler) throws IOException {
      boolean error = true<span class="comment">;</span>
      boolean done = false<span class="comment">;       // there is more data for this channel.</span>
      int numElements = <span class="number">0</span><span class="comment">;</span>
      <span class="keyword">Call</span> <span class="keyword">call</span> = null<span class="comment">;</span>
      try {
        synchronized (responseQueue) {
          //
          // If there are no items for this channel, then we are done
          //
          numElements = responseQueue<span class="preprocessor">.size</span>()<span class="comment">;</span>
          if (numElements == <span class="number">0</span>) {
            error = false<span class="comment">;</span>
            return true<span class="comment">;              // no more data for this channel.</span>
          }
          //
          // Extract the first <span class="keyword">call</span>
          //
          <span class="keyword">call</span> = responseQueue<span class="preprocessor">.removeFirst</span>()<span class="comment">;</span>
          SocketChannel channel = <span class="keyword">call</span><span class="preprocessor">.connection</span><span class="preprocessor">.channel</span><span class="comment">;</span>
          if (LOG<span class="preprocessor">.isDebugEnabled</span>()) {
            LOG<span class="preprocessor">.debug</span>(getName() + <span class="string">": responding to "</span> + <span class="keyword">call</span>)<span class="comment">;</span>
          }
          //
          // Send as much data as we can <span class="keyword">in</span> the non-blocking fashion
          //
          int numBytes = channelWrite(channel, <span class="keyword">call</span><span class="preprocessor">.rpcResponse</span>)<span class="comment">;</span>
          if (numBytes &lt; <span class="number">0</span>) {
            return true<span class="comment">;</span>
          }
          if (!<span class="keyword">call</span><span class="preprocessor">.rpcResponse</span><span class="preprocessor">.hasRemaining</span>()) {
            //Clear <span class="keyword">out</span> the response buffer so it can be collected
            <span class="keyword">call</span><span class="preprocessor">.rpcResponse</span> = null<span class="comment">;</span>
            <span class="keyword">call</span><span class="preprocessor">.connection</span><span class="preprocessor">.decRpcCount</span>()<span class="comment">;</span>
            if (numElements == <span class="number">1</span>) {    // last <span class="keyword">call</span> fully processes.
              done = true<span class="comment">;             // no more data for this channel.</span>
            } else {
              done = false<span class="comment">;            // more calls pending to be sent.</span>
            }
            if (LOG<span class="preprocessor">.isDebugEnabled</span>()) {
              LOG<span class="preprocessor">.debug</span>(getName() + <span class="string">": responding to "</span> + <span class="keyword">call</span>
                  + <span class="string">" Wrote "</span> + numBytes + <span class="string">" bytes."</span>)<span class="comment">;</span>
            }
          } else {
            //
            // If we were unable to write the entire response <span class="keyword">out</span>, then 
            // insert <span class="keyword">in</span> Selector queue. 
            //
            <span class="keyword">call</span><span class="preprocessor">.connection</span><span class="preprocessor">.responseQueue</span><span class="preprocessor">.addFirst</span>(<span class="keyword">call</span>)<span class="comment">;</span>
            
            if (inHandler) {
              // <span class="keyword">set</span> the serve time when the response has to be sent later
              <span class="keyword">call</span><span class="preprocessor">.timestamp</span> = Time<span class="preprocessor">.now</span>()<span class="comment">;</span>
              
              incPending()<span class="comment">;</span>
              try {
                // Wakeup the thread blocked on select, only then can the <span class="keyword">call</span> 
                // to channel<span class="preprocessor">.register</span>() complete.
                writeSelector<span class="preprocessor">.wakeup</span>()<span class="comment">;</span>
                channel<span class="preprocessor">.register</span>(writeSelector, SelectionKey<span class="preprocessor">.OP</span>_WRITE, <span class="keyword">call</span>)<span class="comment">;</span>
              } catch (ClosedChannelException e) {
                //Its ok. channel might be closed else where.
                done = true<span class="comment">;</span>
              } finally {
                decPending()<span class="comment">;</span>
              }
            }
            if (LOG<span class="preprocessor">.isDebugEnabled</span>()) {
              LOG<span class="preprocessor">.debug</span>(getName() + <span class="string">": responding to "</span> + <span class="keyword">call</span>
                  + <span class="string">" Wrote partial "</span> + numBytes + <span class="string">" bytes."</span>)<span class="comment">;</span>
            }
          }
          error = false<span class="comment">;              // everything went off well</span>
        }
      } finally {
        if (error && <span class="keyword">call</span> != null) {
          LOG<span class="preprocessor">.warn</span>(getName()+<span class="string">", call "</span> + <span class="keyword">call</span> + <span class="string">": output error"</span>)<span class="comment">;</span>
          done = true<span class="comment">;               // error. no more data for this channel.</span>
          closeConnection(<span class="keyword">call</span><span class="preprocessor">.connection</span>)<span class="comment">;</span>
        }
      }
      return done<span class="comment">;</span>
    }
</pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-04T02:36:38.000Z"><a href="/2014/06/04/tcp-receive-packet/">6月 4 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/04/tcp-receive-packet/">TCP receive packet</a></h1>
  

    </header>
    <div class="entry">
      
        <p>sock_recvmsg()<br>    —&gt; inet_recvmsg()<br>        —&gt;tcp_recvmsg()</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="code"><pre>int tcp_v4_rcv(struct sk_buff *skb)
{
    <span class="keyword">...</span>

	inet_rps_save_rxhash(sk, skb-&gt;rxhash);

    /* keypoint: 在软中断上下中将数据包入到收包队列中 */

    /* 检查当前是否有用户进程在使用这个sock，如果有就直接将sk_buff入到
     * 用户进程sk_backlog队列中，当用户进程释放slock前，会处理sk_backlog
     * 队列中的数据包。
     * While locked, BH processing will add new packets to
     * the backlog queue.  This queue is processed by the
     * owner of the socket lock right before it is released.
     *
     * Since ~<span class="number">2.3</span><span class="number">.5</span> it is also exclusive sleep lock serializing
     * accesses from user process context.
     * */
	<span class="keyword">if</span> (!sock_owned_by_user(sk)) {
<span class="comment">#ifdef CONFIG_NET_DMA</span>
        /* 如果支持DMA，可将拷贝sk_buff至用户态缓存的工作交给DMA来处理
         * 找到dma_chan,直接调用tcp_v4_do_rcv()*/
		struct tcp_sock *tp = tcp_sk(sk);
		<span class="keyword">if</span> (!tp-&gt;ucopy.dma_chan && tp-&gt;ucopy.pinned_list)
			tp-&gt;ucopy.dma_chan = dma_find_channel(DMA_MEMCPY);
		<span class="keyword">if</span> (tp-&gt;ucopy.dma_chan)
			ret = tcp_v4_do_rcv(sk, skb);
		<span class="keyword">else</span>
<span class="comment">#endif</span>
		{
            /*将数据包先入到ucopy.prequeue队列中
             * tcp_prequeue() 
             *      //若开启tcp_low_latency或者ucopy.task为空则返回<span class="number">0</span>。
             *      //ucopy.task为空一般是表示进程空间有进程在等待sock
             *      //的数据的到来，因此我们需要直接复制数据到receive队
             *      //列。并唤醒它。
             *      <span class="keyword">if</span> (sysctl_tcp_low_latency || !tp-&gt;ucopy.task) 
             *           <span class="keyword">return</span> <span class="number">0</span>;
             *      __skb_queue_tail(&tp-&gt;ucopy.prequeue, skb);
             *      tp-&gt;ucopy.memory += skb-&gt;truesize;
             */
			<span class="keyword">if</span> (!tcp_prequeue(sk, skb))
				ret = tcp_v4_do_rcv(sk, skb);//将数据包直接入receive_queue
		}
	} <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(sk_add_backlog(sk, skb))) {
		bh_unlock_sock(sk);
		NET_INC_STATS_BH(net, LINUX_MIB_TCPBACKLOGDROP);
		goto discard_and_relse;
	}
	bh_unlock_sock(sk);
    <span class="keyword">...</span>
}
</pre></td></tr></table></figure>

<p>tcp_v4_do_rcv()<br>    —&gt;tcp_rcv_established()</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>tcp_rcv_established()
{
    <span class="keyword">...</span>

    __skb_pull(skb, tcp_header_len);
    /*将数据包添加到sk_receive_queue队列*/
    __skb_queue_tail(&sk-&gt;sk_receive_queue, skb);
    skb_set_owner_r(skb, sk);
    tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
    <span class="keyword">...</span>
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="keyword">int</span> tcp_recvmsg(struct kiocb <span class="variable">*iocb</span>, struct sock <span class="variable">*sk</span>, struct msghdr <span class="variable">*msg</span>,
		size_t len, <span class="keyword">int</span> nonblock, <span class="keyword">int</span> flags, <span class="keyword">int</span> <span class="variable">*addr_len</span>)
{
	struct tcp_sock <span class="variable">*tp</span> = tcp_sk(sk);
	<span class="keyword">int</span> copied = <span class="number">0</span>; <span class="regexp">/* 统计已经向用户态进程的缓冲区拷贝的数据量 */</span>
	u32 peek_seq;
	u32 <span class="variable">*seq</span>;
	unsigned long used;
	<span class="keyword">int</span> target;		<span class="regexp">/* Read at least this many bytes */</span>
	struct task_struct <span class="variable">*user_recv</span> = NULL;

    <span class="regexp">/* 持有当前sock结构的sk-&gt;sk_lock.slock , 
     * 若当前被其他的进程持有，则让出CPU睡眠等待，
     * 直至被唤醒*/</span>
	lock_sock(sk);

	TCP_CHECK_TIMER(sk);

    <span class="regexp">/* 依据当前是否是阻塞式读返回timer */</span>
	timeo = sock_rcvtimeo(sk, nonblock);

	<span class="regexp">/* Urgent data needs to be handled specially. */</span>
	<span class="keyword">if</span> (flags & MSG_OOB)
		<span class="keyword">goto</span> recv_urg;

    <span class="regexp">/*取得当前tcp字节流中的未读数据的起始序列号*/</span>
	seq = &tp-&gt;copied_seq;
	<span class="keyword">if</span> (flags & MSG_PEEK) {
		peek_seq = tp-&gt;copied_seq;
		seq = &peek_seq;
	}

    /*
       结合MSG_WAITALL 标志位决定本次需处理多少数据。MSG_WAITALL指明等待所有的数据到达才返回。
       man <span class="keyword">recv</span>:
       MSG_WAITALL (since Linux <span class="number">2.2</span>)
       This flag requests that the operation block <span class="keyword">until</span> the full request is satisfied.  However,  the  call  may
       still  <span class="keyword">return</span>  less  data than requested <span class="keyword">if</span> a signal is caught, an error <span class="keyword">or</span> disconnect occurs, <span class="keyword">or</span> the <span class="keyword">next</span>
       data to be received is of a different type than that returned.
       
       此处若MSG_WAITALL未被置位，则取len与sk_rcvlowat接收水位线两者中的较小值
       static inline <span class="keyword">int</span> sock_rcvlowat(const struct sock <span class="variable">*sk</span>, <span class="keyword">int</span> waitall, <span class="keyword">int</span> len)
       {
           <span class="keyword">return</span> (waitall ? len : min_t(<span class="keyword">int</span>, sk-&gt;sk_rcvlowat, len)) ? : <span class="number">1</span>;
       }
     <span class="variable">*/</span>
	target = sock_rcvlowat(sk, flags & MSG_WAITALL, len);
</pre></td></tr></table></figure>

<p>tcp_recvmsg() 主循环体：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
</pre></td><td class="code"><pre>do {
        /*循环遍历sk-&gt;sk_receive_queue链表，处理每个skb*/
	skb_queue_walk(&sk-&gt;sk_receive_queue, skb) {
		/* Now that we have two receive queues this
		 * shouldn't happen.
		 */
		if (WARN(before(*seq, TCP_SKB_CB(skb)-&gt;seq),
		     KERN_INFO <span class="string">"recvmsg bug: copied %X "</span>
			       <span class="string">"seq %X rcvnxt %X fl %X\n"</span>, *seq,
			       TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt,
			       flags))
			break;

		offset = *seq - TCP_SKB_CB(skb)-&gt;seq;
		if (tcp_hdr(skb)-&gt;syn) //如果为syn包，将跳过直接处理下一个数据包
			offset--;
		if (offset &lt; skb-&gt;len) //找到可被处理的skb,跳转至found_ok_skb tag 处理
			goto found_ok_skb;
		if (tcp_hdr(skb)-&gt;fin) //处理fin包
			goto found_fin_ok;
		WARN(!(flags & MSG_PEEK), KERN_INFO <span class="string">"recvmsg bug 2: "</span>
				<span class="string">"copied %X seq %X rcvnxt %X fl %X\n"</span>,
				*seq, TCP_SKB_CB(skb)-&gt;seq,
				tp-&gt;rcv_nxt, flags);
	}

        /*注意，当执行至这里时，意味着sk-&gt;sk_receive_queue队列已经为空，
          由此退出循环，执行至这里*/

        /*检查已经拷贝的数据量以及sk_backlog队列是否为空，
          若拷贝的数据值已经超过预期值，且sk_backlog队列为空
          则直接退出大循环*/
	if (copied &gt;= target && !sk-&gt;sk_backlog.tail)
		break;

        /*copied 有值表明已经拷贝了部分数据，做相关的错误检查及待处理的信号检查*/
	if (copied) {
		if (sk-&gt;sk_err ||
		    sk-&gt;sk_state == TCP_CLOSE ||
		    (sk-&gt;sk_shutdown & RCV_SHUTDOWN) ||
		    !timeo ||
		    signal_pending(current))
			break;
	} else {
            /* 若拷贝的数据量为零，检查是否有错误*/
		if (sock_flag(sk, SOCK_DONE))
			break;

		if (sk-&gt;sk_err) {
			copied = sock_error(sk);
			break;
		}

		if (sk-&gt;sk_shutdown & RCV_SHUTDOWN)
			break;

		if (sk-&gt;sk_state == TCP_CLOSE) {
			if (!sock_flag(sk, SOCK_DONE)) {
				/* This occurs when user tries to read
				 * from never connected socket.
				 */
				copied = -ENOTCONN;
				break;
			}
			break;
		}

		if (!timeo) {
			copied = -EAGAIN;
			break;
		}

		if (signal_pending(current)) {
			copied = sock_intr_errno(timeo);
			break;
		}
	}

        //在向用户态拷贝了一定量的数据后，向对端发送ACK包以确认本端已收到数据
	tcp_cleanup_rbuf(sk, copied);

        /* 检查tcp_low_latency标志是否置位，若置位则表示数据包将直接入receive_queue队列，
           而不会入sock的prequeue队列，由此无需由prequeue队列将数据包向receive_queue队列
           转 */
	if (!sysctl_tcp_low_latency && tp-&gt;ucopy.task == user_recv) {
		/* Install new reader */
		if (!user_recv && !(flags & (MSG_TRUNC | MSG_PEEK))) {
			user_recv = current;
			tp-&gt;ucopy.task = user_recv;
			tp-&gt;ucopy.iov = msg-&gt;msg_iov;
		}

		tp-&gt;ucopy.len = len;

		WARN_ON(tp-&gt;copied_seq != tp-&gt;rcv_nxt &&
			!(flags & (MSG_PEEK | MSG_TRUNC)));

		/* Ugly... If prequeue is not empty, we have to
		 * process it before releasing socket, otherwise
		 * order will be broken at second iteration.
		 * More elegant solution is required!!!
		 *
		 * Look: we have the following (pseudo)queues:
		 *
		 * 1. packets in flight
		 * 2. backlog
		 * 3. prequeue
		 * 4. receive_queue
		 *
		 * Each queue can be processed only if the next ones
		 * are empty. At this point we have empty receive_queue.
		 * But prequeue _can_ be not empty after 2nd iteration,
		 * when we jumped to start of loop because backlog
		 * processing added something to receive_queue.
		 * We cannot release_sock(), because backlog contains
		 * packets arrived _after_ prequeued ones.
		 *
		 * Shortly, algorithm is clear --- to process all
		 * the queues in order. We could make it more directly,
		 * requeueing packets from backlog to prequeue, if
		 * is not empty. It is more elegant, but eats cycles,
		 * unfortunately.
		 */

            /*若ucopy.prequeue 队列不为空，则跳转至do_prequeue tag将ucopy.prequeue队列
             *中的数据移动至receive_queue队列,注意跳转后在移动完数据包后将继续外层的大循环
             *而回至程序的开头开始遍历receive_queue队列*/
		if (!skb_queue_empty(&tp-&gt;ucopy.prequeue))
			goto do_prequeue;

		/* __ Set realtime policy in scheduler __ */
	}

        /* 执行至此表示ucopy.prequeue队列已经为空 */
        /* 检查已拷贝的数据是否已经满足预期要拷贝的数据，若不足
           将睡眠等待数据的到来*/
	if (copied &gt;= target) {
		/* Do not sleep, just process backlog. */
            /* release_sock()函数中将开始遍历sk-&gt;sk_backlog队列，将其中的数据包添加至receive_queue 队列中 */
		release_sock(sk);
		lock_sock(sk);
	} else
		sk_wait_data(sk, &timeo);

<span class="comment">#ifdef CONFIG_NET_DMA</span>
	tp-&gt;ucopy.wakeup = 0;
<span class="comment">#endif</span>

	if (user_recv) {
		int chunk;

		/* __ Restore normal policy in scheduler __ */

		if ((chunk = len - tp-&gt;ucopy.len) != 0) {
			NET_ADD_STATS_USER(sock_net(sk), LINUX_MIB_TCPDIRECTCOPYFROMBACKLOG, chunk);
			len -= chunk;
			copied += chunk;
		}

		if (tp-&gt;rcv_nxt == tp-&gt;copied_seq &&
		    !skb_queue_empty(&tp-&gt;ucopy.prequeue)) {
<span class="title">do_prequeue:</span>
                /* 将prequeue中的数据转至receive_queue*/
			tcp_prequeue_process(sk);

			if ((chunk = len - tp-&gt;ucopy.len) != 0) {
				NET_ADD_STATS_USER(sock_net(sk), LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE, chunk);
				len -= chunk;
				copied += chunk;
			}
		}
	}
	if ((flags & MSG_PEEK) &&
	    (peek_seq - copied - urg_hole != tp-&gt;copied_seq)) {
		if (net_ratelimit())
			printk(KERN_DEBUG <span class="string">"TCP(%s:%d): Application bug, race in MSG_PEEK.\n"</span>,
			       current-&gt;comm, task_pid_nr(current));
		peek_seq = tp-&gt;copied_seq;
	}
	continue;

<span class="title">found_ok_skb:</span>
	/* Ok so how much can we use? */
	used = skb-&gt;len - offset;
	if (len &lt; used)
		used = len;

	/* Do we have urgent data here? */
	if (tp-&gt;urg_data) {
		u32 urg_offset = tp-&gt;urg_seq - *seq;
		if (urg_offset &lt; used) {
			if (!urg_offset) {
				if (!sock_flag(sk, SOCK_URGINLINE)) {
					++*seq;
					urg_hole++;
					offset++;
					used--;
					if (!used)
						goto skip_copy;
				}
			} else
				used = urg_offset;
		}
	}

	if (!(flags & MSG_TRUNC)) {
<span class="comment">#ifdef CONFIG_NET_DMA</span>
            /* 若支持DMA，则获取相应的DMA通道，将数据拷贝的工作交由DMA处理*/
		if (!tp-&gt;ucopy.dma_chan && tp-&gt;ucopy.pinned_list)
			tp-&gt;ucopy.dma_chan = dma_find_channel(DMA_MEMCPY);

		if (tp-&gt;ucopy.dma_chan) {
			tp-&gt;ucopy.dma_cookie = dma_skb_copy_datagram_iovec(
				tp-&gt;ucopy.dma_chan, skb, offset,
				msg-&gt;msg_iov, used,
				tp-&gt;ucopy.pinned_list);

			if (tp-&gt;ucopy.dma_cookie &lt; 0) {

				printk(KERN_ALERT <span class="string">"dma_cookie &lt; 0\n"</span>);

				/* Exception. Bailout! */
				if (!copied)
					copied = -EFAULT;
				break;
			}
			if ((offset + used) == skb-&gt;len)
				copied_early = 1;

		} else
<span class="comment">#endif</span>
		{
                /* 将数据拷贝至用户缓冲区中 */
			err = skb_copy_datagram_iovec(skb, offset,
					msg-&gt;msg_iov, used);
			if (err) {
				/* Exception. Bailout! */
				if (!copied)
					copied = -EFAULT;
				break;
			}
		}
	}

        /* 更新统计值及数据包的seq号 */
	*seq += used;
	copied += used;
	len -= used;

        /*调整tcp收包缓冲区的大小，相应的调整TCP通告窗口的大小*/
	tcp_rcv_space_adjust(sk);

<span class="title">skip_copy:</span>
	if (tp-&gt;urg_data && after(tp-&gt;copied_seq, tp-&gt;urg_seq)) {
		tp-&gt;urg_data = 0;
		tcp_fast_path_check(sk);
	}
	if (used + offset &lt; skb-&gt;len)
		continue;

	if (tcp_hdr(skb)-&gt;fin)
		goto found_fin_ok;
        /*KEY: 处理MSG_PEEK标志位，MSG_PEEK置位表明应用不希望缓冲区中的数据在已经被应用接收后被内核删除掉，由此在下一次
          应用读取套接字时，从缓冲区中读出的数据仍是此前接收到的数据。
          man recv: 
          MSG_PEEK
          This  flag  causes  the  receive  operation to return data from the beginning of the receive queue without
          removing that data from the queue.  Thus, a subsequent receive call will return the same data.

          若MSG_PEEK置位，则不删除已经拷贝至用户缓冲区的skb，否则将其从receive_queue链表中删除并调用kfree()释放掉skb数据包
         */
	if (!(flags & MSG_PEEK)) {
		sk_eat_skb(sk, skb, copied_early);
		copied_early = 0;
	}
        /* 继续下一次的循环处理 */
	continue;

<span class="title">found_fin_ok:</span>
	/* Process the FIN. */
	++*seq;
	if (!(flags & MSG_PEEK)) {
		sk_eat_skb(sk, skb, copied_early);
		copied_early = 0;
	}
	break;
} while (len &gt; 0);
</pre></td></tr></table></figure>

<p>tcp_recvmsg() 退出主循环:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre></td><td class="code"><pre><span class="keyword">if</span> (user_recv) {
	<span class="keyword">if</span> (!skb_queue_empty(&tp-&gt;ucopy.prequeue)) {
		<span class="keyword">int</span> chunk;

		tp-&gt;ucopy.len = copied &gt; <span class="number">0</span> ? len : <span class="number">0</span>;

		tcp_prequeue_process(sk);

		<span class="keyword">if</span> (copied &gt; <span class="number">0</span> && (chunk = len - tp-&gt;ucopy.len) != <span class="number">0</span>) {
			NET_ADD_STATS_USER(sock_net(sk), LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE, chunk);
			len -= chunk;
			copied += chunk;
		}
	}

	tp-&gt;ucopy.task = NULL;
	tp-&gt;ucopy.len = <span class="number">0</span>;
}

<span class="comment">#ifdef CONFIG_NET_DMA</span>
<span class="keyword">if</span> (tp-&gt;ucopy.dma_chan) {
	dma_cookie_t done, used;

	dma_async_memcpy_issue_pending(tp-&gt;ucopy.dma_chan);

	<span class="keyword">while</span> (dma_async_memcpy_complete(tp-&gt;ucopy.dma_chan,
					 tp-&gt;ucopy.dma_cookie, &done,
					 &used) == DMA_IN_PROGRESS) {
		<span class="regexp">/* do partial cleanup of sk_async_wait_queue */</span>
		<span class="keyword">while</span> ((skb = skb_peek(&sk-&gt;sk_async_wait_queue)) &&
		       (dma_async_is_complete(skb-&gt;dma_cookie, done,
					      used) == DMA_SUCCESS)) {
			__skb_dequeue(&sk-&gt;sk_async_wait_queue);
			kfree_skb(skb);
		}
	}

	/* Safe to free early-copied skbs now <span class="variable">*/</span>
	__skb_queue_purge(&sk-&gt;sk_async_wait_queue);
	tp-&gt;ucopy.dma_chan = NULL;
}
<span class="keyword">if</span> (tp-&gt;ucopy.pinned_list) {
	dma_unpin_iovec_pages(tp-&gt;ucopy.pinned_list);
	tp-&gt;ucopy.pinned_list = NULL;
}
<span class="comment">#endif</span>

/* According to UNIX98, msg_name/msg_namelen are ignored
 * on connected <span class="keyword">socket</span>. I was just happy <span class="keyword">when</span> found this <span class="number">8</span>) --ANK
 <span class="variable">*/</span>

/* Clean up data we have <span class="keyword">read</span>: This will <span class="keyword">do</span> ACK frames. <span class="variable">*/</span>
tcp_cleanup_rbuf(sk, copied);

TCP_CHECK_TIMER(sk);
release_sock(sk);
<span class="keyword">return</span> copied;

out:
TCP_CHECK_TIMER(sk);
release_sock(sk);
<span class="keyword">return</span> err;

recv_urg:
err = tcp_recv_urg(sk, msg, len, flags);
<span class="keyword">goto</span> out;
}
</pre></td></tr></table></figure>

<p>/<em> 在拷贝一定的数据给user后，发送ACK给对端，调整windows的大小</em>/<br>tcp_cleanup_rbuf()</p>
<p>/*</p>
<ul>
<li>This function should be called every time data is copied to user space.</li>
<li>It calculates the appropriate TCP receive buffer space.</li>
<li>在拷贝数据包至用户空间后，调整收包缓存，并相应的调整TCP 通告窗口的大小<br><em>/<br>tcp_rcv_space_adjust()<br>{<br> /</em> Make the window clamp follow along.  */<br> tp-&gt;window_clamp = new_clamp;<br>}<br>tcp_init_buffer_space() //初始化分配</li>
</ul>
<p>MSG_WAITALL (since Linux 2.2)<br>    This flag requests that the operation block until the full request is satisfied.  However,  the  call  may<br>    still  return  less  data than requested if a signal is caught, an error or disconnect occurs, or the next<br>    data to be received is of a different type than that returned.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-02T02:33:59.000Z"><a href="/2014/06/02/yarn-fair-schedule-调度算法/">6月 2 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/02/yarn-fair-schedule-调度算法/">Yarn Fair-schedule 调度算法</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Fair Schedule调度算法与Capacity Schedule调度算法有着类似的处理逻辑，其在分配资源时将同样经过三个层级的分配：队列，job，task，不同之处在于其对三个层级队列提供了三种可配置的排序方式，FIFO，DRF<br>DominantResourceFairnessComparator</p>
<p>ResourceWeights 类描述了多个维度的资源，数据成员weights中包含的是各个维度的资源占总资源的份额，当前支持两个维度的资源：MEMORY，CPU</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="title">public</span> <span class="class"><span class="keyword">class</span> <span class="type">ResourceWeights</span> {
  public static final <span class="type">ResourceWeights</span> <span class="type">NEUTRAL</span> = new <span class="type">ResourceWeights</span><span class="container">(1.0<span class="title">f</span>)</span>; //将各个维度的资源为100%

  private float[] weights = new float[<span class="type">ResourceType</span>.values<span class="container">()</span>.length];

  public <span class="type">ResourceWeights</span><span class="container">(<span class="title">float</span> <span class="title">memoryWeight</span>, <span class="title">float</span> <span class="title">cpuWeight</span>)</span> {
    weights[<span class="type">ResourceType</span>.<span class="type">MEMORY</span>.ordinal<span class="container">()</span>] = memoryWeight;
    weights[<span class="type">ResourceType</span>.<span class="type">CPU</span>.ordinal<span class="container">()</span>] = cpuWeight;
  }

  public <span class="type">ResourceWeights</span><span class="container">(<span class="title">float</span> <span class="title">weight</span>)</span> {
    for <span class="container">(<span class="title">int</span> <span class="title">i</span> = 0; <span class="title">i</span> &lt; <span class="title">weights</span>.<span class="title">length</span>; <span class="title">i</span>++)</span> {
      weights[i] = weight;
    }
  }

  public void setWeight<span class="container">(<span class="type">ResourceType</span> <span class="title">resourceType</span>, <span class="title">float</span> <span class="title">weight</span>)</span> {
    weights[resourceType.ordinal<span class="container">()</span>] = weight;
  }
  
  public float getWeight<span class="container">(<span class="type">ResourceType</span> <span class="title">resourceType</span>)</span> {
    return weights[resourceType.ordinal<span class="container">()</span>];
  }
  ...
}</span>
</pre></td></tr></table></figure>

<p>DominantResourceFairnessPolicy类实现了DRF算法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
</pre></td><td class="code"><pre>    <span class="javadoc">/**
     * Calculates and orders a resource's share of a pool in terms of two vectors.
     * The shares vector contains, for each resource, the fraction of the pool that
     * it takes up.  The resourceOrder vector contains an ordering of resources
     * by largest share.  So if resource=&lt;10 MB, 5 CPU&gt;, and pool=&lt;100 MB, 10 CPU&gt;,
     * shares will be [.1, .5] and resourceOrder will be [CPU, MEMORY].
     */</span>
    <span class="comment">//定义了如何去计算各个维度的资源,并会对各个维度的资源占比做个排序，</span>
    <span class="comment">//方便后续获得主资源，英文注释中给出了很清晰的例子</span>
    <span class="keyword">void</span> calculateShares(Resource resource, Resource pool,
        ResourceWeights shares, ResourceType[] resourceOrder, ResourceWeights weights) {
      shares.setWeight(MEMORY, (<span class="keyword">float</span>)resource.getMemory() /
          (pool.getMemory() * weights.getWeight(MEMORY))); 
      shares.setWeight(CPU, (<span class="keyword">float</span>)resource.getVirtualCores() /
          (pool.getVirtualCores() * weights.getWeight(CPU)));
      <span class="comment">// sort order vector by resource share</span>
      <span class="keyword">if</span> (resourceOrder != <span class="keyword">null</span>) {
        <span class="keyword">if</span> (shares.getWeight(MEMORY) &gt; shares.getWeight(CPU)) {
          resourceOrder[<span class="number">0</span>] = MEMORY;
          resourceOrder[<span class="number">1</span>] = CPU;
        } <span class="keyword">else</span>  {
          resourceOrder[<span class="number">0</span>] = CPU;
          resourceOrder[<span class="number">1</span>] = MEMORY;
        }
      }
    }

    <span class="annotation">@Override</span>
    <span class="comment">//用以实现s1,s2两个多维度资源的主资源间的比较</span>
    <span class="keyword">public</span> <span class="keyword">int</span> compare(Schedulable s1, Schedulable s2) {
      ResourceWeights sharesOfCluster1 = <span class="keyword">new</span> ResourceWeights();
      ResourceWeights sharesOfCluster2 = <span class="keyword">new</span> ResourceWeights();
      ResourceWeights sharesOfMinShare1 = <span class="keyword">new</span> ResourceWeights();
      ResourceWeights sharesOfMinShare2 = <span class="keyword">new</span> ResourceWeights();
      ResourceType[] resourceOrder1 = <span class="keyword">new</span> ResourceType[NUM_RESOURCES];
      ResourceType[] resourceOrder2 = <span class="keyword">new</span> ResourceType[NUM_RESOURCES];
      
      <span class="comment">// Calculate shares of the cluster for each resource both schedulables.</span>
      calculateShares(s1.getResourceUsage(),
          clusterCapacity, sharesOfCluster1, resourceOrder1, s1.getWeights()); <span class="comment">//依据s1的权重来计算其资源占比的份额</span>
      calculateShares(s1.getResourceUsage(),
          s1.getMinShare(), sharesOfMinShare1, <span class="keyword">null</span>, ResourceWeights.NEUTRAL); <span class="comment">//对队列而言，需要获取</span>
      calculateShares(s2.getResourceUsage(),
          clusterCapacity, sharesOfCluster2, resourceOrder2, s2.getWeights());
      calculateShares(s2.getResourceUsage(),
          s2.getMinShare(), sharesOfMinShare2, <span class="keyword">null</span>, ResourceWeights.NEUTRAL);
      
      <span class="comment">// A queue is needy for its min share if its dominant resource</span>
      <span class="comment">// (with respect to the cluster capacity) is below its configured min share</span>
      <span class="comment">// for that resource</span>
      <span class="comment">//检查二者的主资源份额是否低于队列所设置的最低资源分配额(主/min &lt; 1),</span>
      <span class="comment">//若低于则表明亟需被调度以分配资源</span>
      <span class="keyword">boolean</span> s1Needy = sharesOfMinShare1.getWeight(resourceOrder1[<span class="number">0</span>]) &lt; <span class="number">1.0</span>f;
      <span class="keyword">boolean</span> s2Needy = sharesOfMinShare2.getWeight(resourceOrder2[<span class="number">0</span>]) &lt; <span class="number">1.0</span>f;
      
      <span class="keyword">int</span> res = <span class="number">0</span>;
      <span class="keyword">if</span> (!s2Needy && !s1Needy) {
        res = compareShares(sharesOfCluster1, sharesOfCluster2,
            resourceOrder1, resourceOrder2);
      } <span class="keyword">else</span> <span class="keyword">if</span> (s1Needy && !s2Needy) {
        res = -<span class="number">1</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (s2Needy && !s1Needy) {
        res = <span class="number">1</span>;
      } <span class="keyword">else</span> { <span class="comment">// both are needy below min share</span>
        res = compareShares(sharesOfMinShare1, sharesOfMinShare2,
            resourceOrder1, resourceOrder2);
      }
      <span class="comment">//当两者的主资源份额相同时，将比较二者的启动时间已决定谁先被调度</span>
      <span class="keyword">if</span> (res == <span class="number">0</span>) {
        <span class="comment">// Apps are tied in fairness ratio. Break the tie by submit time.</span>
        res = (<span class="keyword">int</span>)(s1.getStartTime() - s2.getStartTime());
      }
      <span class="keyword">return</span> res;
    }

    <span class="keyword">private</span> <span class="keyword">int</span> compareShares(ResourceWeights shares1, ResourceWeights shares2,
        ResourceType[] resourceOrder1, ResourceType[] resourceOrder2) {
      <span class="comment">//首先比较shares1与shares2的主资源，若一样则再比较次资源</span>
      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resourceOrder1.length; i++) {
        <span class="keyword">int</span> ret = (<span class="keyword">int</span>)Math.signum(shares1.getWeight(resourceOrder1[i])
            - shares2.getWeight(resourceOrder2[i]));
        <span class="keyword">if</span> (ret != <span class="number">0</span>) {
          <span class="keyword">return</span> ret;
        }
      }
      <span class="keyword">return</span> <span class="number">0</span>;
    }
</pre></td></tr></table></figure>

<h3 id="-8d44-6e90-5206-914d-">资源分配</h3>
<p>FairScheduler公平调度器同样需要处理NODE_UPDATE事件来完成资源的分配,其执行处理过程类似Capacity</p>
<p>nodeUpdate()<br>    —&gt;assignContainer() // Parent<br>        —&gt;assignContainer() // Child</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
</pre></td><td class="code"><pre><span class="transposed_variable">FairScheduler.</span>java:
  private synchronized void nodeUpdate(RMNode nm) {
    <span class="keyword">if</span> (<span class="transposed_variable">LOG.</span>isDebugEnabled()) {
      <span class="transposed_variable">LOG.</span>debug(<span class="string">"nodeUpdate: "</span> + nm + <span class="string">" cluster capacity: "</span> + clusterCapacity);
    }
    <span class="transposed_variable">eventLog.</span>log(<span class="string">"HEARTBEAT"</span>, <span class="transposed_variable">nm.</span>getHostName());
    FSSchedulerNode node = <span class="transposed_variable">nodes.</span>get(<span class="transposed_variable">nm.</span>getNodeID());

    List&lt;UpdatedContainerInfo&gt; containerInfoList = <span class="transposed_variable">nm.</span>pullContainerUpdates();
    List&lt;ContainerStatus&gt; newlyLaunchedContainers = new ArrayList&lt;ContainerStatus&gt;();
    List&lt;ContainerStatus&gt; completedContainers = new ArrayList&lt;ContainerStatus&gt;();
    <span class="keyword">for</span>(UpdatedContainerInfo containerInfo : containerInfoList) {
      <span class="transposed_variable">newlyLaunchedContainers.</span>addAll(<span class="transposed_variable">containerInfo.</span>getNewlyLaunchedContainers());
      <span class="transposed_variable">completedContainers.</span>addAll(<span class="transposed_variable">containerInfo.</span>getCompletedContainers());
    } 

    <span class="comment">// Processing the newly launched containers</span>
    <span class="keyword">for</span> (ContainerStatus launchedContainer : newlyLaunchedContainers) {
      containerLaunchedOnNode(<span class="transposed_variable">launchedContainer.</span>getContainerId(), node);
    }

    <span class="comment">// Process completed containers</span>
    <span class="keyword">for</span> (ContainerStatus completedContainer : completedContainers) {
      ContainerId containerId = <span class="transposed_variable">completedContainer.</span>getContainerId();
      <span class="transposed_variable">LOG.</span>debug(<span class="string">"Container FINISHED: "</span> + containerId);
      completedContainer(getRMContainer(containerId),
          completedContainer, <span class="transposed_variable">RMContainerEventType.</span>FINISHED);
    }

    <span class="comment">// Assign new containers...</span>
    <span class="comment">// 1. Check for reserved applications</span>
    <span class="comment">// 2. Schedule if there are no reservations</span>

    AppSchedulable reservedAppSchedulable = <span class="transposed_variable">node.</span>getReservedAppSchedulable();
    <span class="keyword">if</span> (reservedAppSchedulable != null) {
      Priority reservedPriority = <span class="transposed_variable">node.</span>getReservedContainer().getReservedPriority();
      <span class="keyword">if</span> (reservedAppSchedulable != null &&
          !<span class="transposed_variable">reservedAppSchedulable.</span>hasContainerForNode(reservedPriority, node)) {
        <span class="comment">// Don't hold the reservation if app can no longer use it</span>
        <span class="transposed_variable">LOG.</span>info(<span class="string">"Releasing reservation that cannot be satisfied for application "</span>
            + <span class="transposed_variable">reservedAppSchedulable.</span>getApp().getApplicationAttemptId()
            + <span class="string">" on node "</span> + nm);
        <span class="transposed_variable">reservedAppSchedulable.</span>unreserve(reservedPriority, node);
        reservedAppSchedulable = null;
      } <span class="keyword">else</span> {
        <span class="comment">// Reservation exists; try to fulfill the reservation</span>
        <span class="transposed_variable">LOG.</span>info(<span class="string">"Trying to fulfill reservation for application "</span>
            + <span class="transposed_variable">reservedAppSchedulable.</span>getApp().getApplicationAttemptId()
            + <span class="string">" on node: "</span> + nm);

        <span class="transposed_variable">node.</span>getReservedAppSchedulable().assignReservedContainer(node);
      }
    }
    <span class="keyword">if</span> (reservedAppSchedulable == null) {
      <span class="comment">// No reservation, schedule at queue which is farthest below fair share</span>
      int assignedContainers = <span class="number">0</span>;
      while (<span class="transposed_variable">node.</span>getReservedContainer() == null) {
        boolean assignedContainer = false;
        <span class="keyword">if</span> (<span class="transposed_variable">Resources.</span>greaterThan(RESOURCE_CALCULATOR, clusterCapacity,
              <span class="transposed_variable">queueMgr.</span>getRootQueue().assignContainer(node), <span class="comment">//在此尝试循环分配资源，直至无法分配为止</span>
              <span class="transposed_variable">Resources.</span>none())) {
          assignedContainers++;
          assignedContainer = true;
        }
        <span class="keyword">if</span> (!assignedContainer) { <span class="keyword">break</span>; }
        <span class="keyword">if</span> (!assignMultiple) { <span class="keyword">break</span>; }
        <span class="keyword">if</span> ((assignedContainers &gt;= maxAssign) && (maxAssign &gt; <span class="number">0</span>)) { <span class="keyword">break</span>; }
      }
    }
    updateRootQueueMetrics();
  }

<span class="transposed_variable">FSParentQueue.</span>java:
  public Resource assignContainer(FSSchedulerNode node) {
    Resource assigned = <span class="transposed_variable">Resources.</span>none();

    <span class="comment">// If this queue is over its limit, reject</span>
    <span class="keyword">if</span> (!assignContainerPreCheck(node)) {
      <span class="keyword">return</span> assigned;
    }

    <span class="comment">//首先依据排序的策略对所有的子队列进行排序，然后再依次遍历各个子队列在子队列上进行实际的分配操作</span>
    <span class="transposed_variable">Collections.</span>sort(childQueues, <span class="transposed_variable">policy.</span>getComparator());
    <span class="keyword">for</span> (FSQueue child : childQueues) {
      assigned = <span class="transposed_variable">child.</span>assignContainer(node);
      <span class="keyword">if</span> (!<span class="transposed_variable">Resources.</span>equals(assigned, <span class="transposed_variable">Resources.</span>none())) { <span class="comment">//如若未分配则跳出</span>
        <span class="keyword">break</span>;
      }
    }
    <span class="keyword">return</span> assigned;
  }

<span class="transposed_variable">FSLeafQueue.</span>java:
  public Resource assignContainer(FSSchedulerNode node) {
    Resource assigned = <span class="transposed_variable">Resources.</span>none();
    <span class="keyword">if</span> (<span class="transposed_variable">LOG.</span>isDebugEnabled()) {
      <span class="transposed_variable">LOG.</span>debug(<span class="string">"Node offered to queue: "</span> + getName());
    }

    <span class="keyword">if</span> (!assignContainerPreCheck(node)) {
      <span class="keyword">return</span> assigned;
    }

    <span class="comment">//首先依据排序的策略对当前队列的job进行排序，然</span>
    <span class="comment">//后再依次处理各个job</span>
    Comparator&lt;Schedulable&gt; comparator = <span class="transposed_variable">policy.</span>getComparator();
    <span class="transposed_variable">Collections.</span>sort(appScheds, comparator);
    <span class="keyword">for</span> (AppSchedulable sched : appScheds) {
      <span class="keyword">if</span> (<span class="transposed_variable">sched.</span>getRunnable()) {
        assigned = <span class="transposed_variable">sched.</span>assignContainer(node);
        <span class="keyword">if</span> (!<span class="transposed_variable">assigned.</span>equals(<span class="transposed_variable">Resources.</span>none())) {
          <span class="keyword">break</span>;
        }
      }
    }
    <span class="keyword">return</span> assigned;
  }

<span class="transposed_variable">AppSchedulable.</span>java:
  private Resource assignContainer(FSSchedulerNode node, boolean reserved) {
    <span class="transposed_variable">LOG.</span>info(<span class="string">"Node offered to app: "</span> + getName() + <span class="string">" reserved: "</span> + reserved);

    <span class="keyword">if</span> (reserved) {
      RMContainer rmContainer = <span class="transposed_variable">node.</span>getReservedContainer();
      Priority priority = <span class="transposed_variable">rmContainer.</span>getReservedPriority();

      <span class="comment">// Make sure the application still needs requests at this priority</span>
      <span class="keyword">if</span> (<span class="transposed_variable">app.</span>getTotalRequiredResources(priority) == <span class="number">0</span>) {
        unreserve(priority, node);
        <span class="keyword">return</span> <span class="transposed_variable">Resources.</span>none();
      }
    } <span class="keyword">else</span> {
      <span class="comment">// If this app is over quota, don't schedule anything</span>
      <span class="keyword">if</span> (!(getRunnable())) { <span class="keyword">return</span> <span class="transposed_variable">Resources.</span>none(); }
    }

    Collection&lt;Priority&gt; prioritiesToTry = (reserved) ? 
        <span class="transposed_variable">Arrays.</span>asList(<span class="transposed_variable">node.</span>getReservedContainer().getReservedPriority()) : 
        <span class="transposed_variable">app.</span>getPriorities();
    
    <span class="comment">// For each priority, see if we can schedule a node local, rack local</span>
    <span class="comment">// or off-switch request. Rack of off-switch requests may be delayed</span>
    <span class="comment">// (not scheduled) in order to promote better locality.</span>
    synchronized (app) {
      <span class="keyword">for</span> (Priority priority : prioritiesToTry) {
        <span class="keyword">if</span> (<span class="transposed_variable">app.</span>getTotalRequiredResources(priority) &lt;= <span class="number">0</span> ||
            !hasContainerForNode(priority, node)) {
          <span class="keyword">continue</span>;
        }
        
        <span class="transposed_variable">app.</span>addSchedulingOpportunity(priority);

        ResourceRequest rackLocalRequest = <span class="transposed_variable">app.</span>getResourceRequest(priority,
            <span class="transposed_variable">node.</span>getRackName());
        ResourceRequest localRequest = <span class="transposed_variable">app.</span>getResourceRequest(priority,
            <span class="transposed_variable">node.</span>getNodeName());
        
        <span class="keyword">if</span> (localRequest != null && !<span class="transposed_variable">localRequest.</span>getRelaxLocality()) {
          <span class="transposed_variable">LOG.</span>warn(<span class="string">"Relax locality off is not supported on local request: "</span>
              + localRequest);
        }
        
        NodeType allowedLocality = <span class="transposed_variable">app.</span>getAllowedLocalityLevel(priority,
            <span class="transposed_variable">scheduler.</span>getNumClusterNodes(), <span class="transposed_variable">scheduler.</span>getNodeLocalityThreshold(),
            <span class="transposed_variable">scheduler.</span>getRackLocalityThreshold());
        
        <span class="keyword">if</span> (rackLocalRequest != null && <span class="transposed_variable">rackLocalRequest.</span>getNumContainers() != <span class="number">0</span>
            && localRequest != null && <span class="transposed_variable">localRequest.</span>getNumContainers() != <span class="number">0</span>) {
          <span class="keyword">return</span> assignContainer(node, priority,
              localRequest, <span class="transposed_variable">NodeType.</span>NODE_LOCAL, reserved);
        }
        
        <span class="keyword">if</span> (rackLocalRequest != null && !<span class="transposed_variable">rackLocalRequest.</span>getRelaxLocality()) {
          <span class="keyword">continue</span>;
        }

        <span class="keyword">if</span> (rackLocalRequest != null && <span class="transposed_variable">rackLocalRequest.</span>getNumContainers() != <span class="number">0</span>
            && (<span class="transposed_variable">allowedLocality.</span>equals(<span class="transposed_variable">NodeType.</span>RACK_LOCAL) ||
                <span class="transposed_variable">allowedLocality.</span>equals(<span class="transposed_variable">NodeType.</span>OFF_SWITCH))) {
          <span class="keyword">return</span> assignContainer(node, priority, rackLocalRequest,
              <span class="transposed_variable">NodeType.</span>RACK_LOCAL, reserved);
        }

        ResourceRequest offSwitchRequest = <span class="transposed_variable">app.</span>getResourceRequest(priority,
            <span class="transposed_variable">ResourceRequest.</span>ANY);
        <span class="keyword">if</span> (offSwitchRequest != null && !<span class="transposed_variable">offSwitchRequest.</span>getRelaxLocality()) {
          <span class="keyword">continue</span>;
        }
        
        <span class="keyword">if</span> (offSwitchRequest != null && <span class="transposed_variable">offSwitchRequest.</span>getNumContainers() != <span class="number">0</span>
            && <span class="transposed_variable">allowedLocality.</span>equals(<span class="transposed_variable">NodeType.</span>OFF_SWITCH)) {
          <span class="keyword">return</span> assignContainer(node, priority, offSwitchRequest,
              <span class="transposed_variable">NodeType.</span>OFF_SWITCH, reserved);
        }
      }
    }
    <span class="keyword">return</span> <span class="transposed_variable">Resources.</span>none();
  }
</pre></td></tr></table></figure>

<p>在指定NM结点上分配container，此处理逻辑类似Capacity Scheduler。在创建完container后会将container入到newlyAllocatedContainers，liveContainers中供后续AM取资源时使用，并触发RMContainerEventType.START事件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="code"><pre>fair/<span class="transposed_variable">FSSchedulerApp.</span>java:
  synchronized public RMContainer allocate(NodeType type, FSSchedulerNode node,
      Priority priority, ResourceRequest request,
      Container container) {
    <span class="comment">// Update allowed locality level</span>
    NodeType allowed = <span class="transposed_variable">allowedLocalityLevel.</span>get(priority);
    <span class="keyword">if</span> (allowed != null) {
      <span class="keyword">if</span> (<span class="transposed_variable">allowed.</span>equals(<span class="transposed_variable">NodeType.</span>OFF_SWITCH) &&
          (<span class="transposed_variable">type.</span>equals(<span class="transposed_variable">NodeType.</span>NODE_LOCAL) ||
              <span class="transposed_variable">type.</span>equals(<span class="transposed_variable">NodeType.</span>RACK_LOCAL))) {
        <span class="transposed_variable">this.</span>resetAllowedLocalityLevel(priority, type);
      }
      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="transposed_variable">allowed.</span>equals(<span class="transposed_variable">NodeType.</span>RACK_LOCAL) &&
          <span class="transposed_variable">type.</span>equals(<span class="transposed_variable">NodeType.</span>NODE_LOCAL)) {
        <span class="transposed_variable">this.</span>resetAllowedLocalityLevel(priority, type);
      }
    }

    <span class="comment">// Required sanity check - AM can call 'allocate' to update resource </span>
    <span class="comment">// request without locking the scheduler, hence we need to check</span>
    <span class="keyword">if</span> (getTotalRequiredResources(priority) &lt;= <span class="number">0</span>) {
      <span class="keyword">return</span> null;
    }
    
    <span class="comment">// Create RMContainer</span>
    RMContainer rmContainer = new RMContainerImpl(container, 
        getApplicationAttemptId(), <span class="transposed_variable">node.</span>getNodeID(), rmContext
        .getDispatcher().getEventHandler(), rmContext
        .getContainerAllocationExpirer());

    <span class="comment">// Add it to allContainers list.</span>
    <span class="transposed_variable">newlyAllocatedContainers.</span>add(rmContainer);
    <span class="transposed_variable">liveContainers.</span>put(<span class="transposed_variable">container.</span>getId(), rmContainer);    

    <span class="comment">// Update consumption and track allocations</span>
    <span class="transposed_variable">appSchedulingInfo.</span>allocate(type, node, priority, request, container);
    <span class="transposed_variable">Resources.</span>addTo(currentConsumption, <span class="transposed_variable">container.</span>getResource());

    <span class="comment">// Inform the container</span>
    <span class="transposed_variable">rmContainer.</span>handle(
        new RMContainerEvent(<span class="transposed_variable">container.</span>getId(), <span class="transposed_variable">RMContainerEventType.</span>START));

    <span class="keyword">if</span> (<span class="transposed_variable">LOG.</span>isDebugEnabled()) {
      <span class="transposed_variable">LOG.</span>debug(<span class="string">"allocate: applicationAttemptId="</span> 
          + <span class="transposed_variable">container.</span>getId().getApplicationAttemptId() 
          + <span class="string">" container="</span> + <span class="transposed_variable">container.</span>getId() + <span class="string">" host="</span>
          + <span class="transposed_variable">container.</span>getNodeId().getHost() + <span class="string">" type="</span> + type);
    }
    <span class="transposed_variable">RMAuditLogger.</span>logSuccess(getUser(), 
        <span class="transposed_variable">AuditConstants.</span>ALLOC_CONTAINER, <span class="string">"SchedulerApp"</span>, 
        getApplicationId(), <span class="transposed_variable">container.</span>getId());
    
    <span class="keyword">return</span> rmContainer;
  }
</pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-01T02:33:27.000Z"><a href="/2014/06/01/yarn-资源管理与分配/">6月 1 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/01/yarn-资源管理与分配/">Yarn 资源管理与分配</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Scheduler_-521d-59cb-5316-">Scheduler 初始化</h2>
<p>在RM启动时将依据用户配置来初始化调度器，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>serviceInit()
    <span class="keyword">...</span>
    this.scheduler = createScheduler();
    <span class="keyword">...</span>
    //创建ApplicationMasterService，用以相应MRAppMaster的请求
    masterService = createApplicationMasterService();
    <span class="keyword">...</span>

createScheduler()
    String schedulerClassName = conf.get(YarnConfiguration.RM_SCHEDULER, YarnConfiguration.DEFAULT_RM_SCHEDULER);
</pre></td></tr></table></figure>

<h2 id="Job_-63d0-4ea4-81f3-8c03-5ea6-961f-5217-">Job 提交至调度队列</h2>
<p>RM中使用FiCaSchedulerNode类来描述一个NM slave结点上的资源使用情况， 用FiCaSchedulerApp 类来描述一个提交到RM的job，跟踪与维护job的运行时信息</p>
<p>CapacityScheduler.java:<br>handle()<br>    —&gt;addNode(nodeAddedEvent.getAddedRMNode()); handle NODE_ADDED 事件,创建NM对应的FiCaSchedulerNode对象用以管理NM中当前可用的资源,相关处理代码如下<br>    —&gt;addApplication() //handle APP_ADDED 事件<br>        LeafQueue.java:<br>        —&gt;submitApplication()//将job提交至叶子节点的队列，对其做相关的权限检查，确认后方将job提交至队列中</p>
<p>CapacityScheduler.java:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>  private synchronized void addNode(RMNode nodeManager) {
    //RM中全局的NM使用一个ConcurrentMap处理，存储NM ID及其对应的FiCaSchedulerNode
    //对象,创建FiCaSchedulerNode对象并添加至全局的nodes中
    this<span class="preprocessor">.nodes</span><span class="preprocessor">.put</span>(nodeManager<span class="preprocessor">.getNodeID</span>(), new FiCaSchedulerNode(nodeManager, usePortForNodeName))<span class="comment">; </span>
    Resources<span class="preprocessor">.addTo</span>(clusterResource, nodeManager<span class="preprocessor">.getTotalCapability</span>())<span class="comment">;</span>
    root<span class="preprocessor">.updateClusterResource</span>(clusterResource)<span class="comment">;</span>
    ++numNodeManagers<span class="comment">; //更新全局的NM个数</span>
    LOG<span class="preprocessor">.info</span>(<span class="string">"Added node "</span> + nodeManager<span class="preprocessor">.getNodeAddress</span>() + 
        <span class="string">" clusterResource: "</span> + clusterResource)<span class="comment">;</span>
  }
</pre></td></tr></table></figure>

<h2 id="-8d44-6e90-5206-914d-ff1a-">资源分配：</h2>
<p>RM中的资源分配过程时间上分为两大步骤：</p>
<ul>
<li>1）RM接收NM的心跳信息，处理各个结点上新启动的或已运行完成需要释放的Container，随后会对当前集群中的可用资源做一个分配，并将分配的结果存储在一个内存结构中</li>
<li>2）AM定期向RM发送心跳信息来获取新分配的Container，ApplicationMasterService将负责响应RPC请求，并从已分配的Container中将可用资源分发给AM</li>
</ul>
<h3 id="RM_-5206-914d-53ef-7528-8d44-6e90-">RM 分配可用资源</h3>
<p>nodeUpdate()<br>    —&gt;处理新启动的container列表,对每个可用的container发送LAUNCHED事件<br>    —&gt;处理已完成的释放的container列表<br>    —&gt;root.assignContainers(clusterResource, node); //从根队列开始遍历每个子队列分配资源<br>       —&gt;assignContainersToChildQueues()//遍历子队列列表,子队列列表本身使用TreeSet结构来管理与维护，多个队列间以队列可用容量来排序<br>        // Try to assign to most ‘under-served’ sub-queue<br>        for (Iterator<CSQueue> iter=childQueues.iterator(); iter.hasNext();) { }//由当前可用资源量最多的开始<br>            —&gt;assignment = childQueue.assignContainers(cluster, node);//在子队列上分配资源<br>            // Try to assign containers to applications in order<br>            for (FiCaSchedulerApp application : activeApplications) { //同一子队列上提交的早的先被调度<br>                // Schedule in priority order<br>                for (Priority priority : application.getPriorities()) { //同一个job发出的多个资源请求中，从优先级高的开始<br>                }<br>            }</p>
<p>队列间使用的比较器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>  this<span class="preprocessor">.queueComparator</span> = cs<span class="preprocessor">.getQueueComparator</span>()<span class="comment">;</span>
  this<span class="preprocessor">.childQueues</span> = new TreeSet&lt;CSQueue&gt;(queueComparator)<span class="comment">;</span>

子队列间插入TreeSet中时所使用的比较器，选择比较队列已经使用的容量大小，当大小一样时，将比较队列名称的名字长队  
  static final Comparator&lt;CSQueue&gt; queueComparator = new Comparator&lt;CSQueue&gt;() {
    @Override
    public int compare(CSQueue q1, CSQueue q2) {
      if (q1<span class="preprocessor">.getUsedCapacity</span>() &lt; q2<span class="preprocessor">.getUsedCapacity</span>()) {
        return -<span class="number">1</span><span class="comment">;</span>
      } else if (q1<span class="preprocessor">.getUsedCapacity</span>() &gt; q2<span class="preprocessor">.getUsedCapacity</span>()) {
        return <span class="number">1</span><span class="comment">;</span>
      }

      return q1<span class="preprocessor">.getQueuePath</span>()<span class="preprocessor">.compareTo</span>(q2<span class="preprocessor">.getQueuePath</span>())<span class="comment">;</span>
    }
  }<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>由根队列开始分配Container：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="code"><pre>  <span class="comment">//收到某个NM结点发来的心跳信息后，尝试在NM结点上分配container，</span>
  <span class="comment">//而实际的调度是发生在将可用的资源如何分配各不同的队列，同一队</span>
  <span class="comment">//列上的不同job，同一job中的不同task</span>
  public synchronized CSAssignment assignContainers(
      Resource clusterResource, FiCaSchedulerNode node) {
    CSAssignment assignment = 
        new CSAssignment(<span class="transposed_variable">Resources.</span>createResource(<span class="number">0</span>, <span class="number">0</span>), <span class="transposed_variable">NodeType.</span>NODE_LOCAL);
   
    <span class="comment">//检查当前NM上的可用资源是否能够满足最低分配额，</span>
    <span class="comment">//若不能，则放弃在当前NM上分配资源</span>
    while (canAssign(clusterResource, node)) {
      ...

      <span class="comment">// Are we over maximum-capacity for this queue?</span>
      <span class="comment">//检查当前已使用的资源占总资源的占比是否超过所</span>
      <span class="comment">//允许的最大值</span>
      <span class="keyword">if</span> (!assignToQueue(clusterResource)) {
        <span class="keyword">break</span>;
      }
      
      <span class="comment">// Schedule</span>
      <span class="comment">//在当前队列的各个子队列上分配资源</span>
      CSAssignment assignedToChild = 
          assignContainersToChildQueues(clusterResource, node);
      <span class="transposed_variable">assignment.</span>setType(<span class="transposed_variable">assignedToChild.</span>getType());
      
      <span class="comment">// Done if no child-queue assigned anything</span>
      <span class="comment">//检查在子队列上是否分配成功，若失败则直接跳出，</span>
      <span class="comment">//因分配过程是依据资源的使用量来调度的，当前的失败</span>
      <span class="comment">//后后续的亦不会成功</span>
      <span class="keyword">if</span> (<span class="transposed_variable">Resources.</span>greaterThan(
              resourceCalculator, clusterResource, 
              <span class="transposed_variable">assignedToChild.</span>getResource(), <span class="transposed_variable">Resources.</span>none())) {
        <span class="comment">// Track resource utilization for the parent-queue</span>
        <span class="comment">//更新集群资源统计</span>
        allocateResource(clusterResource, <span class="transposed_variable">assignedToChild.</span>getResource());
        
        <span class="comment">// Track resource utilization in this pass of the scheduler</span>
        <span class="transposed_variable">Resources.</span>addTo(<span class="transposed_variable">assignment.</span>getResource(), <span class="transposed_variable">assignedToChild.</span>getResource());

      } <span class="keyword">else</span> {
        <span class="keyword">break</span>;
      }

      <span class="comment">// Do not assign more than one container if this isn't the root queue</span>
      <span class="comment">// or if we've already assigned an off-switch container</span>
      <span class="keyword">if</span> (!rootQueue || <span class="transposed_variable">assignment.</span>getType() == <span class="transposed_variable">NodeType.</span>OFF_SWITCH) {
        <span class="keyword">if</span> (<span class="transposed_variable">LOG.</span>isDebugEnabled()) {
          <span class="keyword">if</span> (rootQueue && <span class="transposed_variable">assignment.</span>getType() == <span class="transposed_variable">NodeType.</span>OFF_SWITCH) {
            <span class="transposed_variable">LOG.</span>debug(<span class="string">"Not assigning more than one off-switch container,"</span> +
                <span class="string">" assignments so far: "</span> + assignment);
          }
        }
        <span class="keyword">break</span>;
      }
    }
    
    <span class="keyword">return</span> assignment;
  }
</pre></td></tr></table></figure>

<p>在多个叶子队列上分配资源：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>  synchronized CSAssignment assignContainersToChildQueues(Resource cluster, 
      FiCaSchedulerNode node) {
    CSAssignment assignment = 
        new CSAssignment(Resources.createResource(<span class="number">0</span>, <span class="number">0</span>), NodeType.NODE_LOCAL);
    
    // Try to assign to most <span class="string">'under-served'</span> sub-queue
    <span class="keyword">for</span> (Iterator&lt;CSQueue&gt; iter=childQueues.iterator(); iter.hasNext();) {
      CSQueue childQueue = iter.next();
      <span class="keyword">...</span> 
      assignment = childQueue.assignContainers(cluster, node);
      <span class="keyword">...</span>

      // If we do assign, remove the queue and re-insert <span class="keyword">in</span>-order to re-sort
      //检查是否在子队列上分配container成功
      <span class="keyword">if</span> (Resources.greaterThan(
              resourceCalculator, cluster, 
              assignment.getResource(), Resources.none())) { 
        // Remove and re-insert to sort
        //若成功，则意味着当前子队列的资源使用量有改动，将其从
        //TreeSet中移除，再从新插入，以此来实现更新多个子队列的
        //资源使用量的排序
        iter.remove();
        childQueues.add(childQueue);
        <span class="keyword">break</span>;
      }
    }
    
    <span class="keyword">return</span> assignment;
  }
</pre></td></tr></table></figure>

<p>同一队列上的多个job间使用的排序比较器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>Comparator&lt;FiCaSchedulerApp&gt; applicationComparator = cs.getApplicationComparator();
<span class="keyword">this</span>.pendingApplications = <span class="keyword">new</span> TreeSet&lt;FiCaSchedulerApp&gt;(applicationComparator);
<span class="keyword">this</span>.activeApplications = <span class="keyword">new</span> TreeSet&lt;FiCaSchedulerApp&gt;(applicationComparator);

同一子队列上，多个job插入队列时所使用的比较器，选择比较job的 ApplicationId 大小,
ApplicationId大小对应着job的提交时间，提交的时间越晚则ID值越大

<span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;FiCaSchedulerApp&gt; applicationComparator = 
    <span class="keyword">new</span> Comparator&lt;FiCaSchedulerApp&gt;() {
    <span class="keyword">@Override</span>
    <span class="keyword">public</span> <span class="keyword">int</span> compare(FiCaSchedulerApp a1, FiCaSchedulerApp a2) {
      <span class="keyword">return</span> a1.getApplicationId().compareTo(a2.getApplicationId());
    }
  };
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
</pre></td><td class="code"><pre>  public synchronized CSAssignment 
  assignContainers(Resource clusterResource, FiCaSchedulerNode node) {

    <span class="comment">// Check for reserved resources</span>
    RMContainer reservedContainer = <span class="transposed_variable">node.</span>getReservedContainer();
    <span class="keyword">if</span> (reservedContainer != null) {
      FiCaSchedulerApp application = 
          getApplication(<span class="transposed_variable">reservedContainer.</span>getApplicationAttemptId());
      synchronized (application) {
        <span class="keyword">return</span> assignReservedContainer(application, node, reservedContainer,
          clusterResource);
      }
    }
    
    <span class="comment">// Try to assign containers to applications in order</span>
    <span class="comment">//依据插入队列的时间先后顺序处理同一队列上的多个job</span>
    <span class="keyword">for</span> (FiCaSchedulerApp application : activeApplications) {

      synchronized (application) {
        <span class="comment">// Check if this resource is on the blacklist</span>
        <span class="comment">//检查当前NM 结点是否上了当前job的黑名单，若是则跳过当前job</span>
        <span class="comment">//不为当前job分配资源</span>
        <span class="keyword">if</span> (<span class="transposed_variable">FiCaSchedulerUtils.</span>isBlacklisted(application, node, LOG)) {
          <span class="keyword">continue</span>;
        }
        
        <span class="comment">// Schedule in priority order</span>
        <span class="keyword">for</span> (Priority priority : <span class="transposed_variable">application.</span>getPriorities()) {
          <span class="comment">// Required resource</span>
          Resource required = 
              <span class="transposed_variable">application.</span>getResourceRequest(
                  priority, <span class="transposed_variable">ResourceRequest.</span>ANY).getCapability();

          <span class="comment">// Do we need containers at this 'priority'?</span>
          <span class="keyword">if</span> (!needContainers(application, priority, required)) {
            <span class="keyword">continue</span>;
          }

          Resource userLimit = 
              computeUserLimitAndSetHeadroom(application, clusterResource, 
                  required);          
          
          <span class="comment">// Check queue max-capacity limit</span>
          <span class="comment">//检查即将分配的资源是否会超过是否超过上限值（由maximun-capacity指定）</span>
          <span class="keyword">if</span> (!assignToQueue(clusterResource, required)) {
            <span class="keyword">return</span> NULL_ASSIGNMENT;
          }

          <span class="comment">// Check user limit</span>
          <span class="comment">//检查是否超过用户的使用上限</span>
          <span class="keyword">if</span> (!assignToUser(
              clusterResource, <span class="transposed_variable">application.</span>getUser(), userLimit)) {
              <span class="keyword">break</span>; 
          }

          <span class="comment">// Inform the application it is about to get a scheduling opportunity</span>
          <span class="transposed_variable">application.</span>addSchedulingOpportunity(priority);
          
          <span class="comment">// Try to schedule</span>
          <span class="comment">//尝试对选定的job的指定优先级进行分配container</span>
          CSAssignment assignment =  
            assignContainersOnNode(clusterResource, node, application, priority, 
                null);

          <span class="comment">// Did the application skip this node?</span>
          <span class="keyword">if</span> (<span class="transposed_variable">assignment.</span>getSkipped()) {
            <span class="comment">// Don't count 'skipped nodes' as a scheduling opportunity!</span>
            <span class="transposed_variable">application.</span>subtractSchedulingOpportunity(priority);
            <span class="keyword">continue</span>;
          }
          
          <span class="comment">// Did we schedule or reserve a container?</span>
          Resource assigned = <span class="transposed_variable">assignment.</span>getResource();
          <span class="comment">//检查是否成功分配资源</span>
          <span class="keyword">if</span> (<span class="transposed_variable">Resources.</span>greaterThan(
              resourceCalculator, clusterResource, assigned, <span class="transposed_variable">Resources.</span>none())) {

            <span class="comment">// Book-keeping </span>
            <span class="comment">// Note: Update headroom to account for current allocation too...</span>
            allocateResource(clusterResource, application, assigned);
            
            <span class="comment">// Don't reset scheduling opportunities for non-local assignments</span>
            <span class="comment">// otherwise the app will be delayed for each non-local assignment.</span>
            <span class="comment">// This helps apps with many off-cluster requests schedule faster.</span>
            <span class="keyword">if</span> (<span class="transposed_variable">assignment.</span>getType() != <span class="transposed_variable">NodeType.</span>OFF_SWITCH) {
              <span class="transposed_variable">application.</span>resetSchedulingOpportunities(priority);
            }
            
            <span class="comment">// Done</span>
            <span class="keyword">return</span> assignment;
          } <span class="keyword">else</span> {
            <span class="comment">// Do not assign out of order w.r.t priorities</span>
            <span class="keyword">break</span>;
          }
        }
      }

      <span class="keyword">if</span>(<span class="transposed_variable">LOG.</span>isDebugEnabled()) {
        <span class="transposed_variable">LOG.</span>debug(<span class="string">"post-assignContainers for application "</span>
          + <span class="transposed_variable">application.</span>getApplicationId());
      }
      <span class="transposed_variable">application.</span>showRequests();
    }
  
    <span class="keyword">return</span> NULL_ASSIGNMENT;

  }
</pre></td></tr></table></figure>

<p>同一个job的多个container请求间使用的比较器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="label">AppSchedulingInfo.java:</span>
  final <span class="keyword">Set</span>&lt;Priority&gt; priorities = new TreeSet&lt;Priority&gt;(
      new org<span class="preprocessor">.apache</span><span class="preprocessor">.hadoop</span><span class="preprocessor">.yarn</span><span class="preprocessor">.server</span><span class="preprocessor">.resourcemanager</span><span class="preprocessor">.resource</span><span class="preprocessor">.Priority</span><span class="preprocessor">.Comparator</span>())<span class="comment">;</span>

每个job中提交的资源请求在入到TreeSet结构中时所使用的比较器：
  public static class Comparator 
  implements java<span class="preprocessor">.util</span><span class="preprocessor">.Comparator</span>&lt;org<span class="preprocessor">.apache</span><span class="preprocessor">.hadoop</span><span class="preprocessor">.yarn</span><span class="preprocessor">.api</span><span class="preprocessor">.records</span><span class="preprocessor">.Priority</span>&gt; {
    @Override
    public int compare(org<span class="preprocessor">.apache</span><span class="preprocessor">.hadoop</span><span class="preprocessor">.yarn</span><span class="preprocessor">.api</span><span class="preprocessor">.records</span><span class="preprocessor">.Priority</span> o1, org<span class="preprocessor">.apache</span><span class="preprocessor">.hadoop</span><span class="preprocessor">.yarn</span><span class="preprocessor">.api</span><span class="preprocessor">.records</span><span class="preprocessor">.Priority</span> o2) {
      return o1<span class="preprocessor">.getPriority</span>() - o2<span class="preprocessor">.getPriority</span>()<span class="comment">;</span>
    }
  }
</pre></td></tr></table></figure>

<p>在确定了job及优先级后，尝试在结点上分配资源：<br>assignContainers()<br>    —&gt;assignContainersOnNode() //按照 Data-local ,Rack-local , Off-switch顺序分配job<br>        —&gt;assignNodeLocalContainers()<br>            —&gt;assignContainer() //在结点上完成job的分配</p>
<p>LeafQueue.java:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre>  private CSAssignment assignContainersOnNode(Resource clusterResource, 
      FiCaSchedulerNode node, FiCaSchedulerApp application, 
      Priority priority, RMContainer reservedContainer) {

    Resource assigned = Resources.none();

    // Data-local
    //AppSchedulingInfo类中requests成员记录每个job中所请求的资源类型
    //通过资源的优先级与资源的location信息(Data-local,Rack-local,Off-<span class="keyword">switch</span>
    //来索引资源的请求
    //Map&lt;Priority, Map&lt;String, ResourceRequest&gt;&gt; requests
    
    //依次获取选定的job中在当前优先级下请求的Data-local，
    //Rack-local，Off-<span class="keyword">switch</span>的资源,有限本地分配
    ResourceRequest nodeLocalResourceRequest =
        application.getResourceRequest(priority, node.getNodeName());
    <span class="keyword">if</span> (nodeLocalResourceRequest != null) {
      assigned = 
          assignNodeLocalContainers(clusterResource, nodeLocalResourceRequest, 
              node, application, priority, reservedContainer); 
      <span class="keyword">if</span> (Resources.greaterThan(resourceCalculator, clusterResource, 
          assigned, Resources.none())) {
        <span class="keyword">return</span> new CSAssignment(assigned, NodeType.NODE_LOCAL);
      }
    }

    // Rack-local
    ResourceRequest rackLocalResourceRequest =
        application.getResourceRequest(priority, node.getRackName());
    <span class="keyword">if</span> (rackLocalResourceRequest != null) {
        <span class="keyword">...</span>
    }
    
    // Off-<span class="keyword">switch</span>
    ResourceRequest offSwitchResourceRequest =
        application.getResourceRequest(priority, ResourceRequest.ANY);
    <span class="keyword">if</span> (offSwitchResourceRequest != null) {
        <span class="keyword">...</span> 
    }
    
    <span class="keyword">return</span> SKIP_ASSIGNMENT;
  }
</pre></td></tr></table></figure>

<p>对选定的job在指定location上分配container</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre></td><td class="code"><pre>  <span class="keyword">private</span> Resource assignContainer(Resource clusterResource, FiCaSchedulerNode node, 
      FiCaSchedulerApp application, Priority priority, 
      ResourceRequest request, NodeType <span class="class"><span class="keyword">type</span>, <span class="title">RMContainer</span> <span class="title">rmContainer</span>) {</span>

    <span class="comment">//获取当前的请求，结点上的可用资源，结点的总资源</span>
    Resource capability = request.getCapability();
    Resource available = node.getAvailableResource();
    Resource totalResource = node.getTotalResource();

    <span class="comment">//如果请求资源量超过了结点的总资源量，则直接放弃</span>
    <span class="keyword">if</span> (!Resources.fitsIn(capability, totalResource)) {
      LOG.warn(<span class="string">"Node : "</span> + node.getNodeID()
          + <span class="string">" does not have sufficient resource for request : "</span> + request
          + <span class="string">" node total capability : "</span> + node.getTotalResource());
      <span class="keyword">return</span> Resources.none();
    }
    <span class="comment">//确认当前结点上有可用的资源</span>
    <span class="keyword">assert</span> Resources.greaterThan(
        resourceCalculator, clusterResource, available, Resources.none());

    <span class="comment">//使用Container对象来描述资源分配，</span>
    <span class="comment">//其中包含资源大小，优先级及资源所在的NM结点</span>
    /* 
        Container container = recordFactory.newRecordInstance(Container.<span class="keyword">class</span>);
        container.setId(containerId);
        container.setNodeId(nodeId);
        container.setNodeHttpAddress(nodeHttpAddress);
        container.setResource(resource);
        container.setPriority(priority);
        container.setContainerToken(containerToken);
    */
    Container container = 
        getContainer(rmContainer, application, node, capability, priority);
  
    <span class="comment">// Can we allocate a container on this node?</span>
    <span class="comment">// 确认当前的可用资源是否可以满足需求</span>
    int availableContainers = 
        resourceCalculator.computeAvailableContainers(available, capability);
    <span class="keyword">if</span> (availableContainers &gt; <span class="number">0</span>) {
      <span class="comment">// Allocate...</span>

      <span class="comment">// Did we previously reserve containers at this 'priority'?</span>
      <span class="keyword">if</span> (rmContainer != <span class="keyword">null</span>){
        unreserve(application, priority, node, rmContainer);
      }

      Token containerToken =
          createContainerToken(application, container);
      <span class="keyword">if</span> (containerToken == <span class="keyword">null</span>) {
        <span class="comment">// Something went wrong...</span>
        <span class="keyword">return</span> Resources.none();
      }
      container.setContainerToken(containerToken);
      
      <span class="comment">// Inform the application</span>
      RMContainer allocatedContainer = 
          application.allocate(<span class="class"><span class="keyword">type</span>, <span class="title">node</span>, <span class="title">priority</span>, <span class="title">request</span>, <span class="title">container</span>);</span>

      <span class="comment">// Does the application need this resource?</span>
      <span class="keyword">if</span> (allocatedContainer == <span class="keyword">null</span>) {
        <span class="keyword">return</span> Resources.none();
      }

      <span class="comment">// Inform the node</span>
      node.allocateContainer(application.getApplicationId(), 
          allocatedContainer);

      <span class="keyword">return</span> container.getResource();
    } <span class="keyword">else</span> {
      <span class="comment">// Reserve by 'charging' in advance...</span>
      <span class="comment">// 当前结点上的可用资源无法一次性满足需求时，将为job预留资源</span>
      <span class="comment">// 直至有足够的资源</span>
      reserve(application, priority, node, rmContainer, container);

      <span class="keyword">return</span> request.getCapability();
    }
  }
</pre></td></tr></table></figure>

<p>分配container：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre>  synchronized <span class="keyword">public</span> RMContainer allocate(NodeType <span class="class"><span class="keyword">type</span>, <span class="title">FiCaSchedulerNode</span> <span class="title">node</span>,</span>
      Priority priority, ResourceRequest request, 
      Container container) {
    ... 

    <span class="comment">// Create RMContainer</span>
    RMContainer rmContainer = <span class="keyword">new</span> RMContainerImpl(container, this
        .getApplicationAttemptId(), node.getNodeID(), this.rmContext
        .getDispatcher().getEventHandler(), this.rmContext
        .getContainerAllocationExpirer());

    <span class="comment">// Add it to allContainers list.</span>
    <span class="comment">// KEY:</span>
    <span class="comment">//将分配出的Container添加至新分配的container链表</span>
    <span class="comment">//newlyAllocatedContainers中，后续AM获取container</span>
    <span class="comment">//时将从其中获取已分配的container</span>
    newlyAllocatedContainers.add(rmContainer);
    <span class="comment">//将新分配的container添加至liveContainers集合中，其中</span>
    <span class="comment">//包含的是当前所有活动的container</span>
    liveContainers.put(container.getId(), rmContainer);    

    <span class="comment">// Update consumption and track allocations</span>
    <span class="comment">// 更新资源使用统计</span>
    appSchedulingInfo.allocate(<span class="class"><span class="keyword">type</span>, <span class="title">node</span>, <span class="title">priority</span>, <span class="title">request</span>, <span class="title">container</span>);</span>
    Resources.addTo(currentConsumption, container.getResource());

    <span class="comment">// Inform the container</span>
    <span class="comment">// 完成创建后触发RMContainerEventType.START事件</span>
    rmContainer.handle(
        <span class="keyword">new</span> RMContainerEvent(container.getId(), RMContainerEventType.START));

    ...
    <span class="keyword">return</span> rmContainer;
  }
</pre></td></tr></table></figure>

<p>在RM完成container的分配后，更新NM结点上的资源使用统计信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>  <span class="javadoc">/**
   * The Scheduler has allocated containers on this node to the 
   * given application.
   * 
   *<span class="javadoctag"> @param</span> applicationId application
   *<span class="javadoctag"> @param</span> rmContainer allocated container
   */</span>
  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> allocateContainer(ApplicationId applicationId, 
      RMContainer rmContainer) {
    Container container = rmContainer.getContainer();
    <span class="comment">//更新当前NM结点上的资源量</span>
    deductAvailableResource(container.getResource());
    <span class="comment">//更新NM上已分配的container个数统计</span>
    ++numContainers;
    
    <span class="comment">//将新分配的container添加至全局map中，以container的ID</span>
    <span class="comment">//为key值，供后续AM申请资源时使用</span>
    launchedContainers.put(container.getId(), rmContainer);
    ...
  }
</pre></td></tr></table></figure>

<h4 id="AM_-83b7-53d6-5df2-5206-914d-Container-5217-8868-">AM 获取已分配Container列表</h4>
<p>ApplicationMasterService用于响应来自AMs的RPC请求。主要负责新AM的注册，AM运行结束后终止运行等请求，接收来自AMs的容器分配与释放请求并将这些请求转发至调度器YarnScheduler。</p>
<p>ApplicationMasterService在收到AM的心跳信息后将从RM的已经分配的container链表中依据AM请求的资源来返回container</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
</pre></td><td class="code"><pre>ApplicationMasterService.java:
  <span class="keyword">public</span> AllocateResponse allocate(AllocateRequest request)
      <span class="keyword">throws</span> YarnException, IOException {
      ...
      <span class="comment">//使用指定的调度器分配资源</span>
      <span class="comment">//Send new requests to appAttempt.</span>
      Allocation allocation =
          this.rScheduler.allocate(appAttemptId, ask, release, 
              blacklistAdditions, blacklistRemovals);
      ...
 }

  <span class="keyword">public</span> AllocateResponse allocate(AllocateRequest request)
      <span class="keyword">throws</span> YarnException, IOException {

    <span class="comment">//由请求中获取当前需要分配资源的appAttemptId</span>
    ApplicationAttemptId appAttemptId = authorizeRequest();

    this.amLivelinessMonitor.receivedPing(appAttemptId);

    <span class="comment">/* check if its in cache */</span>
    AllocateResponse lastResponse = responseMap.get(appAttemptId);
    <span class="keyword">if</span> (lastResponse == <span class="keyword">null</span>) {
      LOG.error(<span class="string">"AppAttemptId doesnt exist in cache "</span> + appAttemptId);
      <span class="keyword">return</span> resync;
    }
    <span class="comment">//AM 请求资源分为两步：首先提交job至用户指定的队列，完成job在RM上的注册</span>
    <span class="comment">//随后在RM收到NM的心跳后会将NM上的空闲资源依据已经提交至队列上的job所请求</span>
    <span class="comment">//的资源数来划分container，并将其缓存至链表中，最后AM通过心跳信息来与RM</span>
    <span class="comment">//请求资源时，将从RM已经分配的container列表返回job所请求的对应的container</span>

    <span class="comment">//在此需检查当前所请求资源appAttemptId是否已经被注册过,若没有则异常返回</span>
    <span class="keyword">if</span> (!hasApplicationMasterRegistered(appAttemptId)) {
        ...
    }

    <span class="keyword">if</span> ((request.getResponseId() + <span class="number">1</span>) == lastResponse.getResponseId()) {
      <span class="comment">/* old heartbeat */</span>
      <span class="keyword">return</span> lastResponse;
    } <span class="keyword">else</span> <span class="keyword">if</span> (request.getResponseId() + <span class="number">1</span> &lt; lastResponse.getResponseId()) {
      LOG.error(<span class="string">"Invalid responseid from appAttemptId "</span> + appAttemptId);
      <span class="comment">// Oh damn! Sending reboot isn't enough. RM state is corrupted. TODO:</span>
      <span class="comment">// Reboot is not useful since after AM reboots, it will send register and </span>
      <span class="comment">// get an exception. Might as well throw an exception here.</span>
      <span class="keyword">return</span> resync;
    } 
    
    <span class="comment">// Allow only one thread in AM to do heartbeat at a time.</span>
    <span class="keyword">synchronized</span> (lastResponse) {

      <span class="comment">// Send the status update to the appAttempt.</span>
      this.rmContext.getDispatcher().getEventHandler().handle(
          <span class="keyword">new</span> RMAppAttemptStatusupdateEvent(appAttemptId, request
              .getProgress()));

      <span class="comment">//获取AM提交的job资源请求列表及资源释放列表</span>
      List&lt;ResourceRequest&gt; ask = request.getAskList();
      List&lt;ContainerId&gt; release = request.getReleaseList();
 
      <span class="comment">//黑名单增删</span>
      ResourceBlacklistRequest blacklistRequest = request.getResourceBlacklistRequest();
      List&lt;String&gt; blacklistAdditions = 
          (blacklistRequest != <span class="keyword">null</span>) ? 
              blacklistRequest.getBlacklistAdditions() : <span class="keyword">null</span>;
      List&lt;String&gt; blacklistRemovals = 
          (blacklistRequest != <span class="keyword">null</span>) ? 
              blacklistRequest.getBlacklistRemovals() : <span class="keyword">null</span>;
      
      
      <span class="comment">//使用指定的调度器来获取资源</span>
      Allocation allocation =
          this.rScheduler.allocate(appAttemptId, ask, release, 
              blacklistAdditions, blacklistRemovals);

      RMApp app = this.rmContext.getRMApps().get(
          appAttemptId.getApplicationId());
      RMAppAttempt appAttempt = app.getRMAppAttempt(appAttemptId);
      
      AllocateResponse allocateResponse =
          recordFactory.newRecordInstance(AllocateResponse.<span class="class"><span class="keyword">class</span>);

      ...

      <span class="title">allocateResponse</span>.<span class="title">setAllocatedContainers</span>(<span class="title">allocation</span>.<span class="title">getContainers</span>());
      <span class="title">allocateResponse</span>.<span class="title">setCompletedContainersStatuses</span>(<span class="title">appAttempt</span>
          .<span class="title">pullJustFinishedContainers</span>());
      <span class="title">allocateResponse</span>.<span class="title">setResponseId</span>(<span class="title">lastResponse</span>.<span class="title">getResponseId</span>() + 1);
      <span class="title">allocateResponse</span>.<span class="title">setAvailableResources</span>(<span class="title">allocation</span>.<span class="title">getResourceLimit</span>());
      
      <span class="title">allocateResponse</span>.<span class="title">setNumClusterNodes</span>(<span class="title">this</span>.<span class="title">rScheduler</span>.<span class="title">getNumClusterNodes</span>());
   
      // <span class="title">add</span> <span class="title">preemption</span> <span class="title">to</span> <span class="title">the</span> <span class="title">allocateResponse</span> <span class="title">message</span> (<span class="title">if</span> <span class="title">any</span>)
      <span class="title">allocateResponse</span>.<span class="title">setPreemptionMessage</span>(<span class="title">generatePreemptionMessage</span>(<span class="title">allocation</span>));

      // <span class="title">Adding</span> <span class="title">NMTokens</span> <span class="title">for</span> <span class="title">allocated</span> <span class="title">containers</span>.
      <span class="title">if</span> (!<span class="title">allocation</span>.<span class="title">getContainers</span>().<span class="title">isEmpty</span>()) </span>{
        allocateResponse.setNMTokens(rmContext.getNMTokenSecretManager()
            .createAndGetNMTokens(app.getUser(), appAttemptId,
                allocation.getContainers()));
      }

      <span class="comment">// before returning response, verify in sync</span>
      AllocateResponse oldResponse =
          responseMap.put(appAttemptId, allocateResponse);
      <span class="keyword">if</span> (oldResponse == <span class="keyword">null</span>) {
        <span class="comment">// appAttempt got unregistered, remove it back out</span>
        responseMap.remove(appAttemptId);
        String message = <span class="string">"App Attempt removed from the cache during allocate"</span>
            + appAttemptId;
        LOG.error(message);
        <span class="keyword">return</span> resync;
      }

      <span class="keyword">return</span> allocateResponse;
    }
  }
</pre></td></tr></table></figure>

<p>CapacityScheduler.java:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre></td><td class="code"><pre>  public Allocation allocate(ApplicationAttemptId applicationAttemptId,
      List&lt;ResourceRequest&gt; ask, List&lt;ContainerId&gt; release, 
      List&lt;String&gt; blacklistAdditions, List&lt;String&gt; blacklistRemovals) {

    FiCaSchedulerApp application = getApplication(applicationAttemptId)<span class="comment">;</span>
    
    // Sanity check
    //将job请求的资源归一化，以最小分配资源量为步长
    SchedulerUtils<span class="preprocessor">.normalizeRequests</span>(
        ask, getResourceCalculator(), getClusterResources(),
        getMinimumResourceCapability(), maximumAllocation)<span class="comment">;</span>

    // Release containers
    for (ContainerId releasedContainerId : release) {
      RMContainer rmContainer = getRMContainer(releasedContainerId)<span class="comment">;</span>
      if (rmContainer == null) {
         RMAuditLogger<span class="preprocessor">.logFailure</span>(application<span class="preprocessor">.getUser</span>(),
             AuditConstants<span class="preprocessor">.RELEASE</span>_CONTAINER, 
             <span class="string">"Unauthorized access or invalid container"</span>, <span class="string">"CapacityScheduler"</span>,
             <span class="string">"Trying to release container not owned by app or with invalid id"</span>,
             application<span class="preprocessor">.getApplicationId</span>(), releasedContainerId)<span class="comment">;</span>
      }
      completedContainer(rmContainer,
          SchedulerUtils<span class="preprocessor">.createAbnormalContainerStatus</span>(
              releasedContainerId, 
              SchedulerUtils<span class="preprocessor">.RELEASED</span>_CONTAINER),
          RMContainerEventType<span class="preprocessor">.RELEASED</span>)<span class="comment">;</span>
    }

    synchronized (application) {

      // 确保在为job申请资源时，job本身没有被停止或删除
      if (application<span class="preprocessor">.isStopped</span>()) {
        LOG<span class="preprocessor">.info</span>(<span class="string">"Calling allocate on a stopped "</span> +
            <span class="string">"application "</span> + applicationAttemptId)<span class="comment">;</span>
        return EMPTY_ALLOCATION<span class="comment">;</span>
      }

      if (!ask<span class="preprocessor">.isEmpty</span>()) {

        if(LOG<span class="preprocessor">.isDebugEnabled</span>()) {
          LOG<span class="preprocessor">.debug</span>(<span class="string">"allocate: pre-update"</span> +
            <span class="string">" applicationAttemptId="</span> + applicationAttemptId + 
            <span class="string">" application="</span> + application)<span class="comment">;</span>
        }
        application<span class="preprocessor">.showRequests</span>()<span class="comment">;</span>
  
        // Update application requests
        application<span class="preprocessor">.updateResourceRequests</span>(ask)<span class="comment">;</span>
  
        LOG<span class="preprocessor">.debug</span>(<span class="string">"allocate: post-update"</span>)<span class="comment">;</span>
        application<span class="preprocessor">.showRequests</span>()<span class="comment">;</span>
      }

      if(LOG<span class="preprocessor">.isDebugEnabled</span>()) {
        LOG<span class="preprocessor">.debug</span>(<span class="string">"allocate:"</span> +
          <span class="string">" applicationAttemptId="</span> + applicationAttemptId + 
          <span class="string">" #ask="</span> + ask<span class="preprocessor">.size</span>())<span class="comment">;</span>
      }

      application<span class="preprocessor">.updateBlacklist</span>(blacklistAdditions, blacklistRemovals)<span class="comment">;</span>

      return application<span class="preprocessor">.getAllocation</span>(getResourceCalculator(),
                   clusterResource, getMinimumResourceCapability())<span class="comment">;</span>
    }
  }
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre>  <span class="keyword">public</span> <span class="keyword">synchronized</span> Allocation getAllocation(ResourceCalculator rc,
      Resource clusterResource, Resource minimumAllocation) {

    Set&lt;ContainerId&gt; currentContPreemption = Collections.unmodifiableSet(
        <span class="keyword">new</span> HashSet&lt;ContainerId&gt;(containersToPreempt));
    containersToPreempt.clear();
    Resource tot = Resource.newInstance(<span class="number">0</span>, <span class="number">0</span>);

    <span class="comment">//currentContPreemption集合中的container为可被抢占的</span>
    <span class="comment">//遍历获取其ContainerId 并从liveContainers中获得其对应</span>
    <span class="comment">//的资源，将其添加至</span>
    <span class="keyword">for</span>(ContainerId c : currentContPreemption){
      Resources.addTo(tot,
          liveContainers.get(c).getContainer().getResource());
    }
    <span class="comment">//以最小分配额为步长，计算当前总的可用的资源中可分配多少个container</span>
    <span class="comment">//对多个维度的资源来说，将选取mem与cpu中占总资源量较大者为主资源，</span>
    <span class="keyword">int</span> numCont = (<span class="keyword">int</span>) Math.ceil(
        Resources.divide(rc, clusterResource, tot, minimumAllocation));
    ResourceRequest rr = ResourceRequest.newInstance(
        Priority.UNDEFINED, ResourceRequest.ANY,
        minimumAllocation, numCont);
    <span class="keyword">return</span> <span class="keyword">new</span> Allocation(pullNewlyAllocatedContainers(), getHeadroom(),
                          <span class="keyword">null</span>, currentContPreemption,
                          Collections.singletonList(rr));
  }

ResourceRequest.java:
  <span class="keyword">public</span> <span class="keyword">static</span> ResourceRequest newInstance(Priority priority, String hostName,
      Resource capability, <span class="keyword">int</span> numContainers, <span class="keyword">boolean</span> relaxLocality) {
    ResourceRequest request = Records.newRecord(ResourceRequest.<span class="class"><span class="keyword">class</span>);
    <span class="title">request</span>.<span class="title">setPriority</span>(<span class="title">priority</span>);
    <span class="title">request</span>.<span class="title">setResourceName</span>(<span class="title">hostName</span>);
    <span class="title">request</span>.<span class="title">setCapability</span>(<span class="title">capability</span>);
    <span class="title">request</span>.<span class="title">setNumContainers</span>(<span class="title">numContainers</span>);
    <span class="title">request</span>.<span class="title">setRelaxLocality</span>(<span class="title">relaxLocality</span>);
    <span class="title">return</span> <span class="title">request</span>;
  }</span>
</pre></td></tr></table></figure>

<p>allocate()<br>    —&gt;SchedulerUtils.normalizeRequests()<br>        —&gt;SchedulerUtils.normalizeRequest()<br>            —&gt;normalize()</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre>  <span class="comment">//对每个用户的资源请求归一化</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> normalizeRequests(
    List&lt;ResourceRequest&gt; asks,
    ResourceCalculator resourceCalculator,
    Resource clusterResource,
    Resource minimumResource,
    Resource maximumResource) {
    <span class="keyword">for</span> (ResourceRequest ask : asks) {
      normalizeRequest(
        ask, resourceCalculator, clusterResource, minimumResource,
        maximumResource, minimumResource);
    }
  }

  <span class="javadoc">/**
   * Utility method to normalize a resource request, by insuring that the
   * requested memory is a multiple of minMemory and is not zero.
   */</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> normalizeRequest(
    ResourceRequest ask,
    ResourceCalculator resourceCalculator,
    Resource clusterResource,
    Resource minimumResource,
    Resource maximumResource) {
    Resource normalized =
      Resources.normalize(
        resourceCalculator, ask.getCapability(), minimumResource,
        maximumResource, minimumResource);
    ask.setCapability(normalized);
  }

DominantResourceCalculator.java:
  <span class="keyword">public</span> Resource normalize(Resource r, Resource minimumResource,
                            Resource maximumResource, Resource stepFactor) {

    <span class="comment">//首先以一定的步长将请求资源量取整，然后取用户请求</span>
    <span class="comment">//量与允许的最大资源量中较小的</span>
    <span class="comment">//步长为最小分配资源量</span>
    <span class="keyword">int</span> normalizedMemory = Math.min(
      roundUp(
        Math.max(r.getMemory(), minimumResource.getMemory()),
        stepFactor.getMemory()),
      maximumResource.getMemory());
    <span class="keyword">int</span> normalizedCores = Math.min(
      roundUp(
        Math.max(r.getVirtualCores(), minimumResource.getVirtualCores()),
        stepFactor.getVirtualCores()),
      maximumResource.getVirtualCores());
    <span class="keyword">return</span> Resources.createResource(normalizedMemory,
      normalizedCores);
  }
</pre></td></tr></table></figure>

<h4 id="AM_-7aef-7684-7533-8bf7-">AM 端的申请</h4>
<p>RMContainerAllocator是MRAppMaster中负责资源申请与分配的模块，其通过周期性心跳信息获取RM中当前已分配的Container，并对获得的资源看其是否可以满足当前的任务需求，若满足则将对资源做进一步的分配，分配给具体的task，并启动相应的container。</p>
<p>其本身将启动一个线程，每间隔一段时间会向RM发送心跳信息，其中时间间隔的大小取决于MRAppMaster与RM间的心跳时间间隔”yarn.app.mapreduce.am.scheduler.heartbeat.interval-ms” , 默认值为1000ms。</p>
<p>RMCommunicator.java:<br>startAllocatorThread()<br>    —&gt;heartbeat()</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="label">RMContainerAllocator.java:</span>
  protected synchronized void heartbeat() throws Exception {
    scheduleStats<span class="preprocessor">.updateAndLogIfChanged</span>(<span class="string">"Before Scheduling: "</span>)<span class="comment">;</span>
    //用以周期性的向RM发送心跳信息
    List&lt;Container&gt; allocatedContainers = getResources()<span class="comment">;</span>
    if (allocatedContainers<span class="preprocessor">.size</span>() &gt; <span class="number">0</span>) {
      //对获取到的资源进行再分配，将资源分配给具体的task，如map或者reduce
      scheduledRequests<span class="preprocessor">.assign</span>(allocatedContainers)<span class="comment">;</span>
    }

    int completedMaps = getJob()<span class="preprocessor">.getCompletedMaps</span>()<span class="comment">;</span>
    int completedTasks = completedMaps + getJob()<span class="preprocessor">.getCompletedReduces</span>()<span class="comment">;</span>
    if (lastCompletedTasks != completedTasks) {
      lastCompletedTasks = completedTasks<span class="comment">;</span>
      recalculateReduceSchedule = true<span class="comment">;</span>
    }

    if (recalculateReduceSchedule) {
      preemptReducesIfNeeded()<span class="comment">;</span>
      scheduleReduces(
          getJob()<span class="preprocessor">.getTotalMaps</span>(), completedMaps,
          scheduledRequests<span class="preprocessor">.maps</span><span class="preprocessor">.size</span>(), scheduledRequests<span class="preprocessor">.reduces</span><span class="preprocessor">.size</span>(), 
          assignedRequests<span class="preprocessor">.maps</span><span class="preprocessor">.size</span>(), assignedRequests<span class="preprocessor">.reduces</span><span class="preprocessor">.size</span>(),
          mapResourceReqt, reduceResourceReqt,
          pendingReduces<span class="preprocessor">.size</span>(), 
          maxReduceRampupLimit, reduceSlowStart)<span class="comment">;</span>
      recalculateReduceSchedule = false<span class="comment">;</span>
    }

    scheduleStats<span class="preprocessor">.updateAndLogIfChanged</span>(<span class="string">"After Scheduling: "</span>)<span class="comment">;</span>
  }
</pre></td></tr></table></figure>

<p>heartbeat()<br>    —&gt;getResources()<br>    —&gt;assign()</p>
<p>RMContainerAllocator.java:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
</pre></td><td class="code"><pre>    private void assign(List&lt;Container&gt; allocatedContainers) {
      Iterator&lt;Container&gt; it = allocatedContainers<span class="preprocessor">.iterator</span>()<span class="comment">;</span>
      LOG<span class="preprocessor">.info</span>(<span class="string">"Got allocated containers "</span> + allocatedContainers<span class="preprocessor">.size</span>())<span class="comment">;</span>
      containersAllocated += allocatedContainers<span class="preprocessor">.size</span>()<span class="comment">;</span>
      while (it<span class="preprocessor">.hasNext</span>()) {
        Container allocated = it<span class="preprocessor">.next</span>()<span class="comment">;</span>
        if (LOG<span class="preprocessor">.isDebugEnabled</span>()) {
          LOG<span class="preprocessor">.debug</span>(<span class="string">"Assigning container "</span> + allocated<span class="preprocessor">.getId</span>()
              + <span class="string">" with priority "</span> + allocated<span class="preprocessor">.getPriority</span>() + <span class="string">" to NM "</span>
              + allocated<span class="preprocessor">.getNodeId</span>())<span class="comment">;</span>
        }
        
        // check if allocated container meets memory requirements 
        // <span class="keyword">and</span> whether we have any scheduled tasks that need 
        // a container to be assigned
        boolean isAssignable = true<span class="comment">;</span>
        Priority priority = allocated<span class="preprocessor">.getPriority</span>()<span class="comment">;</span>
        int allocatedMemory = allocated<span class="preprocessor">.getResource</span>()<span class="preprocessor">.getMemory</span>()<span class="comment">;</span>
        if (PRIORITY_FAST_FAIL_MAP<span class="preprocessor">.equals</span>(priority) 
            || PRIORITY_MAP<span class="preprocessor">.equals</span>(priority)) {
          if (allocatedMemory &lt; mapResourceReqt
              || maps<span class="preprocessor">.isEmpty</span>()) {
            LOG<span class="preprocessor">.info</span>(<span class="string">"Cannot assign container "</span> + allocated 
                + <span class="string">" for a map as either "</span>
                + <span class="string">" container memory less than required "</span> + mapResourceReqt
                + <span class="string">" or no pending map tasks - maps.isEmpty="</span> 
                + maps<span class="preprocessor">.isEmpty</span>())<span class="comment">; </span>
            isAssignable = false<span class="comment">; </span>
          }
        } 
        else if (PRIORITY_REDUCE<span class="preprocessor">.equals</span>(priority)) {
          if (allocatedMemory &lt; reduceResourceReqt
              || reduces<span class="preprocessor">.isEmpty</span>()) {
            LOG<span class="preprocessor">.info</span>(<span class="string">"Cannot assign container "</span> + allocated 
                + <span class="string">" for a reduce as either "</span>
                + <span class="string">" container memory less than required "</span> + reduceResourceReqt
                + <span class="string">" or no pending reduce tasks - reduces.isEmpty="</span> 
                + reduces<span class="preprocessor">.isEmpty</span>())<span class="comment">; </span>
            isAssignable = false<span class="comment">;</span>
          }
        } else {
          LOG<span class="preprocessor">.warn</span>(<span class="string">"Container allocated at unwanted priority: "</span> + priority + 
              <span class="string">". Returning to RM..."</span>)<span class="comment">;</span>
          isAssignable = false<span class="comment">;</span>
        }
        
        if(!isAssignable) {
          // release container if we could not assign it 
          containerNotAssigned(allocated)<span class="comment">;</span>
          it<span class="preprocessor">.remove</span>()<span class="comment">;</span>
          continue<span class="comment">;</span>
        }
        
        // do not assign if allocated container is on a  
        // blacklisted host
        String allocatedHost = allocated<span class="preprocessor">.getNodeId</span>()<span class="preprocessor">.getHost</span>()<span class="comment">;</span>
        if (isNodeBlacklisted(allocatedHost)) {
          // we need to request for a new container 
          // <span class="keyword">and</span> release the current one
          LOG<span class="preprocessor">.info</span>(<span class="string">"Got allocated container on a blacklisted "</span>
              + <span class="string">" host "</span>+allocatedHost
              +<span class="string">". Releasing container "</span> + allocated)<span class="comment">;</span>

          // find the request matching this allocated container 
          // <span class="keyword">and</span> replace it with a new one 
          ContainerRequest toBeReplacedReq = 
              getContainerReqToReplace(allocated)<span class="comment">;</span>
          if (toBeReplacedReq != null) {
            LOG<span class="preprocessor">.info</span>(<span class="string">"Placing a new container request for task attempt "</span> 
                + toBeReplacedReq<span class="preprocessor">.attemptID</span>)<span class="comment">;</span>
            ContainerRequest newReq = 
                getFilteredContainerRequest(toBeReplacedReq)<span class="comment">;</span>
            decContainerReq(toBeReplacedReq)<span class="comment">;</span>
            if (toBeReplacedReq<span class="preprocessor">.attemptID</span><span class="preprocessor">.getTaskId</span>()<span class="preprocessor">.getTaskType</span>() ==
                TaskType<span class="preprocessor">.MAP</span>) {
              maps<span class="preprocessor">.put</span>(newReq<span class="preprocessor">.attemptID</span>, newReq)<span class="comment">;</span>
            }
            else {
              reduces<span class="preprocessor">.put</span>(newReq<span class="preprocessor">.attemptID</span>, newReq)<span class="comment">;</span>
            }
            addContainerReq(newReq)<span class="comment">;</span>
          }
          else {
            LOG<span class="preprocessor">.info</span>(<span class="string">"Could not map allocated container to a valid request."</span>
                + <span class="string">" Releasing allocated container "</span> + allocated)<span class="comment">;</span>
          }
          
          // release container if we could not assign it 
          containerNotAssigned(allocated)<span class="comment">;</span>
          it<span class="preprocessor">.remove</span>()<span class="comment">;</span>
          continue<span class="comment">;</span>
        }
      }

      assignContainers(allocatedContainers)<span class="comment">;</span>
       
      // release container if we could not assign it 
      it = allocatedContainers<span class="preprocessor">.iterator</span>()<span class="comment">;</span>
      while (it<span class="preprocessor">.hasNext</span>()) {
        Container allocated = it<span class="preprocessor">.next</span>()<span class="comment">;</span>
        LOG<span class="preprocessor">.info</span>(<span class="string">"Releasing unassigned and invalid container "</span> 
            + allocated + <span class="string">". RM may have assignment issues"</span>)<span class="comment">;</span>
        containerNotAssigned(allocated)<span class="comment">;</span>
      }
    }
</pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-31T14:38:14.000Z"><a href="/2014/05/31/tcp-optimization/">5月 31 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/05/31/tcp-optimization/">Socket 缓冲区</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="-5957-63a5-5b57-7f13-51b2-533a-">套接字缓冲区</h2>
<p>每个套接字都对应着一个缓冲区，当调用write()系统调用时，kernel将从应用的缓冲区中将数据拷贝的socket的发送缓冲区中，当缓冲区中无法容纳应用本次发送的所有数据时（或是因为应用缓冲区本身就大于发送缓冲区，或是发送缓冲区中已有数据剩余空间不足），应用将被阻塞而睡眠等待，直至应用缓冲区中的数据全被拷贝至发送缓冲区中，write系统调用方返回，此时仅仅意味着应用缓冲区可被重用，但数据本身还未必被发送。</p>
<p>TCP将取套接口缓冲区中的数据并发送给对端，在对端确认已收到数据后，本端方可将缓冲区中的数据删除，TCP将保留数据拷贝直至对端确认。（连接关闭时缓冲区中数据的处理？）</p>
<p>TCP以MSS大小的或更小的块将数据传递给IP，同时给每个数据块安上一个TCP头部以构成TCP分节。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>MSS为最大分节大小，在连接建立时协商，是SYN包的一个选项，用于向对端TCP通告对端在每个分节中能发送的最大的TCP数据量。MSS的目的是告诉对端其重组缓冲区大小的实际值，从而避免分片，通常设置为MTU减去IP与TCP头部的固定长度，IPV4中为1460。
</pre></td></tr></table></figure>

<p>MSS是对端通告的，在对端未通告时就用536这个值（IPV4的最小重组缓冲区字节数576减去IPV4头部字节数20与TCP头部字节数20）。</p>
<p>IP层将为每个TCP分节加上IP头以构成IP数据报，查找其宿IP地址的路由表以确定外出的接口。然后将数据报传递给相应的数据链路。IP可能在数据报传递给数据链路前将其分片。</p>
<p>每个数据链路有一个输出队列，如果队列已满，则新到的分组将被丢弃，并沿协议栈向上返回错误，TCP将处理这个错误，并尝试重传相应的分节，应用进程并不知道这个错误。</p>
<h2 id="-7f13-51b2-533a-5927-5c0f-8bbe-7f6e-">缓冲区大小设置</h2>
<p>套接口缓冲区中”可用空间的”大小本身还影响着TCP通告对端的窗口大小，TCP套接口接收缓冲区不可能溢出，因为不允许对端发出超过本端所通告的窗口大小的数据，这就是TCP的流量控制。</p>
<p>SO_RCVBUF和SO_SNDBUF选项可用于查看或设置套接口缓冲区大小。由于TCP的窗口大小是在连接建立时用SYN与对端互换得到的，由此client端与server端需在连接建立前查看或者设置套接口缓冲区的大小。具体的，对client端而言，需在调用connect()系统调用前，而server端在调用listen()前给监听套接字设置，由accept()系统调用返回的已连接套接字将继承自listen套接字。</p>
<h1 id="BDP">BDP</h1>
<p>在了解了如何设置套接字缓冲区后，随之而来的问题是缓冲区到底该设置多大呢？<br>一个网络连接，可被视为一个管道，带宽为管道的直径，而RTT即为管道的长度，BDP(Bandwidth-Delay Product)带宽-时延积即描述了管道的容量。<br>BDP:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>The delay-bandwidth product <span class="operator">of</span> <span class="operator">a</span> transmission path defines <span class="operator">the</span> amount <span class="operator">of</span> data TCP should have <span class="operator">within</span> <span class="operator">the</span> transmission path <span class="keyword">at</span> <span class="keyword">any</span> <span class="constant">one</span> <span class="built_in">time</span>, <span class="operator">in</span> order <span class="built_in">to</span> fully utilize <span class="operator">the</span> available channel capacity.
</pre></td></tr></table></figure>

<p>BDP 给出了一种简单的方法来计算理论上最优的 TCP socket 缓冲区大小(其中保存了排队等待传输和等待应用程序接收的数据)。如果缓冲区太小，那么 TCP 窗口就不能完全打开，这会对性能造成限制。如果缓冲区太大，那么宝贵的内存资源就会造成浪费。如果您设置的缓冲区大小正好合适，那么就可以完全利用可用的带宽。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="setting">BDP=<span class="value">带宽*RTT</span></span>
</pre></td></tr></table></figure>

<p>由于TCP头部窗口规模字段只占16位，当BDP大小超过64kb时，可考虑在建立连接前通过设置窗口规模选项使用长胖管道选项。</p>
<h2 id="-7cfb-7edf-914d-7f6e-">系统配置</h2>
<p>以上这些配置在2.6.7版本的内核后不再需要劳心的去逐一检查配置，kernel中提供了协议栈自动调优功能：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">cat</span> /<span class="keyword">proc</span>/sys/net/ipv4/tcp_moderate_rcvbuf
</pre></td></tr></table></figure>

<p>kernel中读写缓存：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="variable">$ </span>cat /proc/sys/net/ipv4/tcp_rmem
<span class="number">4096</span> <span class="number">87380</span> <span class="number">4194304</span>
<span class="variable">$ </span>cat /proc/sys/net/ipv4/tcp_wmem
<span class="number">4096</span> <span class="number">16384</span> <span class="number">4194304</span>
</pre></td></tr></table></figure>

<p>应用可申请的最大读写缓存：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="variable">$ </span>cat /proc/sys/net/core/rmem_max
<span class="number">124928</span>
<span class="variable">$ </span>cat /proc/sys/net/core/wmem_max
<span class="number">124928</span>
</pre></td></tr></table></figure>

<p>参考：<br><a href="http://lonesysadmin.net/2013/12/19/account-bandwidth-delay-product-larger-network-buffers/" target="_blank">Account for the Bandwidth-Delay Product with Larger Network Buffers</a><br><a href="http://sandilands.info/sgordon/impact-of-bandwidth-delay-product-on-tcp-throughput" target="_blank">Impact of Bandwidth Delay Product on TCP Throughput</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-28T16:18:04.000Z"><a href="/2014/05/29/learn-protocol-buffers/">5月 29 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/05/29/learn-protocol-buffers/">Learn Protocol Buffers</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Protocol Buffers 是谷歌开放出的一个轻量级的序列化工具，要想使用需首先定义一个.proto文件，遵循其自定义了的一套语法，<a href="https://developers.google.com/protocol-buffers/docs/proto?hl=zh-cn#services" target="_blank">官网介绍</a>。</p>
<h2 id="message">message</h2>
<p>一个简单的示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>message SearchRequest {
    required <span class="keyword">string</span> query = <span class="number">1</span>;
    optional <span class="keyword">int32</span> page_number = <span class="number">2</span>;<span class="comment">// Which page number do we want?  注释采用C语言风格。</span>
    optional <span class="keyword">int32</span> result_per_page = <span class="number">3</span> [<span class="keyword">default</span> = <span class="number">10</span>]; <span class="comment">//指定默认值</span>
}
</pre></td></tr></table></figure>

<p>message关键字指定定义了一个结构化数据，以上定义了两个整形与一个字符串形，required 等限定字指定其规则：<br>-(1) required：这个域在消息中必须刚好有1个；<br>-(2) optional：这个域在消息中可以有0或1个；<br>-(3) repeated：这个域在消息中可以有从多个，包括0个。</p>
<p>最后的数字用以唯一标识结构成员在序列化后的二进制数据中的位置，1-15使用一个字节编码，其中包含成员的标识及类型信息，16-2047使用两个字节存储，由此频繁使用尽可能排在靠前的位置使用前15号标识。</p>
<h2 id="service">service</h2>
<p>example:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>service EchoService
{
    rpc Echo(EchoRequest) returns (EchoResponse)<span class="comment">;</span>
    rpc Dummy(DummyRequest) returns (DummyResponse)<span class="comment">;</span>
}<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>If you want to use your message types with an RPC (Remote Procedure Call) system, you can define an RPC service interface in a .proto file and the protocol buffer compiler will generate service interface code and stubs in your chosen language.</p>
<p>service关键字指定定义一个接口类，通过protoc 可自动化生成一个供server端使用的接口及client端对应的stub类。</p>
<p>编译命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>protoc -I=<span class="variable">$SRC_DIR</span> --cpp_out=<span class="variable">$DST_DIR</span> <span class="variable">$SRC_DIR</span>/<span class="built_in">echo</span>.proto
</pre></td></tr></table></figure>

<p>经编译将生成echo.pb.h ， echo.pb.cc两个文件。其中定义了由service指定的EchoService抽象接口类以及client端使用的EchoService_Stub stub 类。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="type">EchoService_Stub</span>;

<span class="keyword">class</span> <span class="type">EchoService</span> : public ::google::protobuf::<span class="type">Service</span> {
 protected:
  // <span class="type">This</span> <span class="keyword">class</span> should be treated as an abstract interface.
  inline <span class="type">EchoService</span><span class="container">()</span> {};
 public:
  virtual ~<span class="type">EchoService</span><span class="container">()</span>;

  typedef <span class="type">EchoService_Stub</span> <span class="type">Stub</span>; //通过typedef将实际名为<span class="type">EchoService_Stub</span>的

  static const ::google::protobuf::<span class="type">ServiceDescriptor</span>* descriptor<span class="container">()</span>;

  virtual void <span class="type">Echo</span><span class="container">(::<span class="title">google</span>::<span class="title">protobuf</span>::<span class="type">RpcController</span>* <span class="title">controller</span>,
                       <span class="title">const</span> ::<span class="title">echo</span>::<span class="type">EchoRequest</span>* <span class="title">request</span>,
                       ::<span class="title">echo</span>::<span class="type">EchoResponse</span>* <span class="title">response</span>,
                       ::<span class="title">google</span>::<span class="title">protobuf</span>::<span class="type">Closure</span>* <span class="title">done</span>)</span>;
  virtual void <span class="type">Dummy</span><span class="container">(::<span class="title">google</span>::<span class="title">protobuf</span>::<span class="type">RpcController</span>* <span class="title">controller</span>,
                       <span class="title">const</span> ::<span class="title">echo</span>::<span class="type">DummyRequest</span>* <span class="title">request</span>,
                       ::<span class="title">echo</span>::<span class="type">DummyResponse</span>* <span class="title">response</span>,
                       ::<span class="title">google</span>::<span class="title">protobuf</span>::<span class="type">Closure</span>* <span class="title">done</span>)</span>;

  // implements <span class="type">Service</span> ----------------------------------------------

  const ::google::protobuf::<span class="type">ServiceDescriptor</span>* <span class="type">GetDescriptor</span><span class="container">()</span>;
  void <span class="type">CallMethod</span><span class="container">(<span class="title">const</span> ::<span class="title">google</span>::<span class="title">protobuf</span>::<span class="type">MethodDescriptor</span>* <span class="title">method</span>,
                  ::<span class="title">google</span>::<span class="title">protobuf</span>::<span class="type">RpcController</span>* <span class="title">controller</span>,
                  <span class="title">const</span> ::<span class="title">google</span>::<span class="title">protobuf</span>::<span class="type">Message</span>* <span class="title">request</span>,
                  ::<span class="title">google</span>::<span class="title">protobuf</span>::<span class="type">Message</span>* <span class="title">response</span>,
                  ::<span class="title">google</span>::<span class="title">protobuf</span>::<span class="type">Closure</span>* <span class="title">done</span>)</span>;
  const ::google::protobuf::<span class="type">Message</span>& <span class="type">GetRequestPrototype</span><span class="container">(
    <span class="title">const</span> ::<span class="title">google</span>::<span class="title">protobuf</span>::<span class="type">MethodDescriptor</span>* <span class="title">method</span>)</span> const;
  const ::google::protobuf::<span class="type">Message</span>& <span class="type">GetResponsePrototype</span><span class="container">(
    <span class="title">const</span> ::<span class="title">google</span>::<span class="title">protobuf</span>::<span class="type">MethodDescriptor</span>* <span class="title">method</span>)</span> const;

 private:
  <span class="type">GOOGLE_DISALLOW_EVIL_CONSTRUCTORS</span><span class="container">(<span class="type">EchoService</span>)</span>;
};</span>
</pre></td></tr></table></figure>

<p>client 端一次rpc调用的执行过程：</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-28T07:19:02.000Z"><a href="/2014/05/28/jvm-reuse-in-yarn/">5月 28 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/05/28/jvm-reuse-in-yarn/">JVM reuse in Yarn</a></h1>
  

    </header>
    <div class="entry">
      
        <p>java 这种基于虚拟机的语言，在进程启动时伴随着启动相应的jvm，对于长期运行的服务，jvm本身的启动开销还好，但对于小job，jvm本身的启动开销不再可被忽视。尝试复用jvm，在一个jvm中完成多个task，减小jvm启动开销，也可减少单机运行的进程数。</p>
<h2 id="-914d-7f6e-">配置</h2>
<p>mapreduce.job.ubertask.enable<br>mapreduce.job.ubertask.maxmaps<br>mapreduce.job.ubertask.maxreduces<br>mapreduce.job.ubertask.maxbytes</p>
<h2 id="-5b9e-73b0-">实现</h2>
<p>makeUberDecision()函数将结合集群的配置决定当前的job是否开启uber模式。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
</pre></td><td class="code"><pre>private void makeUberDecision(long dataInputLength) {
    //FIXME:  need new memory criterion for uber-decision (oops, too late here<span class="comment">;</span>
    // until AM-resizing supported,
    // must depend on job client to pass fat-slot needs)
    // these are no longer <span class="string">"system"</span> settings, necessarily<span class="comment">; user may override</span>
    int sysMaxMaps = conf<span class="preprocessor">.getInt</span>(MRJobConfig<span class="preprocessor">.JOB</span>_UBERTASK_MAXMAPS, <span class="number">9</span>)<span class="comment">;</span>

    //FIXME: handling multiple reduces within a single AM does not seem to
    //work.
    int sysMaxReduces = conf<span class="preprocessor">.getInt</span>(MRJobConfig<span class="preprocessor">.JOB</span>_UBERTASK_MAXREDUCES, <span class="number">1</span>)<span class="comment">;</span>
    boolean isValidUberMaxReduces = (sysMaxReduces == <span class="number">0</span>)
        || (sysMaxReduces == <span class="number">1</span>)<span class="comment">;</span>

    long sysMaxBytes = conf<span class="preprocessor">.getLong</span>(MRJobConfig<span class="preprocessor">.JOB</span>_UBERTASK_MAXBYTES,
            fs<span class="preprocessor">.getDefaultBlockSize</span>(this<span class="preprocessor">.remoteJobSubmitDir</span>))<span class="comment">; // FIXME: this is wrong; get FS from</span>
    // [File?]InputFormat <span class="keyword">and</span> default block size
    // from that

    long sysMemSizeForUberSlot =
        conf<span class="preprocessor">.getInt</span>(MRJobConfig<span class="preprocessor">.MR</span>_AM_VMEM_MB,
                MRJobConfig<span class="preprocessor">.DEFAULT</span>_MR_AM_VMEM_MB)<span class="comment">;</span>

    long sysCPUSizeForUberSlot =
        conf<span class="preprocessor">.getInt</span>(MRJobConfig<span class="preprocessor">.MR</span>_AM_CPU_VCORES,
                MRJobConfig<span class="preprocessor">.DEFAULT</span>_MR_AM_CPU_VCORES)<span class="comment">;</span>

    boolean uberEnabled =
        conf<span class="preprocessor">.getBoolean</span>(MRJobConfig<span class="preprocessor">.JOB</span>_UBERTASK_ENABLE, false)<span class="comment">;</span>
    boolean smallNumMapTasks = (numMapTasks &lt;= sysMaxMaps)<span class="comment">;</span>
    boolean smallNumReduceTasks = (numReduceTasks &lt;= sysMaxReduces)<span class="comment">;</span>
    boolean smallInput = (dataInputLength &lt;= sysMaxBytes)<span class="comment">;</span>
    // ignoring overhead due to UberAM <span class="keyword">and</span> statics as negligible here:
    boolean smallMemory =
        ( (Math<span class="preprocessor">.max</span>(conf<span class="preprocessor">.getLong</span>(MRJobConfig<span class="preprocessor">.MAP</span>_MEMORY_MB, <span class="number">0</span>),
                    conf<span class="preprocessor">.getLong</span>(MRJobConfig<span class="preprocessor">.REDUCE</span>_MEMORY_MB, <span class="number">0</span>))
           &lt;= sysMemSizeForUberSlot)
          || (sysMemSizeForUberSlot == JobConf<span class="preprocessor">.DISABLED</span>_MEMORY_LIMIT))<span class="comment">;</span>
    boolean smallCpu =
        (
         Math<span class="preprocessor">.max</span>(
             conf<span class="preprocessor">.getInt</span>(
                 MRJobConfig<span class="preprocessor">.MAP</span>_CPU_VCORES, 
                 MRJobConfig<span class="preprocessor">.DEFAULT</span>_MAP_CPU_VCORES), 
             conf<span class="preprocessor">.getInt</span>(
                 MRJobConfig<span class="preprocessor">.REDUCE</span>_CPU_VCORES, 
                 MRJobConfig<span class="preprocessor">.DEFAULT</span>_REDUCE_CPU_VCORES)) 
         &lt;= sysCPUSizeForUberSlot
        )<span class="comment">;</span>
    boolean notChainJob = !isChainJob(conf)<span class="comment">;</span>

    // User has overall veto power over uberization, <span class="keyword">or</span> user can modify
    // limits (overriding system settings <span class="keyword">and</span> potentially shooting
    // themselves <span class="keyword">in</span> the head).  Note that ChainMapper/Reducer are
    // fundamentally incompatible with MR-<span class="number">1220</span><span class="comment">; they employ a blocking</span>
    // queue between the maps/reduces <span class="keyword">and</span> thus require parallel execution,
    // while <span class="string">"uber-AM"</span> (MR AM + LocalContainerLauncher) loops over tasks
    // <span class="keyword">and</span> thus requires sequential execution.
    isUber = uberEnabled && smallNumMapTasks && smallNumReduceTasks
        && smallInput && smallMemory && smallCpu 
        && notChainJob && isValidUberMaxReduces<span class="comment">;</span>

    if (isUber) {
        LOG<span class="preprocessor">.info</span>(<span class="string">"Uberizing job "</span> + jobId + <span class="string">": "</span> + numMapTasks + <span class="string">"m+"</span>
                + numReduceTasks + <span class="string">"r tasks ("</span> + dataInputLength
                + <span class="string">" input bytes) will run sequentially on single node."</span>)<span class="comment">;</span>

        // make sure reduces are scheduled only after all map are completed
        conf<span class="preprocessor">.setFloat</span>(MRJobConfig<span class="preprocessor">.COMPLETED</span>_MAPS_FOR_REDUCE_SLOWSTART,
                <span class="number">1.0</span>f)<span class="comment">;</span>
        // uber-subtask attempts all get launched on same node<span class="comment">; if one fails,</span>
        // probably should retry elsewhere, i<span class="preprocessor">.e</span>., move entire uber-AM:  ergo,
        // limit attempts to <span class="number">1</span> (<span class="keyword">or</span> at most <span class="number">2</span>?  probably not...)
        conf<span class="preprocessor">.setInt</span>(MRJobConfig<span class="preprocessor">.MAP</span>_MAX_ATTEMPTS, <span class="number">1</span>)<span class="comment">;</span>
        conf<span class="preprocessor">.setInt</span>(MRJobConfig<span class="preprocessor">.REDUCE</span>_MAX_ATTEMPTS, <span class="number">1</span>)<span class="comment">;</span>

        // disable speculation
        conf<span class="preprocessor">.setBoolean</span>(MRJobConfig<span class="preprocessor">.MAP</span>_SPECULATIVE, false)<span class="comment">;</span>
        conf<span class="preprocessor">.setBoolean</span>(MRJobConfig<span class="preprocessor">.REDUCE</span>_SPECULATIVE, false)<span class="comment">;</span>
    } else {
        StringBuilder msg = new StringBuilder()<span class="comment">;</span>
        msg<span class="preprocessor">.append</span>(<span class="string">"Not uberizing "</span>)<span class="preprocessor">.append</span>(jobId)<span class="preprocessor">.append</span>(<span class="string">" because:"</span>)<span class="comment">;</span>
        if (!uberEnabled)
            msg<span class="preprocessor">.append</span>(<span class="string">" not enabled;"</span>)<span class="comment">;</span>
        if (!smallNumMapTasks)
            msg<span class="preprocessor">.append</span>(<span class="string">" too many maps;"</span>)<span class="comment">;</span>
        if (!smallNumReduceTasks)
            msg<span class="preprocessor">.append</span>(<span class="string">" too many reduces;"</span>)<span class="comment">;</span>
        if (!smallInput)
            msg<span class="preprocessor">.append</span>(<span class="string">" too much input;"</span>)<span class="comment">;</span>
        if (!smallMemory)
            msg<span class="preprocessor">.append</span>(<span class="string">" too much RAM;"</span>)<span class="comment">;</span>
        if (!notChainJob)
            msg<span class="preprocessor">.append</span>(<span class="string">" chainjob;"</span>)<span class="comment">;</span>
        if (!isValidUberMaxReduces)
            msg<span class="preprocessor">.append</span>(<span class="string">" not supported uber max reduces"</span>)<span class="comment">;</span>
        LOG<span class="preprocessor">.info</span>(msg<span class="preprocessor">.toString</span>())<span class="comment">;</span>
    }
}
</pre></td></tr></table></figure>

<p>对于开启uber模式的job，其执行处理流程如下：<br>Resource Manager里的Application Manager会为每一个application在NodeManager里面申请一个container，然后在该container里面启动一个Application Master。containe启动时便会相应启动一个JVM。此时，如果uber功能被启用，并且该application被认为是一个“小的application”，那么Application Master便会将该application包含的每一个task依次在这个container里的JVM里顺序执行，直到所有task被执行完(“WIth ‘uber’ mode enabled, you’ll run everything within the container of the AM itself”)。这样Application Master便不用再为每一个task向Resource Manager去申请一个单独的container，最终达到了 JVM重用（资源重用）的目的。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-27T09:26:14.000Z"><a href="/2014/05/27/千兆网卡驱动分析/">5月 27 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/05/27/千兆网卡驱动分析/">千兆网卡驱动分析</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="-4e2d-65ad-7533-8bf7-">中断申请</h1>
<p>对驱动程序来说，都是有着固定的流程。中断申请通常是在网络设备被打开时才申请。对网络设备而言，打开操作对应的是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
</pre></td><td class="code"><pre>/*
 * The <span class="keyword">open</span> entry point is called <span class="keyword">when</span> a network interface is made
 * active by the <span class="keyword">system</span> (IFF_UP).  At this point all resources needed
 * <span class="keyword">for</span> transmit <span class="keyword">and</span> receive operations are allocated, the interrupt
 * handler is registered with the OS, the watchdog timer is started,
 * <span class="keyword">and</span> the stack is notified that the interface is ready.
 <span class="variable">*/</span>
static <span class="keyword">int</span> e1000_open(struct net_device <span class="variable">*netdev</span>)
{
	struct e1000_adapter <span class="variable">*adapter</span> = netdev_priv(netdev);
	struct e1000_hw <span class="variable">*hw</span> = &adapter-&gt;hw;
	struct pci_dev <span class="variable">*pdev</span> = adapter-&gt;pdev;
	<span class="keyword">int</span> err;

	adapter-&gt;pdev = pdev;
	<span class="regexp">/* disallow open during test */</span>
	<span class="keyword">if</span> (test_bit(__E1000_TESTING, &adapter-&gt;state))
		<span class="keyword">return</span> -EBUSY;

	pm_runtime_get_sync(pci_dev_to_dev(pdev));

	netif_carrier_off(netdev);

	<span class="regexp">/* 分配发送描述符队列 */</span>
	err = e1000e_setup_tx_resources(adapter-&gt;tx_ring);
	<span class="keyword">if</span> (err)
		<span class="keyword">goto</span> err_setup_tx;

	<span class="regexp">/* allocate receive descriptors */</span>
	/* 分配接收描述符队列 <span class="variable">*/</span>
	err = e1000e_setup_rx_resources(adapter-&gt;rx_ring);
	<span class="keyword">if</span> (err)
		<span class="keyword">goto</span> err_setup_rx;

    ...

	e1000e_power_up_phy(adapter);

    ...

	<span class="regexp">/* before we allocate an interrupt, we must be ready to handle it.
	 * Setting DEBUG_SHIRQ in the kernel makes it fire an interrupt
	 * as soon as we call pci_request_irq, so we have to setup our
	 * clean_rx handler before we do so.
	 */</span>
	e1000_configure(adapter);

    <span class="regexp">/* 申请中断并注册中断处理函数 */</span>
	err = e1000_request_ir<span class="string">q(adapter)</span>;
	<span class="keyword">if</span> (err)
		<span class="keyword">goto</span> err_req_irq;

    ...

	<span class="regexp">/* From here on the code is the same as e1000e_up() */</span>
	clear_bit(__E1000_DOWN, &adapter-&gt;state);

<span class="comment">#ifdef CONFIG_E1000E_NAPI</span>
	napi_enable(&adapter-&gt;napi);
<span class="comment">#endif</span>

	e1000_irq_enable(adapter);

	adapter-&gt;tx_hang_recheck = false;
	
    <span class="regexp">/*通知协议栈当前设备可用*/</span>
    /<span class="variable">*Allow</span> upper layers to call the device hard_start_xmit routine<span class="variable">*/</span>
    netif_start_queue(netdev);

	hw-&gt;mac.get_link_status = true;
	pm_runtime_put(pci_dev_to_dev(pdev));

    <span class="regexp">/* 启动watchdog */</span>
	/* fire a <span class="keyword">link</span> status change interrupt to start the watchdog <span class="variable">*/</span>
	<span class="keyword">if</span> (adapter-&gt;msix_entries)
		ew32(ICS, E1000_ICS_LSC | E1000_ICR_OTHER);
	<span class="keyword">else</span>
		ew32(ICS, E1000_ICS_LSC);

	<span class="keyword">return</span> <span class="number">0</span>;

    ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre>/<span class="variable">**</span>
 * e1000e_setup_rx_resources - allocate Rx resources (Descriptors)
 * <span class="variable">@rx_ring</span>: Rx descriptor ring
 *
 * Returns <span class="number">0</span> on success, negative on failure
 <span class="variable">**</span>/
<span class="keyword">int</span> e1000e_setup_rx_resources(struct e1000_ring <span class="variable">*rx_ring</span>)
{
	struct e1000_adapter <span class="variable">*adapter</span> = rx_ring-&gt;adapter;
	struct e1000_buffer <span class="variable">*buffer_info</span>;
	<span class="keyword">int</span> i, size, desc_len, err = -ENOMEM;

	size = sizeof(struct e1000_buffer) * rx_ring-&gt;count;
   
    <span class="regexp">/* 调用vmalloc 分配ringbuffer管理结构*/</span>
	rx_ring-&gt;buffer_info = vzalloc_node(size, adapter-&gt;node);
	<span class="keyword">if</span> (!rx_ring-&gt;buffer_info)
		<span class="keyword">goto</span> err;

	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rx_ring-&gt;count; i++) {
		buffer_info = &rx_ring-&gt;buffer_info[i];
        <span class="regexp">/* 调用kmalloc为每一个*/</span>
		buffer_info-&gt;ps_pages = kzalloc_node(PS_PAGE_BUFFERS *
						     sizeof(struct
							    e1000_ps_page),
						     GFP_KERNEL, adapter-&gt;node);
		<span class="keyword">if</span> (!buffer_info-&gt;ps_pages)
			<span class="keyword">goto</span> err_pages;
	}

	desc_len = sizeof(union e1000_rx_desc_packet_split);

	<span class="regexp">/* Round up to nearest 4K */</span>
	rx_ring-&gt;size = rx_ring-&gt;count * desc_len;
	rx_ring-&gt;size = ALIGN(rx_ring-&gt;size, <span class="number">4096</span>);

	err = e1000_alloc_ring_dma(adapter, rx_ring);
	<span class="keyword">if</span> (err)
		<span class="keyword">goto</span> err_pages;

	rx_ring-&gt;next_to_clean = <span class="number">0</span>;
	rx_ring-&gt;next_to_use = <span class="number">0</span>;
	rx_ring-&gt;rx_skb_top = NULL;

	<span class="keyword">return</span> <span class="number">0</span>;

err_pages:
	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rx_ring-&gt;count; i++) {
		buffer_info = &rx_ring-&gt;buffer_info[i];
		kfree(buffer_info-&gt;ps_pages);
	}
err:
	vfree(rx_ring-&gt;buffer_info);
	e_err(<span class="string">"Unable to allocate memory for the receive descriptor ring\n"</span>);
	<span class="keyword">return</span> err;
}
</pre></td></tr></table></figure>

<h1 id="-5185-5b58-">内存</h1>
<p>网卡启动时初始化分配ringbuffer管理结构所使用的内存空间<br>e1000_open()<br>    —&gt; e1000e_setup_tx_resources(adapter-&gt;tx_ring);    /<em> allocate transmit descriptors </em>/<br>    —&gt; e1000e_setup_rx_resources(adapter-&gt;rx_ring); /<em> 分配ringbuffer管理结构，e1000_buffer供软件使用，desc供硬件使用 </em>/</p>
<p>随后调用e1000_configure()实际分配skb_buff数据缓冲区<br>e1000_open()<br>e1000_up()<br>    —&gt; e1000_configure(adapter);<br>        —&gt; e1000_configure_rx(adapter);<br>        —&gt; e1000_configure_tx(adapter); /<em> 分配 alloc_rx_buf() 函数</em>/<br>        —&gt; e1000_alloc_rx_buffers()</p>
<p>e1000_configure()</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>static void e1000_configure(struct e1000_adapter <span class="variable">*adapter</span>)
{
	struct e1000_ring <span class="variable">*rx_ring</span> = adapter-&gt;rx_ring;

	e1000e_set_rx_mode(adapter-&gt;netdev);

<span class="comment">#if defined(NETIF_F_HW_VLAN_TX) || defined(NETIF_F_HW_VLAN_CTAG_TX)</span>
	e1000_restore_vlan(adapter);
<span class="comment">#endif</span>
	e1000_init_manageability_pt(adapter);

	e1000_configure_tx(adapter);

<span class="comment">#ifdef NETIF_F_RXHASH</span>
	<span class="keyword">if</span> (adapter-&gt;netdev-&gt;features & NETIF_F_RXHASH)
		e1000e_setup_rss_hash(adapter);
<span class="comment">#endif</span>
	e1000_setup_rctl(adapter);
	e1000_configure_rx(adapter);
	adapter-&gt;alloc_rx_buf(rx_ring, e1000_desc_unused(rx_ring), GFP_KERNEL);
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre></td><td class="code"><pre>/<span class="variable">**</span>
 * e1000_alloc_rx_buffers - Replace used receive buffers
 * <span class="variable">@rx_ring</span>: Rx descriptor ring
 * <span class="variable">@cleaned_count</span>: 本次需分配的skb_buff 的个数
 <span class="variable">**</span>/
static void e1000_alloc_rx_buffers(struct e1000_ring <span class="variable">*rx_ring</span>,
				   <span class="keyword">int</span> cleaned_count, gfp_t gfp)
{
	struct e1000_adapter <span class="variable">*adapter</span> = rx_ring-&gt;adapter;
	struct net_device <span class="variable">*netdev</span> = adapter-&gt;netdev;
	struct pci_dev <span class="variable">*pdev</span> = adapter-&gt;pdev;
	union e1000_rx_desc_extended <span class="variable">*rx_desc</span>;
	struct e1000_buffer <span class="variable">*buffer_info</span>;
	struct sk_buff <span class="variable">*skb</span>;
	unsigned <span class="keyword">int</span> i;
	unsigned <span class="keyword">int</span> bufsz = adapter-&gt;rx_buffer_len;

    <span class="regexp">//e</span>1000_buffer为ringbuffer的管理结构，为软件使用的，注意其内存分配的地址为通过vmalloc分配的，每个e1000_buffer结构均含有一个指向skb_buff结构的指针，通过next_to_use获得当前可用的e1000_buffer结构，从其开始分配skb_buff
	i = rx_ring-&gt;next_to_use;
	buffer_info = &rx_ring-&gt;buffer_info[i];

	<span class="keyword">while</span> (cleaned_count--) {
		skb = buffer_info-&gt;skb;
        <span class="regexp">//</span>如果已经分配skb_buff，则直接做DMA映射
		<span class="keyword">if</span> (skb) {
			skb_trim(skb, <span class="number">0</span>);
			<span class="keyword">goto</span> map_skb;
		}

		skb = __netdev_alloc_skb_ip_align(netdev, bufsz, gfp);
		<span class="keyword">if</span> (!skb) {
			<span class="regexp">/* Better luck next round */</span>
			adapter-&gt;alloc_rx_buff_failed++;
			<span class="keyword">break</span>;
		}

		buffer_info-&gt;skb = skb;
map_skb:
        <span class="regexp">/* DMA_TO_DEVICE表示从主存到设备，DMA_FROM_DEVICE表示从设备到主存 */</span>
		buffer_info-&gt;dma = dma_map_single(&pdev-&gt;dev, skb-&gt;data,
						  adapter-&gt;rx_buffer_len,
						  DMA_FROM_DEVICE);
		<span class="keyword">if</span> (dma_mapping_error(&pdev-&gt;dev, buffer_info-&gt;dma)) {
			dev_err(&pdev-&gt;dev, <span class="string">"Rx DMA map failed\n"</span>);
			adapter-&gt;rx_dma_failed++;
			<span class="keyword">break</span>;
		}

        /<span class="regexp">/获得当前结点对应的硬件管理结构，更新DMA addr,后续硬件收到数据包时将从此结构中获得DMA地址，并由DMA engine负责将数据包有网卡内存直接拷贝至主存中的这个地址
		rx_desc = E1000_RX_DESC_EXT(*rx_ring, i);
		rx_desc-&gt;read.buffer_addr = cpu_to_le64(buffer_info-&gt;dma);

		if (unlikely(!(i & (E1000_RX_BUFFER_WRITE - 1)))) {
			/</span>*
			 * Force memory writes to complete before letting h/w
			 * know there are new descriptors to fetch.  (Only
			 * applicable <span class="keyword">for</span> weak-ordered memory model archs,
			 * such as IA-<span class="number">64</span>).
			 <span class="variable">*/</span>
			wmb();
			<span class="keyword">if</span> (adapter-&gt;flags2 & FLAG2_PCIM2PCI_ARBITER_WA)
				e1000e_update_rdt_wa(rx_ring, i);
			<span class="keyword">else</span>
				writel(i, rx_ring-&gt;tail);
		}
        /<span class="regexp">/分配下一个
		i++;
		if (i == rx_ring-&gt;count)
			i = 0;
		buffer_info = &rx_ring-&gt;buffer_info[i];
	}

	rx_ring-&gt;next_to_use = i;
}</span>
</pre></td></tr></table></figure>

<p>Send Packet:<br>sk_buff 在发包路径上何时被释放：<br>When the buffer has been loaded into the hardware or, in the case of some DMA driven devices, when the hardware has indicated transmission is complete, the driver must release the buffer by calling dev_kfree_skb(skb, FREE_WRITE). As soon as this call is made, the sk_buff in question may spontaneously disappear, and the device driver should not reference it again.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre>include/net/sock.h:
<span class="keyword">struct</span> sock {
    ...

	socket_lock_t		sk_lock;
	<span class="comment">/*
	 * The backlog queue is special, it is always used with
	 * the per-socket spinlock held and requires low latency
	 * access. Therefore we special case it's implementation.
	 */</span>
	<span class="keyword">struct</span> {
		<span class="keyword">struct</span> sk_buff *head;
		<span class="keyword">struct</span> sk_buff *tail;
	} sk_backlog;

    <span class="comment">/* poll thread 等待队列 */</span>
    wait_queue_head_t	*sk_sleep;

    <span class="comment">/* 发送/接收 缓冲区大小 */</span>
	<span class="keyword">int</span>			sk_rcvbuf;
    <span class="keyword">int</span>			sk_sndbuf;

    <span class="comment">/* struct sock 中包含的五个收包队列 */</span>
	<span class="comment">/*
	 * The backlog queue is special, it is always used with
	 * the per-socket spinlock held and requires low latency
	 * access. Therefore we special case it's implementation.
	 */</span>
	<span class="keyword">struct</span> {
		<span class="keyword">struct</span> sk_buff *head;
		<span class="keyword">struct</span> sk_buff *tail;
	} sk_backlog;
	<span class="keyword">struct</span> sk_buff_head	sk_receive_queue;
	<span class="keyword">struct</span> sk_buff_head	sk_write_queue;
<span class="preprocessor">#ifdef CONFIG_NET_DMA</span>
	<span class="keyword">struct</span> sk_buff_head	sk_async_wait_queue;
<span class="preprocessor">#endif</span>
	<span class="keyword">struct</span> sk_buff_head	sk_error_queue;

    <span class="comment">/* 水位线 */</span>
	<span class="keyword">int</span>			sk_rcvlowat;
    <span class="comment">/* 事件处理cb function */</span>
	<span class="keyword">void</span>			(*sk_state_change)(<span class="keyword">struct</span> sock *sk);
	<span class="keyword">void</span>			(*sk_data_ready)(<span class="keyword">struct</span> sock *sk, <span class="keyword">int</span> bytes);
	<span class="keyword">void</span>			(*sk_write_space)(<span class="keyword">struct</span> sock *sk);
	<span class="keyword">void</span>			(*sk_error_report)(<span class="keyword">struct</span> sock *sk);
  	<span class="keyword">int</span>			(*sk_backlog_rcv)(<span class="keyword">struct</span> sock *sk,
						  <span class="keyword">struct</span> sk_buff *skb);  
	<span class="keyword">void</span>                    (*sk_destruct)(<span class="keyword">struct</span> sock *sk);
};
</pre></td></tr></table></figure>

<p>UDP 数据包的收包路径:<br>NF_INET_LOCAL_IN hook:ip_local_deliver_finish()<br>    —&gt;udp_rcv()<br>        —&gt;sk_receive_queue()</p>
<p>网络协议栈调参：<br>/proc/sys/net/core/</p>
<h3 id="e1000e_ringbuffer">e1000e ringbuffer</h3>
<p>收包环说明：<br>next_to_clean和next_to_use是内核读写的；<br>rdt是内核写，网卡只读；<br>rdh是网卡写，内核只读；<br>next_to_clean和rdh之间的是已经接收到数据包的内存；<br>rdh和rdt之间是还未接收到数据包的内存；<br>next_to_use后的是还未使用的区域。</p>
<p>在e1000_configure_rx()函数中对rx_ring-&gt;tail 与head进行初始化工作：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>e1000_configure_rx()
	rx_ring-&gt;head = adapter-&gt;hw.hw_addr + E1000_RDH;
	rx_ring-&gt;tail = adapter-&gt;hw.hw_addr + E1000_RDT;
</pre></td></tr></table></figure>

<p>e1000_alloc_rx_buffers()<br>    —&gt;e1000e_update_rdt_wa()<br>static void e1000e_update_rdt_wa(struct e1000_ring <em>rx_ring, unsigned int i)<br>{<br>    struct e1000_adapter </em>adapter = rx_ring-&gt;adapter;<br>    struct e1000_hw *hw = &amp;adapter-&gt;hw;</p>
<pre><code><span class="function"><span class="title">if</span> <span class="params">(<span class="function_name">e1000e_update_tail_wa</span>(hw, rx_ring-&gt;tail, i))</span> {
    <span class="title">u32</span> <span class="title">rctl</span> = <span class="title">er32</span><span class="params">(<span class="variable">RCTL</span>)</span>;
    <span class="title">ew32</span><span class="params">(<span class="variable">RCTL</span>, rctl &amp; ~<span class="variable">E1000_RCTL_EN</span>)</span>;
    <span class="title">e_err</span><span class="params">(<span class="string">"ME firmware caused invalid RDT - resetting\n"</span>)</span>;
    <span class="title">schedule_work</span><span class="params">(&amp;adapter-&gt;reset_task)</span>;
}</span>
</code></pre><p>}</p>
<p>/**</p>
<ul>
<li>e1000_alloc_rx_buffers - Replace used receive buffers</li>
<li><p>@rx_ring: Rx descriptor ring<br><em>*/<br>static void e1000_alloc_rx_buffers(struct e1000_ring </em>rx_ring,</p>
<pre><code>            <span class="keyword">int</span> cleaned_count, gfp_t gfp)
</code></pre><p>{<br> struct e1000_adapter <em>adapter = rx_ring-&gt;adapter;<br> struct net_device </em>netdev = adapter-&gt;netdev;<br> struct pci_dev <em>pdev = adapter-&gt;pdev;<br> union e1000_rx_desc_extended </em>rx_desc;<br> struct e1000_buffer <em>buffer_info;<br> struct sk_buff </em>skb;<br> unsigned int i;<br> unsigned int bufsz = adapter-&gt;rx_buffer_len;</p>
<p> i = rx_ring-&gt;next_to_use;<br> buffer_info = &amp;rx_ring-&gt;buffer_info[i];</p>
<p> while (cleaned_count—) {</p>
<pre><code> skb = buffer_info-&gt;skb;
 <span class="keyword">if</span> (skb) {
     <span class="regexp">//</span>如果buffer_info中已有对应的skb数据包，则直接映射即可
     skb_trim(skb, <span class="number">0</span>);
     <span class="keyword">goto</span> map_skb;
 }

 /<span class="regexp">/由主存中分配skb数据包
 skb = __netdev_alloc_skb_ip_align(netdev, bufsz, gfp);
 if (!skb) {
     /</span>* Better luck <span class="keyword">next</span> round <span class="variable">*/</span>
     adapter-&gt;alloc_rx_buff_failed++;
     <span class="keyword">break</span>;
 }

 buffer_info-&gt;skb = skb;
</code></pre><p>map_skb:</p>
<pre><code> <span class="comment">//对socket数据缓冲区做DMA映射</span>
 buffer_info<span class="subst">-&gt;</span>dma <span class="subst">=</span> dma_map_single(<span class="subst">&amp;</span>pdev<span class="subst">-&gt;</span>dev, skb<span class="subst">-&gt;</span><span class="built_in">data</span>,
                   adapter<span class="subst">-&gt;</span>rx_buffer_len,
                   DMA_FROM_DEVICE);
 <span class="keyword">if</span> (dma_mapping_error(<span class="subst">&amp;</span>pdev<span class="subst">-&gt;</span>dev, buffer_info<span class="subst">-&gt;</span>dma)) {
     dev_err(<span class="subst">&amp;</span>pdev<span class="subst">-&gt;</span>dev, <span class="string">"Rx DMA map failed\n"</span>);
     adapter<span class="subst">-&gt;</span>rx_dma_failed<span class="subst">++</span>;
     break;
 }

 <span class="comment">//将映射后的DMA地址更新至对应的e1000_rx_desc_extended结构中</span>
 <span class="comment">//供网卡硬件读取并使用，网卡读取地址后即可经由DMA engine直接</span>
 <span class="comment">//将数据包方至主存中</span>
 rx_desc <span class="subst">=</span> E1000_RX_DESC_EXT(<span class="subst">*</span>rx_ring, i);
 rx_desc<span class="subst">-&gt;</span>read<span class="built_in">.</span>buffer_addr <span class="subst">=</span> cpu_to_le64(buffer_info<span class="subst">-&gt;</span>dma);

 <span class="comment">//在为buffer分配了数据包缓冲区并完成了DMA映射后，不会立即</span>
 <span class="comment">//更新rx_ring-&gt;tail来指示网卡硬件当前有新的可用了，而是缓</span>
 <span class="comment">//冲指定个数后再一次性更新，而个数有E1000_RX_BUFFER_WRITE</span>
 <span class="comment">//指定</span>
 <span class="keyword">if</span> (unlikely(<span class="subst">!</span>(i <span class="subst">&amp;</span> (E1000_RX_BUFFER_WRITE <span class="subst">-</span> <span class="number">1</span>)))) {
     <span class="comment">/*
      * Force memory writes to complete before letting h/w
      * know there are new descriptors to fetch.  (Only
      * applicable for weak-ordered memory model archs,
      * such as IA-64).
      */</span>
     wmb();
     <span class="keyword">if</span> (adapter<span class="subst">-&gt;</span>flags2 <span class="subst">&amp;</span> FLAG2_PCIM2PCI_ARBITER_WA)
         e1000e_update_rdt_wa(rx_ring, i);
     <span class="keyword">else</span>
         writel(i, rx_ring<span class="subst">-&gt;</span>tail);
 }
 i<span class="subst">++</span>;
 <span class="keyword">if</span> (i <span class="subst">==</span> rx_ring<span class="subst">-&gt;</span>count)
     i <span class="subst">=</span> <span class="number">0</span>;
 buffer_info <span class="subst">=</span> <span class="subst">&amp;</span>rx_ring<span class="subst">-&gt;</span>buffer_info<span class="preprocessor">[</span>i<span class="preprocessor">]</span><span class="markup">;</span>
</code></pre><p> }</p>
<p> rx_ring-&gt;next_to_use = i;<br>}</p>
</li>
</ul>
<p>e1000_clean_rx_irq()<br>    //在完成收包处理后，更新next_to_clean，并计算<br>    //当前未使用的desc的个数 , 并分配相应个数的skb缓冲<br>    //以填充buffer_info-&gt;skb，并做DMA映射供后续网卡<br>    //收包处理，此前分配的数据包已经交由协议栈处理，<br>    //后续将由协议栈负责释放<br>    rx_ring-&gt;next_to_clean = i;<br>    cleaned_count = e1000_desc_unused(rx_ring);<br>    if (cleaned_count)<br>        adapter-&gt;alloc_rx_buf(rx_ring, cleaned_count, GFP_ATOMIC);</p>
<p>static int e1000_desc_unused(struct e1000_ring *ring)<br>{<br>    //next_to_use之后的为未被使用的<br>    //next_to_clean之后的为已收到数据包还未被被处理的，此前的为已经处理过的</p>
<pre><code>若next_to_clean 大于next_to_use，则两者间即为未被使用的区域
<span class="keyword">if</span> (ring-&gt;next_to_clean &gt; ring-&gt;next_to_use)
    <span class="keyword">return</span> ring-&gt;next_to_clean - ring-&gt;next_to_use - <span class="number">1</span>;

若next_to_clean小于next_to_use，则小于next_to_clean的与大于next_to_use
均为未被使用的
<span class="keyword">return</span> ring-&gt;count + ring-&gt;next_to_clean - ring-&gt;next_to_use - <span class="number">1</span>;
</code></pre><p>}</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-22T06:28:50.000Z"><a href="/2014/05/22/drop-packets/">5月 22 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/05/22/drop-packets/">Drop packets</a></h1>
  

    </header>
    <div class="entry">
      
        <p>在做HDFS吞吐量测试时，发现集群网络成为了瓶颈，严重影响了job的正常执行。</p>
<p>执行ifconfig 发现网卡出现大量的丢包</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment"># ifconfig eth0</span>
eth0      Link <span class="attribute">encap</span>:Ethernet  HWaddr <span class="attribute">D4</span>:<span class="number">3</span><span class="attribute">D</span>:<span class="number">7</span><span class="attribute">E</span>:<span class="number">6</span><span class="attribute">E</span>:<span class="number">0</span><span class="attribute">E</span>:<span class="number">52</span>
UP BROADCAST RUNNING MULTICAST  <span class="attribute">MTU</span>:<span class="number">1500</span>  <span class="attribute">Metric</span>:<span class="number">1</span>
RX <span class="attribute">packets</span>:<span class="number">1936403454</span> <span class="attribute">errors</span>:<span class="number">0</span> <span class="attribute">dropped</span>:<span class="number">1381778</span> <span class="attribute">overruns</span>:<span class="number">0</span> <span class="attribute">frame</span>:<span class="number">0</span>
TX <span class="attribute">packets</span>:<span class="number">1968205013</span> <span class="attribute">errors</span>:<span class="number">0</span> <span class="attribute">dropped</span>:<span class="number">0</span> <span class="attribute">overruns</span>:<span class="number">0</span> <span class="attribute">carrier</span>:<span class="number">0</span>
   <span class="attribute">collisions</span>:<span class="number">0</span> <span class="attribute">txqueuelen</span>:<span class="number">1000</span>
RX <span class="attribute">bytes</span>:<span class="number">2401524553669</span> (<span class="number">2.1</span> TiB)  TX <span class="attribute">bytes</span>:<span class="number">2234383167319</span> (<span class="number">2.0</span> TiB)
   <span class="attribute">Interrupt</span>:<span class="number">16</span> <span class="attribute">Memory</span>:dfc00000-dfc20000
</pre></td></tr></table></figure>

<p>查阅相关的内核源码可知，ifconfig读的是/proc/net/dev接口，在源文件net-tools-1.60\lib\interface.c的if_readlist_proc函数内可以看到；而/proc/net/dev接口导出的数据是通过函数dev_seq_show以及dev_seq_printf_stats来的，这两个函数都在dev.c文件内，其中：<br>overruns对应的是stats-&gt;rx_fifo_errors。<br>dropped对应的是stats-&gt;rx_dropped + stats-&gt;rx_missed_errors</p>
<p>由此可知ifconfig中显示的丢包统计有两个来源，一个是内核协议栈中的统计值：rx_dropped，而另一个是网卡驱动层面的统计值rx_missed_errors。</p>
<p>更进一步的我想知道这两个值是什么含义，具体对应的那几个阶段的丢包统计，在查阅相关资料及内核源码后，大体总结如下：<br><a href="http://www.novell.com/support/kb/doc.php?id=7007165" target="_blank">rx_dropped</a>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>Beginning <span class="operator">with</span> kernel <span class="number">2.6</span><span class="number">.37</span>, <span class="keyword">it</span> has been changed <span class="operator">the</span> meaning <span class="operator">of</span> dropped packet count. Before, dropped packets was most likely due <span class="built_in">to</span> <span class="operator">an</span> error. Now, <span class="operator">the</span> rx_dropped counter shows statistics <span class="keyword">for</span> dropped frames because <span class="operator">of</span>:

Softnet backlog full
Bad / Unintended VLAN tags
Unknown / Unregistered protocols
IPv6 frames when <span class="operator">the</span> server is <span class="operator">not</span> configured <span class="keyword">for</span> IPv6

If <span class="keyword">any</span> frames meet those conditions, they are dropped <span class="keyword">before</span> <span class="operator">the</span> protocol stack <span class="operator">and</span> <span class="operator">the</span> rx_dropped counter is incremented.
</pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-20T08:04:36.000Z"><a href="/2014/05/20/yarn-内存管理/">5月 20 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/05/20/yarn-内存管理/">Yarn 内存管理</a></h1>
  

    </header>
    <div class="entry">
      
        <p>这两天搞集群调优，分析了下Yarn对集群中内存的管理与分配，记录一下。</p>
<p>Yarn 作为一种分布式集群资源管理系统，最核心的主要的工作的就是完成集群内的资源管理与分配，当前支持Memory与CPU资源在集群内的管理与分配。而这种管理可以分解为两个子问题：</p>
<ul>
<li>1）如何申请<br>即对每个提交到集群的job而言，如何决定该向RM请求多少资源？</li>
<li>2）如何分配<br>即对RM而言，如何响应收到的每一个请求</li>
</ul>
<h1 id="-5982-4f55-7533-8bf7-">如何申请</h1>
<p>对于提交到集群的每个job，都会启动一个ApplicationMaster，由AM负责job的整个生命周期，包括向RM请求资源并负责将请求的资源再分配给具体的task。而当前每个job请求资源数将取决于集群的配置。</p>
<h2 id="-914d-7f6e-">配置</h2>
<p>与内存分配相关的配置如下：</p>
<p>yarn.nodemanager.resource.memory-mb定义每一个NodeManager能够管理的内存数。此参数指定单个节点可供container运行的最大内存数，直接影响到NodeManager向RM发送心跳信息时汇报当前结点中的可用资源数</p>
<p>yarn.scheduler.minimum-allocation-mb 和 yarn.scheduler.maximum-allocation-mb ，顾名思义，就是每一个Task可以分配到的最小和最大内存数。做个除法，就知道每台机器上面能同时运行几个Task了吧？不过还有一个小问题，YARN在运行一个Job的时候要选一台Slave做Application Master的，这个所谓的AM其实也是一个Task，也是要占内存的，是要分配 yarn.app.mapreduce.am.resource.mb 这么多的内存给它的。所以经常可以看到这样的现象：总是有那么一台Slave，运行的Task数总是比别人少一个。</p>
<p>要想让所有Slave运行一样数量的Task，就要设置得“巧妙”一点儿。比如每一台Slave提供2560mb(2048+512)，每一个Task最小512mb最大1024mb。这样就可以让每一个普通结点运行2个Task，AM运行2个Task加上一个AM任务</p>
<p>mapreduce.map.memory.mb,mapreduce.reduce.memory.mb：以上配置定义的是资源分配的整体，而这两个配置则具体的指明对每个提交的job，其map和reduce task需请求多少内存资源，可以在命令行中指定,默认大小1Gb<br>yarn.app.mapreduce.am.resource.mb: 定义启动AM时需分配多少资源<br>mapreduce.map.java.opts，mapreduce.reduce.java.opts，yarn.app.mapreduce.am.command-opts:这三个参数指定在container内启动jvm时所带的命令行参数，可通过其指定最大堆及gc 算法等<br>yarn.nodemanager.vmem-pmem-ratio：间接的指定每个task可申请的最大虚拟内存量，其本身是一个比率，即虚拟内存量与申请物理内存量的比率，默认为2.1</p>
<h2 id="-5b9e-73b0-">实现</h2>
<p>了解以上相关配置，源码实现部分的逻辑也就好理解了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>private int getMemoryRequired(Configuration conf, TaskType taskType) {
    int memory = <span class="number">1024</span><span class="comment">;</span>
    if (taskType == TaskType<span class="preprocessor">.MAP</span>)  {
        memory =
            conf<span class="preprocessor">.getInt</span>(MRJobConfig<span class="preprocessor">.MAP</span>_MEMORY_MB,
                    MRJobConfig<span class="preprocessor">.DEFAULT</span>_MAP_MEMORY_MB)<span class="comment">;</span>
    } else if (taskType == TaskType<span class="preprocessor">.REDUCE</span>) {
        memory =
            conf<span class="preprocessor">.getInt</span>(MRJobConfig<span class="preprocessor">.REDUCE</span>_MEMORY_MB,
                    MRJobConfig<span class="preprocessor">.DEFAULT</span>_REDUCE_MEMORY_MB)<span class="comment">;</span>
    }

    return memory<span class="comment">;</span>
}
</pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-13T10:42:39.000Z"><a href="/2014/05/13/hdfs-测试工具之-distributedfscheck/">5月 13 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/05/13/hdfs-测试工具之-distributedfscheck/">hdfs 测试工具之 DistributedFSCheck</a></h1>
  

    </header>
    <div class="entry">
      
        <p>DistributedFSCheck 是hadoop中自带的一个用以检查分布式文件系统一致性的工具。今天用它简单的测试了下，看了下相关的源码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="title">[</span><span class="comment">linsiyuan@client</span> <span class="comment">~</span><span class="title">]</span><span class="comment">$</span> <span class="comment">hadoop</span> <span class="comment">jar</span> <span class="comment">/usr/lib/hadoop</span><span class="literal">-</span><span class="comment">mapreduce/hadoop</span><span class="literal">-</span><span class="comment">mapreduce</span><span class="literal">-</span><span class="comment">client</span><span class="literal">-</span><span class="comment">jobclient</span><span class="literal">-</span><span class="comment">2</span><span class="string">.</span><span class="comment">2</span><span class="string">.</span><span class="comment">0</span><span class="literal">-</span><span class="comment">tests</span><span class="string">.</span><span class="comment">jar</span> <span class="comment">DistributedFSCheck</span> <span class="literal">-</span><span class="comment">h</span>
<span class="comment">Usage:</span> <span class="comment">DistributedFSCheck</span> <span class="title">[</span><span class="literal">-</span><span class="comment">root</span> <span class="comment">name</span><span class="title">]</span> <span class="title">[</span><span class="literal">-</span><span class="comment">clean</span><span class="title">]</span> <span class="title">[</span><span class="literal">-</span><span class="comment">resFile</span> <span class="comment">resultFileName</span><span class="title">]</span> <span class="title">[</span><span class="literal">-</span><span class="comment">bufferSize</span> <span class="comment">Bytes</span><span class="title">]</span> <span class="title">[</span><span class="literal">-</span><span class="comment">stats</span><span class="title">]</span>
</pre></td></tr></table></figure>

<p>Example:<br>[linsiyuan@client ~]$ hadoop jar /usr/lib/hadoop-mapreduce/hadoop-mapreduce-client-jobclient-2.2.0-tests.jar DistributedFSCheck -Dtest.build.data=/user/linsiyuan -root /user/linsiyuan/nn<br>```</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-11T08:08:50.000Z"><a href="/2014/05/11/git-惊魂一刻/">5月 11 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/05/11/git-惊魂一刻/">git 惊魂一刻</a></h1>
  

    </header>
    <div class="entry">
      
        <p>下午写了段代码准备扔到git上，结果脑子一抽，源码在创建repository是被清空了。。。<br>执行了下面的命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>git init
git status
git remote add origin <span class="keyword">...</span>
git remote -v
git add *
git pull origin master
ls
//悲剧就此发生。。
</pre></td></tr></table></figure>

<p>pull 时会执行fetch与merge两个操作，由于是新建的，远端还是空的，拉到本地时子然将本地还未受git版本管控的文件给清空了，悲催的开始查找回滚的方法。好在还是有的：）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>git fsck <span class="subst">--</span>lost<span class="attribute">-found</span>
dangling tree <span class="number">0</span>a426ea0b653c39869df8f6fea8ef3976309e1a1

git cat<span class="attribute">-file</span> <span class="attribute">-p</span> <span class="number">0</span>a426ea0b653c39869df8f6fea8ef3976309e1a1
<span class="number">100644</span> blob <span class="number">772331606</span>d0b87617df7f39ed7340b582ec2d36b    a
<span class="number">100644</span> blob ee80fc814187fefd41767132b67e321d8a96cac9    b
<span class="number">100644</span> blob ebb87fa559d89d18c9917e816891c9aa00bcd42c    c

git cat<span class="attribute">-file</span> <span class="attribute">-p</span> <span class="number">772331606</span>d0b87617df7f39ed7340b582ec2d36b <span class="subst">&&gt;</span> a<span class="built_in">.</span><span class="literal">new</span>
git cat<span class="attribute">-file</span> <span class="attribute">-p</span> ee80fc814187fefd41767132b67e321d8a96cac9 <span class="subst">&&gt;</span> b<span class="built_in">.</span><span class="literal">new</span>
git cat<span class="attribute">-file</span> <span class="attribute">-p</span> ebb87fa559d89d18c9917e816891c9aa00bcd42c <span class="subst">&&gt;</span> c<span class="built_in">.</span><span class="literal">new</span>
</pre></td></tr></table></figure>

<p>其中git cat-file -p <hex>，hex即为git fsck —lost-found命令的输出，随后可cat各个文件的hex值。<br>有惊无险，以后千万记得commit，这样git可帮助记录下每一次的改动，如有需要回滚也会容易点。常规的回滚方式如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="title">git</span> reflog
<span class="title">git</span> reset <span class="comment">--hard HEAD@{n}</span>
</pre></td></tr></table></figure>

<p>Done. :)</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-04T14:19:31.000Z"><a href="/2014/05/04/内联汇编/">5月 4 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/05/04/内联汇编/">内联汇编</a></h1>
  

    </header>
    <div class="entry">
      
        
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-04-25T06:48:46.000Z"><a href="/2014/04/25/pagecache-in-hadoop/">4月 25 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/04/25/pagecache-in-hadoop/">pagecache in Hadoop</a></h1>
  

    </header>
    <div class="entry">
      
        <p>近期开始调优Hadoop集群，发现测试环境中的几台机器在跑过几个job后内存被迅速的吃光，由于开启了后端结点NodeManager的healthy check，导致多个slave结点均停止服务，提交的任务也被block住，登陆到slave结点后查看内存的使用情况发现有大量的内存被缓存消耗掉:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>free -<span class="attribute">g</span>:
             total       used       free     shared    buffers     cached
<span class="attribute">Mem</span>:            <span class="number">62</span>         <span class="number">61</span>          <span class="number">1</span>          <span class="number">0</span>          <span class="number">0</span>         <span class="number">56</span>
-/+ buffers/<span class="attribute">cache</span>:          <span class="number">4</span>         <span class="number">58</span>
<span class="attribute">Swap</span>:            <span class="number">3</span>          <span class="number">0</span>          <span class="number">3</span>
</pre></td></tr></table></figure>

<p>cache占用了大量的内存，而cache的内存使用去向主要就三个:页缓存，目录项及Inode缓存，由meminfo中可看出当前页缓存占用了大头,且多数缓存位于Inactive 链上：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>cat /proc/<span class="attribute">meminfo</span>:
<span class="attribute">MemTotal</span>:       <span class="number">65947972</span> kB
<span class="attribute">MemFree</span>:         <span class="number">1517896</span> kB
<span class="attribute">Buffers</span>:          <span class="number">519148</span> kB
<span class="attribute">Cached</span>:         <span class="number">58903108</span> kB
<span class="attribute">SwapCached</span>:            <span class="number">0</span> kB
<span class="attribute">Active</span>:          <span class="number">7123068</span> kB
<span class="attribute">Inactive</span>:       <span class="number">54815376</span> kB
Active(anon):    <span class="number">2651364</span> kB
Inactive(anon):      <span class="number">436</span> kB
Active(file):    <span class="number">4471704</span> kB
Inactive(file): <span class="number">54814940</span> kB
<span class="attribute">Unevictable</span>:           <span class="number">0</span> kB
<span class="attribute">Mlocked</span>:               <span class="number">0</span> kB
<span class="attribute">SwapTotal</span>:       <span class="number">4194296</span> kB
<span class="attribute">SwapFree</span>:        <span class="number">4194296</span> kB
<span class="attribute">Dirty</span>:               <span class="number">188</span> kB
<span class="attribute">Writeback</span>:             <span class="number">0</span> kB
<span class="attribute">AnonPages</span>:       <span class="number">2516080</span> kB
<span class="attribute">Mapped</span>:            <span class="number">29656</span> kB
<span class="attribute">Shmem</span>:            <span class="number">135740</span> kB
<span class="attribute">Slab</span>:            <span class="number">2047392</span> kB
<span class="attribute">SReclaimable</span>:    <span class="number">1930772</span> kB
<span class="attribute">SUnreclaim</span>:       <span class="number">116620</span> kB
...
</pre></td></tr></table></figure>

<p>由此即引出三个问题:<br>1）如何定义free内存量<br>2）什么原因导致出现大量的Inactive page cache<br>3）有没有办法调整job对系统缓存使用</p>
<h1 id="-5982-4f55-5b9a-4e49-free-5185-5b58-91cf-">如何定义free内存量</h1>
<p>NodeManager中提供Healthy check功能，用户可自定义脚本实现对系统资源使用情况的检测，当脚本返回ERROR时即认为系统资源耗尽进而停止NodeManager服务，而如何定义系统资源的耗尽标准则完全由用户指定。此前仅仅简单粗暴的检查/proc/meminfo中MemFree的值，此值对应free命令中free项的输出。而事实上此处的free内存量是从操作系统的角度来看，对操作系统而言，buffer与cache均被视为已被使用的内存，当系统内存紧张时，操作系统会负责对缓存所占用的内存进行回收，由此对应用程序而可将其视为可用的内存，MemFree=buffers+cached+free，在内存紧张时交由操作系统去处理。</p>
<h1 id="-5b9a-4f4d-7cfb-7edf-5185-9875-7f13-5b58-7684-4f7f-7528-5206-5e03-">定位系统内页缓存的使用分布</h1>
<p>在已知系统内大量的内存被页缓存吃掉，有没有办法能知道当前内存中主要缓存的是那些文件？有那些进程触发的缓存行为？<br>/proc中并没有直接导出缓存页与文件的映射关系，但kernel的确提供了机制以支持查看指定的文件被缓存在</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-04-18T02:34:39.000Z"><a href="/2014/04/18/sk_buff/">4月 18 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/04/18/sk_buff/">skb_clone</a></h1>
  

    </header>
    <div class="entry">
      
        <p>分析下需要skb_clone的情景，选取kernel中的bridge桥接处理为例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
</pre></td><td class="code"><pre><span class="regexp">/* note: already called with rcu_read_lock (preempt_disabled) */</span>
int br_handle_frame_finish(struct sk_buff *skb)
{
	<span class="reserved">const</span> unsigned char *dest = eth_hdr<span class="function"><span class="params">(skb)</span>-&gt;</span>h_dest;
	struct net_bridge_port *p = rcu_dereference(skb<span class="function">-&gt;</span>dev<span class="function">-&gt;</span>br_port);
	struct net_bridge *br;
	struct net_bridge_fdb_entry *dst;
	struct net_bridge_mdb_entry *mdst;
	struct sk_buff *skb2;

	<span class="keyword">if</span> (!p || p<span class="function">-&gt;</span>state == BR_STATE_DISABLED)
		goto drop;

	<span class="regexp">/* insert into forwarding database after filtering to avoid spoofing */</span>
	br = p<span class="function">-&gt;</span>br;
	br_fdb_update<span class="function"><span class="params">(br, p, eth_hdr(skb)-&gt;h_source)</span>;

	<span class="title">if</span> <span class="params">(!is_broadcast_ether_addr(dest) && is_multicast_ether_addr(dest) &&
	    br_multicast_rcv(br, p, skb))</span>
		<span class="title">goto</span> <span class="title">drop</span>;

	<span class="title">if</span> <span class="params">(p-&gt;state == BR_STATE_LEARNING)</span>
		<span class="title">goto</span> <span class="title">drop</span>;

	<span class="title">BR_INPUT_SKB_CB</span><span class="params">(skb)</span>-&gt;</span>brdev = br<span class="function">-&gt;</span>dev;

	<span class="regexp">/* The packet skb2 goes to the local host (NULL to skip). */</span>
    <span class="regexp">//</span>skb2 是用以发往本机的，即在多播或广播情况下，经由bridge处理既需要
    <span class="regexp">//</span>将数据包转发出去，也需要将数据包交由上层协议栈继续处理，skb2用以指
    <span class="regexp">//</span>示本机是否需要处理，skb用以指示是否需要转发数据包，若需要将调用skb_clone
    <span class="regexp">//</span>复制一份sk_buff
	skb2 = NULL;

    <span class="regexp">//</span>当处于混杂模式时会将收到的数据包即使不是发往本机的也交由上层协议栈处理
	<span class="keyword">if</span> (br<span class="function">-&gt;</span>dev<span class="function">-&gt;</span>flags & IFF_PROMISC)
		skb2 = skb;

	dst = NULL;

    <span class="regexp">//</span>广播包将同时需要本机处理与转发处理
	<span class="keyword">if</span> (is_broadcast_ether_addr(dest))
		skb2 = skb;
	<span class="keyword">else</span> <span class="keyword">if</span> (is_multicast_ether_addr(dest)) {
        <span class="regexp">//</span>多播处理
		mdst = br_mdb_get(br, skb);
		<span class="keyword">if</span> <span class="function"><span class="params">(mdst || BR_INPUT_SKB_CB(skb)-&gt;mrouters_only)</span> {
			<span class="title">if</span> <span class="params">((mdst && !hlist_unhashed(&mdst-&gt;mglist)) ||
			    br_multicast_is_router(br))</span>
				<span class="title">skb2</span> = <span class="title">skb</span>;
			<span class="title">br_multicast_forward</span><span class="params">(mdst, skb, skb2)</span>;
			<span class="title">skb</span> = <span class="title">NULL</span>;
			<span class="title">if</span> <span class="params">(!skb2)</span>
				<span class="title">goto</span> <span class="title">out</span>;
		} <span class="title">else</span>
			<span class="title">skb2</span> = <span class="title">skb</span>;

		<span class="title">br</span>-&gt;</span>dev<span class="function">-&gt;</span>stats.multicast++;
	} <span class="keyword">else</span> <span class="keyword">if</span> ((dst = __br_fdb_get(br, dest)) && dst<span class="function">-&gt;</span>is_local) {
        <span class="regexp">//</span>经查表后发现数据包是发往本机的，则不再需要转发处理，
        <span class="regexp">//</span>至skb为NULL，置skb2为skb指明需要本机处理
		skb2 = skb;
		<span class="regexp">/* Do not forward the packet since it's local. */</span>
		skb = NULL;
	}

    <span class="regexp">//</span>skb不为NULL表示需要做转发处理
	<span class="keyword">if</span> (skb) {
		<span class="keyword">if</span> (dst)
			br_forward(dst<span class="function">-&gt;</span>dst, skb, skb2);
		<span class="keyword">else</span>
			br_flood_forward(br, skb, skb2);
	}

    <span class="regexp">//</span>skb2不为NULL表示需要本机处理，交由上层协议栈处理
	<span class="keyword">if</span> (skb2)
		<span class="keyword">return</span> br_pass_frame_up(skb2);

<span class="attribute">out</span>:
	<span class="keyword">return</span> <span class="number">0</span>;
<span class="attribute">drop</span>:
	kfree_skb(skb);
	goto out;
}

struct sk_buff *skb_clone(struct sk_buff *skb, gfp_t gfp_mask)
{
	struct sk_buff *n;

	<span class="keyword">if</span> <span class="function"><span class="params">(skb_tx(skb)-&gt;dev_zerocopy)</span> {
		<span class="title">if</span> <span class="params">(skb_copy_ubufs(skb, gfp_mask))</span>
			<span class="title">return</span> <span class="title">NULL</span>;
		<span class="title">skb_tx</span><span class="params">(skb)</span>-&gt;</span>dev_zerocopy = <span class="number">0</span>;
	}

	n = skb + <span class="number">1</span>;
	<span class="keyword">if</span> (skb<span class="function">-&gt;</span>fclone == SKB_FCLONE_ORIG &&
	    n<span class="function">-&gt;</span>fclone == SKB_FCLONE_UNAVAILABLE) {
		atomic_t *fclone_ref = (atomic_t *) (n + <span class="number">1</span>);
		n<span class="function">-&gt;</span>fclone = SKB_FCLONE_CLONE;
		atomic_inc(fclone_ref);
	} <span class="keyword">else</span> {
		n = kmem_cache_alloc(skbuff_head_cache, gfp_mask);
		<span class="keyword">if</span> (!n)
			<span class="keyword">return</span> NULL;

		kmemcheck_annotate_bitfield(n, flags1);
		kmemcheck_annotate_bitfield(n, flags2);
		n<span class="function">-&gt;</span>fclone = SKB_FCLONE_UNAVAILABLE;
	}

	<span class="keyword">return</span> __skb_clone(n, skb);
}
</pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-04-18T02:34:31.000Z"><a href="/2014/04/18/process-manager/">4月 18 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/04/18/process-manager/">kernel 中的进程创建</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="PID_namespace_-7684-521b-5efa-">PID namespace 的创建</h3>
<p>copy_process()<br>    —&gt; copy_namespaces()<br>        —&gt; create_new_namespaces()<br>            —&gt; copy_pid_ns()<br>                —&gt; create_pid_namespace()</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre>static struct pid_namespace <span class="variable">*create_pid_namespace</span>(struct pid_namespace <span class="variable">*parent_pid_ns</span>)
{
	struct pid_namespace <span class="variable">*ns</span>;
	unsigned <span class="keyword">int</span> level = parent_pid_ns-&gt;level + <span class="number">1</span>; <span class="regexp">//</span>在父pid namespace的level上加一，以示新一层的namespace
	<span class="keyword">int</span> i;

	ns = kmem_cache_zalloc(pid_ns_cachep, GFP_KERNEL);
	<span class="keyword">if</span> (ns == NULL)
		<span class="keyword">goto</span> out;

	ns-&gt;pidmap[<span class="number">0</span>].page = kzalloc(PAGE_SIZE, GFP_KERNEL);
	<span class="keyword">if</span> (!ns-&gt;pidmap[<span class="number">0</span>].page)
		<span class="keyword">goto</span> out_free;

	ns-&gt;pid_cachep = create_pid_cachep(level + <span class="number">1</span>);
	<span class="keyword">if</span> (ns-&gt;pid_cachep == NULL)
		<span class="keyword">goto</span> out_free_map;

	kref_init(&ns-&gt;kref);
	ns-&gt;level = level;
	ns-&gt;parent = get_pid_ns(parent_pid_ns);
	atomic_set(&ns-&gt;dead, <span class="number">0</span>);

	set_bit(<span class="number">0</span>, ns-&gt;pidmap[<span class="number">0</span>].page);
	atomic_set(&ns-&gt;pidmap[<span class="number">0</span>].nr_free, BITS_PER_PAGE - <span class="number">1</span>);

	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; PIDMAP_ENTRIES; i++)
		atomic_set(&ns-&gt;pidmap[i].nr_free, BITS_PER_PAGE);
	
	<span class="keyword">if</span> (pid_ns_prepare_proc(ns))
		<span class="keyword">goto</span> out_free_map;

	<span class="keyword">return</span> ns;

out_free_map:
	kfree(ns-&gt;pidmap[<span class="number">0</span>].page);
out_free:
	kmem_cache_free(pid_ns_cachep, ns);
out:
	<span class="keyword">return</span> ERR_PTR(-ENOMEM);
}
</pre></td></tr></table></figure>

<h3 id="PID_-5206-914d-">PID 分配</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre>struct pid *alloc_pid(struct pid_namespace *ns)
{
    struct pid *pid<span class="comment">;</span>
    enum pid_type type<span class="comment">;</span>
    int i, nr<span class="comment">;</span>
    struct pid_namespace *tmp<span class="comment">;</span>
    struct upid *upid<span class="comment">;</span>

    pid = NULL<span class="comment">;</span>
    if (atomic_read(&ns-&gt;dead))
        goto <span class="keyword">out</span><span class="comment">;</span>

    pid = kmem_cache_alloc(ns-&gt;pid_cachep, GFP_KERNEL)<span class="comment">;</span>
    if (!pid)
        goto <span class="keyword">out</span><span class="comment">;</span>

    //key: 从当前进程的命名空间开始，逐层往下，为每一层的PID namespace
    //都分配pid，由此确保在每一层上都,有对应的pid
    //当前仅支持两个pid namespace层级，<span class="number">0</span> 为host namespace
    tmp = ns<span class="comment">;</span>
    for (i = ns-&gt;level<span class="comment">; i &gt;= 0; i--) {</span>
        nr = alloc_pidmap(tmp)<span class="comment">;</span>
        if (nr &lt; <span class="number">0</span>)
            goto out_free<span class="comment">;</span>

        pid-&gt;numbers[i]<span class="preprocessor">.nr</span> = nr<span class="comment">;</span>
        pid-&gt;numbers[i]<span class="preprocessor">.ns</span> = tmp<span class="comment">; </span>
        tmp = tmp-&gt;parent<span class="comment">;</span>
    }

    get_pid_ns(ns)<span class="comment">;</span>
    pid-&gt;level = ns-&gt;level<span class="comment">; // 将当前进程描述符的pid namespace置位指定的ns所处的level</span>
    atomic_set(&pid-&gt;count, <span class="number">1</span>)<span class="comment">;</span>
    for (type = <span class="number">0</span><span class="comment">; type &lt; PIDTYPE_MAX; ++type)</span>
        INIT_HLIST_HEAD(&pid-&gt;tasks[type])<span class="comment">;</span>

    spin_lock_irq(&pidmap_lock)<span class="comment">;</span>
    for (i = ns-&gt;level<span class="comment">; i &gt;= 0; i--) {</span>
        upid = &pid-&gt;numbers[i]<span class="comment">;</span>
        hlist_add_head_rcu(&upid-&gt;pid_chain,
                &pid_hash[pid_hashfn(upid-&gt;nr, upid-&gt;ns)])<span class="comment">;</span>
    }
    spin_unlock_irq(&pidmap_lock)<span class="comment">;</span>

<span class="label">out:</span>
    return pid<span class="comment">;</span>

<span class="label">out_free:</span>
    while (++i &lt;= ns-&gt;level)
        free_pidmap(pid-&gt;numbers + i)<span class="comment">;</span>

    kmem_cache_free(ns-&gt;pid_cachep, pid)<span class="comment">;</span>
    pid = NULL<span class="comment">;</span>
    goto <span class="keyword">out</span><span class="comment">;</span>
}
</pre></td></tr></table></figure>

<p>对于进程描述符结构体中的pid来说，其始终保存的都是宿主机命名空间下所对应的pid</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>p-&gt;pid = pid_nr(pid);
p-&gt;tgid = p-&gt;pid;
<span class="keyword">if</span> (clone_flags & CLONE_THREAD)
    p-&gt;tgid = current-&gt;tgid;

<span class="regexp">/*
 * attach_pid() must be called with the tasklist_lock write-held.
 */</span>
void attach_pid(struct task_struct <span class="variable">*task</span>, enum pid_type type,
		struct pid <span class="variable">*pid</span>)
{
	struct pid_link <span class="variable">*link</span>;

	<span class="keyword">link</span> = &task-&gt;pids[type];
	<span class="keyword">link</span>-&gt;pid = pid;
	hlist_add_head_rcu(&<span class="keyword">link</span>-&gt;node, &pid-&gt;tasks[type]);
}
</pre></td></tr></table></figure>

<h3 id="fork-28-29-7cfb-7edf-8c03-7528-5982-4f55-5b9e-73b0-4e00-6b21-8c03-7528-4e24-6b21-8fd4-56de-ff1f-">fork()系统调用如何实现一次调用两次返回？</h3>
<p>操作系统提供了8Kb的存储空间供进程的内核堆栈及线程描述符存储。结构如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="preprocessor">#ifdef CONFIG_4KSTACKS</span>
<span class="preprocessor">#define THREAD_ORDER	0</span>
<span class="preprocessor">#else</span>
<span class="preprocessor">#define THREAD_ORDER	1</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor">#define THREAD_SIZE 	(PAGE_SIZE &lt;&lt; THREAD_ORDER)</span>

<span class="comment">/* PAGE_SHIFT determines the page size */</span>
<span class="preprocessor">#define PAGE_SHIFT	12</span>
<span class="preprocessor">#define PAGE_SIZE	(_AC(1,UL) &lt;&lt; PAGE_SHIFT)</span>

union thread_union {
	<span class="keyword">struct</span> thread_info thread_info;
	unsigned <span class="keyword">long</span> stack[THREAD_SIZE/sizeof(<span class="keyword">long</span>)];
};

<span class="keyword">struct</span> thread_info {
	<span class="keyword">struct</span> task_struct	*task;		<span class="comment">/* main task structure */</span>
	<span class="keyword">struct</span> exec_domain	*exec_domain;	<span class="comment">/* execution domain */</span>
	__u32			flags;		<span class="comment">/* low level flags */</span>
	__u32			status;		<span class="comment">/* thread synchronous flags */</span>
	__u32			cpu;		<span class="comment">/* current CPU */</span>
	<span class="keyword">int</span>			preempt_count;	<span class="comment">/* 0 =&gt; preemptable,
						   &lt;0 =&gt; BUG */</span>
	mm_segment_t		addr_limit;
	<span class="keyword">struct</span> restart_block    restart_block;
	<span class="keyword">void</span> __user		*sysenter_return;
<span class="preprocessor">#ifdef CONFIG_X86_32</span>
	unsigned <span class="keyword">long</span>           previous_esp;   <span class="comment">/* ESP of the previous stack in
						   case of nested (IRQ) stacks
						*/</span>
	__u8			supervisor_stack[<span class="number">0</span>];
<span class="preprocessor">#endif</span>
	<span class="keyword">int</span>			uaccess_err;
};
</pre></td></tr></table></figure>

<p>当进程陷入内核时将使用内核态的堆栈，thread_info被置于内存区的开始的位置，而内核栈从高地址向低地址方向增长。由于thread_info置于内存区的开始位置，可以很方便获得其地址，对当前在CPU上执行指令的进程来说，内核可屏蔽掉esp指针的低13位即可获得（8k=2^13）,而thread_info结构的收个元素为进程描述符，直接对thread_info的地址做解引用即可获得当前进程的进程描述符，此及current宏的实现方式。</p>
<h3 id="-786c-4ef6-4e0a-4e0b-6587-">硬件上下文</h3>
<p>进程描述符中包含一个struct thread_struct thread结构体，其作用就在于当进程切换时用以保存硬件寄存器中的信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre></td><td class="code"><pre><span class="keyword">int</span> __attribute_<span class="number">_</span>((weak)) arch_dup_task_struct(struct task_struct <span class="variable">*dst</span>,
					       struct task_struct <span class="variable">*src</span>)
{
	<span class="variable">*dst</span> = <span class="variable">*src</span>;
	<span class="keyword">return</span> <span class="number">0</span>;
}

static struct task_struct <span class="variable">*dup_task_struct</span>(struct task_struct <span class="variable">*orig</span>)
{
	struct task_struct <span class="variable">*tsk</span>;
	struct thread_info <span class="variable">*ti</span>;
	unsigned long <span class="variable">*stackend</span>;

	<span class="keyword">int</span> err;

	prepare_to_copy(orig);

	tsk = alloc_task_struct();
	<span class="keyword">if</span> (!tsk)
		<span class="keyword">return</span> NULL;

    <span class="regexp">/*
     * #define alloc_thread_info(tsk)						\
     *   ((struct thread_info *)__get_free_pages(THREAD_FLAGS, THREAD_ORDER))
     */</span>
	ti = alloc_thread_info(tsk);
	<span class="keyword">if</span> (!ti) {
		free_task_struct(tsk);
		<span class="keyword">return</span> NULL;
	}

 	err = arch_dup_task_struct(tsk, orig); <span class="regexp">//</span>直接拷贝父进程的进程描述符的数据
	<span class="keyword">if</span> (err)
		<span class="keyword">goto</span> out;
   
    <span class="regexp">//</span>更新栈的起始位置，由于thread_info与内核栈共占<span class="number">8</span>kb的空间，
    /<span class="regexp">/且thread_info位于这8kb空间的起始位置，ti的值即整个内核栈的起始点
	tsk-&gt;stack = ti; 

	err = prop_local_init_single(&tsk-&gt;dirties);
	if (err)
		goto out;
    
    /</span><span class="regexp">/拷贝父进程的thread_info内容
    /</span>*
        <span class="comment">#define task_thread_info(task)	((struct thread_info *)(task)-&gt;stack)</span>
        <span class="comment">#define task_stack_page(task)	((task)-&gt;stack)</span>

        static inline void setup_thread_stack(struct task_struct <span class="variable">*p</span>, struct task_struct <span class="variable">*org</span>)
        {
            <span class="variable">*task_thread_info</span>(p) = <span class="variable">*task_thread_info</span>(org);
            task_thread_info(p)-&gt;task = p;
        }
    <span class="variable">*/</span>
	setup_thread_stack(tsk, orig); 
	clear_tsk_need_resched(tsk);
	clear_user_return_notifier(tsk);
	stackend = end_of_stack(tsk);
	<span class="variable">*stackend</span> = STACK_END_MAGIC;	<span class="regexp">/* for overflow detection */</span>

<span class="comment">#ifdef CONFIG_CC_STACKPROTECTOR</span>
	tsk-&gt;stack_canary = get_random_int();
<span class="comment">#endif</span>

	/* One <span class="keyword">for</span> us, one <span class="keyword">for</span> whoever does the <span class="string">"release_task()"</span> (usually parent) <span class="variable">*/</span>
	atomic_set(&tsk-&gt;usage,<span class="number">2</span>);
	atomic_set(&tsk-&gt;fs_excl, <span class="number">0</span>);
<span class="comment">#ifdef CONFIG_BLK_DEV_IO_TRACE</span>
	tsk-&gt;btrace_seq = <span class="number">0</span>;
<span class="comment">#endif</span>
	tsk-&gt;splice_pipe = NULL;

	account_kernel_stack(ti, <span class="number">1</span>);

	<span class="keyword">return</span> tsk;

out:
	free_thread_info(ti);
	free_task_struct(tsk);
	<span class="keyword">return</span> NULL;
}
</pre></td></tr></table></figure>

<p>子进程返回值：<br>copy_thread()将完成新创建的子进程的内核栈的初始化工作，将创建子进程时CPU寄存器的值来初始化子进程的内核栈。也是在这个函数中完成了子进程返回值的设置。<br>函数本身为体系结构相关的，选取x86的为例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
</pre></td><td class="code"><pre>int copy_thread(unsigned long clone_flags, unsigned long sp,
		unsigned long unused,
	struct task_struct <span class="subst">*</span>p, struct pt_regs <span class="subst">*</span>regs)
{
	int err;
	struct pt_regs <span class="subst">*</span>childregs;
	struct task_struct <span class="subst">*</span>me <span class="subst">=</span> current;

    <span class="comment">/*task_stack_page(p)获得的是内核栈的起始地址（等于thread_info结构的地址），
     *加上THREAD_SIZE即获得内核栈的结束地址，减一个sizeof(pt_regs)字节，亦即
     *将当前寄存器的值存储于内核栈的底部*/</span>
	childregs <span class="subst">=</span> ((struct pt_regs <span class="subst">*</span>)
			(THREAD_SIZE <span class="subst">+</span> task_stack_page(p))) <span class="subst">-</span> <span class="number">1</span>;
	<span class="subst">*</span>childregs <span class="subst">=</span> <span class="subst">*</span>regs;

	childregs<span class="subst">-&gt;</span>ax <span class="subst">=</span> <span class="number">0</span>; <span class="comment">//将子进程的返回值强制为0；</span>
	childregs<span class="subst">-&gt;</span>sp <span class="subst">=</span> sp;
	<span class="keyword">if</span> (sp <span class="subst">==</span> ~<span class="number">0</span>UL)
		childregs<span class="subst">-&gt;</span>sp <span class="subst">=</span> (unsigned long)childregs;
    
    <span class="comment">//更新子进程的thread_info结构，使其指向当前内核栈，此前在dup_task_()函数中被初始化为父进程的内容，</span>
    <span class="comment">//初始化thread_info中的栈顶指针指向内核栈当前可用的最底部，即存储寄存器信息的地</span>
    <span class="comment">//址，注意内核栈的sp指针为由高地址项低地址方向增长</span>
	p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>sp <span class="subst">=</span> (unsigned long) childregs; 

    <span class="comment">//指向内核栈的最底部</span>
	p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>sp0 <span class="subst">=</span> (unsigned long) (childregs<span class="subst">+</span><span class="number">1</span>);
	p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>usersp <span class="subst">=</span> me<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>usersp;

	set_tsk_thread_flag(p, TIF_FORK);

	savesegment(gs, p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>gsindex);
	p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>gs <span class="subst">=</span> p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>gsindex <span class="subst">?</span> <span class="number">0</span> : me<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>gs;
	savesegment(fs, p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>fsindex);
	p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>fs <span class="subst">=</span> p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>fsindex <span class="subst">?</span> <span class="number">0</span> : me<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>fs;
	savesegment(es, p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>es);
	savesegment(ds, p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>ds);

	<span class="keyword">if</span> (unlikely(test_tsk_thread_flag(me, TIF_IO_BITMAP))) {
		p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>io_bitmap_ptr <span class="subst">=</span> kmalloc(IO_BITMAP_BYTES, GFP_KERNEL);
		<span class="keyword">if</span> (<span class="subst">!</span>p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>io_bitmap_ptr) {
			p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>io_bitmap_max <span class="subst">=</span> <span class="number">0</span>;
			<span class="keyword">return</span> <span class="attribute">-ENOMEM</span>;
		}
		memcpy(p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>io_bitmap_ptr, me<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>io_bitmap_ptr,
				IO_BITMAP_BYTES);
		set_tsk_thread_flag(p, TIF_IO_BITMAP);
	}

	<span class="comment">/*
	 * Set a new TLS for the child thread?
	 */</span>
	<span class="keyword">if</span> (clone_flags <span class="subst">&</span> CLONE_SETTLS) {
<span class="variable">#ifdef</span> CONFIG_IA32_EMULATION
		<span class="keyword">if</span> (test_thread_flag(TIF_IA32))
			err <span class="subst">=</span> do_set_thread_area(p, <span class="subst">-</span><span class="number">1</span>,
				(struct user_desc __user <span class="subst">*</span>)childregs<span class="subst">-&gt;</span>si, <span class="number">0</span>);
		<span class="keyword">else</span>
<span class="variable">#endif</span>
			err <span class="subst">=</span> do_arch_prctl(p, ARCH_SET_FS, childregs<span class="subst">-&gt;</span>r8);
		<span class="keyword">if</span> (err)
			goto out;
	}
	err <span class="subst">=</span> <span class="number">0</span>;
out:
	<span class="keyword">if</span> (err <span class="subst">&&</span> p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>io_bitmap_ptr) {
		kfree(p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>io_bitmap_ptr);
		p<span class="subst">-&gt;</span><span class="keyword">thread</span><span class="built_in">.</span>io_bitmap_max <span class="subst">=</span> <span class="number">0</span>;
	}
	<span class="keyword">return</span> err;
}
</pre></td></tr></table></figure>

<p>父进程返回值：<br>父进程将通过task_pid_vnr()来获取子进程在父进程所处的pid 命名空间下的pid来作为返回值，而子进程的返回已经在copy_thread()将eax寄存器的值置位0作为子进程的返回值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="keyword">static</span> <span class="keyword">inline</span> pid_t task_pid_vnr(<span class="keyword">struct</span> task_struct *tsk)
{
	<span class="keyword">return</span> __task_pid_nr_ns(tsk, PIDTYPE_PID, NULL);
}

pid_t __task_pid_nr_ns(<span class="keyword">struct</span> task_struct *task, enum pid_type <span class="class"><span class="keyword">type</span>,</span>
			<span class="keyword">struct</span> pid_namespace *ns)
{
	pid_t nr = <span class="number">0</span>;

	rcu_read_lock();
	<span class="keyword">if</span> (!ns)
		<span class="comment">//ns = current-&gt;nsproxy-&gt;pid_ns;</span>
<span class="comment">//		ns = current-&gt;nsproxy-&gt;pid_ns;</span>
        ns = task_active_pid_ns(current);
    <span class="keyword">if</span> (likely(pid_alive(task))) {
		<span class="keyword">if</span> (<span class="class"><span class="keyword">type</span> !=</span> PIDTYPE_PID)
			task = task-&gt;group_leader;
		nr = pid_nr_ns(task-&gt;pids[<span class="class"><span class="keyword">type</span>].<span class="title">pid</span>, <span class="title">ns</span>);</span>
	}
	rcu_read_unlock();

	<span class="keyword">return</span> nr;
}

<span class="comment">//BUG root cause:</span>
<span class="comment">//此函数将通过当前进程的struct pid中的level所指示的命名空间去获得进程在对应命名空间下的pid值,而非直接获取nsproxy中所指向的pid_ns，</span>
<span class="comment">//原因在于调用过setns()的进程，其nsproxy与pid-&gt;level可能不一致，其本身不处于新的命名空间下，但其子进程将处于新的命名空间下</span>
<span class="keyword">struct</span> pid_namespace *task_active_pid_ns(<span class="keyword">struct</span> task_struct *tsk)
{
	<span class="keyword">return</span> ns_of_pid(task_pid(tsk));
}

<span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> pid *task_pid(<span class="keyword">struct</span> task_struct *task)
{
	<span class="keyword">return</span> task-&gt;pids[PIDTYPE_PID].pid;
}

<span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> pid_namespace *ns_of_pid(<span class="keyword">struct</span> pid *pid)
{
	<span class="keyword">struct</span> pid_namespace *ns = NULL;
	<span class="keyword">if</span> (pid)
		ns = pid-&gt;numbers[pid-&gt;level].ns;
	<span class="keyword">return</span> ns;
}
</pre></td></tr></table></figure>

<p>setns 系统调用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>SYSCALL_DEFINE2(setns, <span class="keyword">int</span>, fd, unsigned <span class="keyword">int</span>, nstype)
{
    ...

    <span class="comment">//创建新的命名空间，包括pid namespace ,其中pid namespace将基于当前的进程所处的命名空间</span>
    <span class="comment">//层次加一，但本质上指示当前进程所处的pid 命名空间的struct pid 结构体中的level，其值并</span>
    <span class="comment">//未改变，由此调用setns()系统调用的进程其nsproxy结构体中的pid namespace已经指向了下一次</span>
    <span class="comment">//但其本身仍处于原有的pid命名空间中，但其创建的子进程将继承其nsproxy，由此将进入新的pid</span>
    <span class="comment">//命名空间</span>
	new_nsproxy = create_new_namespaces(<span class="number">0</span>, tsk, tsk-&gt;fs);
	<span class="keyword">if</span> (IS_ERR(new_nsproxy)) {
		err = PTR_ERR(new_nsproxy);
		<span class="keyword">goto</span> <span class="keyword">out</span>;
	}

	err = ops-&gt;install(new_nsproxy, ei-&gt;ns);
	<span class="keyword">if</span> (err) {
		free_nsproxy(new_nsproxy);
		<span class="keyword">goto</span> <span class="keyword">out</span>;
	}
	switch_task_namespaces(tsk, new_nsproxy);
<span class="keyword">out</span>:
	fput(file);
	<span class="keyword">return</span> err;
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="title">pid_t</span> pid_vnr(struct pid *pid)  
{  
// return pid_nr_ns(pid, current-&gt;nsproxy-&gt;pid_ns);  
   return pid_nr_ns(pid, task_active_pid_ns(current));  
}  
<span class="type">EXPORT_SYMBOL_GPL</span>(pid_vnr);  

<span class="title">rcu_read_lock</span>();  
<span class="title">if</span> (!ns)  
//  ns = current-&gt;nsproxy-&gt;pid_ns;  
//  ns = current-&gt;nsproxy-&gt;pid_ns;  
    ns = task_active_pid_ns(current);  

    <span class="keyword">if</span> (likely(pid_alive(task))) {  
        <span class="keyword">if</span> (<span class="typedef"><span class="keyword">type</span> != <span class="type">PIDTYPE_PID</span>)  </span>
            task = task-&gt;group_leader;
</pre></td></tr></table></figure>

<h3 id="cgroup_-4e0e-8fdb-7a0b-7684-7ed1-5b9a-">cgroup 与进程的绑定</h3>
<p>在创建新的进程时，默认子进程将继承父进程所处的cgroup ,虽然整个进程描述符在dup_task_struct()函数中复制父进程的内容，但考虑到未加锁，可能父进程的cgroup信息有变更，调用cgroup_fork()以进一步完成子进程的cgroup信息的更新。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>/**
 * cgroup_fork - attach newly forked task <span class="keyword">to</span> <span class="keyword">its</span> parents cgroup.
 * @child: pointer <span class="keyword">to</span> task_struct <span class="keyword">of</span> forking parent process.
 *
 * Description: A task inherits <span class="keyword">its</span> parent's cgroup <span class="keyword">at</span> fork().
 *
 * A pointer <span class="keyword">to</span> <span class="keyword">the</span> shared css_set was automatically copied <span class="keyword">in</span>
 * fork.c <span class="keyword">by</span> dup_task_struct().  However, we ignore <span class="keyword">that</span> <span class="keyword">copy</span>, <span class="keyword">since</span>
 * <span class="keyword">it</span> was <span class="keyword">not</span> made under <span class="keyword">the</span> protection <span class="keyword">of</span> RCU <span class="keyword">or</span> cgroup_mutex, so
 * might no longer be a valid cgroup pointer.  cgroup_attach_task() might
 * have already changed current-&gt;cgroups, allowing <span class="keyword">the</span> previously
 * referenced cgroup group <span class="keyword">to</span> be removed <span class="keyword">and</span> freed.
 *
 * At <span class="keyword">the</span> point <span class="keyword">that</span> cgroup_fork() <span class="keyword">is</span> called, 'current' <span class="keyword">is</span> <span class="keyword">the</span> parent
 * task, <span class="keyword">and</span> <span class="keyword">the</span> passed argument 'child' points <span class="keyword">to</span> <span class="keyword">the</span> child task.
 */
void cgroup_fork(struct task_struct *child)
{
	task_lock(current);
	child-&gt;cgroups = current-&gt;cgroups;
	get_css_set(child-&gt;cgroups);
	task_unlock(current);
	INIT_LIST_HEAD(&child-&gt;cg_list);
}
</pre></td></tr></table></figure>

<p>函数调用关系：<br>1   1732  /opt/linsiyuan/git/top-free/skernel/kernel/cgroup.c &lt;<cgroup_attach_task_all>&gt;<br>retval = cgroup_attach_task(cur_cg, tsk);<br>2   1774  /opt/linsiyuan/git/top-free/skernel/kernel/cgroup.c &lt;<attach_task_by_pid>&gt;<br>ret = cgroup_attach_task(cgrp, tsk);<br>3   3984  /opt/linsiyuan/git/top-free/skernel/kernel/cgroup.c &lt;<cgroup_clone>&gt;<br>ret = cgroup_attach_task(child, tsk);<br>4   2003  /opt/linsiyuan/git/top-free/skernel/kernel/cpuset.c &lt;<cpuset_do_move_task>&gt;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
</pre></td><td class="code"><pre>/**
 * cgroup_attach_task - attach task 'tsk' to cgroup 'cgrp'
 * @cgrp: the cgroup the task is attaching to
 * @tsk: the task to be attached
 *
 * Call holding cgroup_mutex. May take task_lock of
 * the task 'tsk' during call.
 */
int cgroup_attach_task(struct cgroup *cgrp, struct task_struct *tsk)
{
	int retval = 0;
	struct cgroup_subsys *ss, *failed_ss = NULL;
	struct cgroup *oldcgrp;
	struct css_set *cg;
	struct css_set *newcg;
	struct cgroupfs_root *root = cgrp-&gt;root;

	/* Nothing to do if the task is already in that cgroup */
	oldcgrp = task_cgroup_from_root(tsk, root);
	if (cgrp == oldcgrp)
		return 0;

	for_each_subsys(root, ss) {
		if (ss-&gt;can_attach) {
			retval = ss-&gt;can_attach(ss, cgrp, tsk, false);
			if (retval) {
				/*
				 * Remember on which subsystem the can_attach()
				 * failed, so that we only call cancel_attach()
				 * against the subsystems whose can_attach()
				 * succeeded. (See below)
				 */
				failed_ss = ss;
				goto out;
			}
		}
	}

	task_lock(tsk);
	cg = tsk-&gt;cgroups;
	get_css_set(cg);
	task_unlock(tsk);
	/*
	 * Locate or allocate a new css_set for this task,
	 * based on its final set of cgroups
	 */
	newcg = find_css_set(cg, cgrp);
	put_css_set(cg);
	if (!newcg) {
		retval = -ENOMEM;
		goto out;
	}

	task_lock(tsk);
	if (tsk-&gt;flags & PF_EXITING) {
		task_unlock(tsk);
		put_css_set(newcg);
		retval = -ESRCH;
		goto out;
	}
	rcu_assign_pointer(tsk-&gt;cgroups, newcg);
	task_unlock(tsk);

	/* Update the css_set linked lists if we're using them */
	write_lock(&css_set_lock);
	if (!list_empty(&tsk-&gt;cg_list)) {
		list_del(&tsk-&gt;cg_list);
		list_add(&tsk-&gt;cg_list, &newcg-&gt;tasks);
	}
	write_unlock(&css_set_lock);

	for_each_subsys(root, ss) {
		if (ss-&gt;attach)
			ss-&gt;attach(ss, cgrp, oldcgrp, tsk, false);
	}
	set_bit(CGRP_RELEASABLE, &oldcgrp-&gt;flags);
	synchronize_rcu();
	put_css_set(cg);

	/*
	 * wake up rmdir() waiter. the rmdir should fail since the cgroup
	 * is no longer empty.
	 */
	cgroup_wakeup_rmdir_waiter(cgrp);
<span class="title">out:</span>
	if (retval) {
		for_each_subsys(root, ss) {
			if (ss == failed_ss)
				/*
				 * This subsystem was the one that failed the
				 * can_attach() check earlier, so we don't need
				 * to call cancel_attach() against it or any
				 * remaining subsystems.
				 */
				break;
			if (ss-&gt;cancel_attach)
				ss-&gt;cancel_attach(ss, cgrp, tsk, false);
		}
	}
	return retval;
}
</pre></td></tr></table></figure>

<p>在完成进程描述符的创建后，执行cgroup各个子系统所需的callback函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>
	/* Now <span class="keyword">that</span> <span class="keyword">the</span> task <span class="keyword">is</span> <span class="keyword">set</span> up, <span class="command">run</span> cgroup callbacks <span class="keyword">if</span>
	 * necessary. We need <span class="keyword">to</span> <span class="command">run</span> them <span class="keyword">before</span> <span class="keyword">the</span> task <span class="keyword">is</span> visible
	 * <span class="function_start"><span class="keyword">on</span> <span class="title">the</span></span> tasklist. */
	cgroup_fork_callbacks(p);
	cgroup_callbacks_done = <span class="number">1</span>;
</pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-04-18T02:34:17.000Z"><a href="/2014/04/18/glibc-fork()-bug/">4月 18 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/04/18/glibc-fork()-bug/">glibc fork() bug</a></h1>
  

    </header>
    <div class="entry">
      
        <p>关键代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="comment">From</span> <span class="comment">nptl/sysdeps/unix/sysv/linux/fork</span><span class="string">.</span><span class="comment">c</span> <span class="comment">(glibc</span> <span class="comment">source</span> <span class="comment">code</span><span class="string">,</span> <span class="title">[</span><span class="comment">1</span><span class="title">]</span><span class="comment">)</span>

<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
 <span class="comment">_IO_list_lock</span> <span class="comment">();</span>

<span class="comment">#ifndef</span> <span class="comment">NDEBUG</span>
 <span class="comment">pid_t</span> <span class="comment">ppid</span> <span class="comment">=</span> <span class="comment">THREAD_GETMEM</span> <span class="comment">(THREAD_SELF</span><span class="string">,</span> <span class="comment">tid);</span>
<span class="comment">#endif</span>

 <span class="comment">/*</span> <span class="string">.</span><span class="string">.</span><span class="string">.</span> <span class="comment">stuff</span> <span class="comment">left</span> <span class="comment">out</span><span class="string">,</span> <span class="comment">including</span> <span class="comment">syscall</span> <span class="comment">to</span> <span class="comment">fork</span> <span class="comment">itself</span> <span class="string">.</span><span class="string">.</span><span class="string">.</span> <span class="comment">*/</span>

<span class="comment">if</span> <span class="comment">(pid</span> <span class="comment">==</span> <span class="comment">0)</span>
<span class="comment">{</span>
    <span class="comment">struct</span> <span class="comment">pthread</span> <span class="comment">*self</span> <span class="comment">=</span> <span class="comment">THREAD_SELF;</span>

    <span class="comment">assert</span> <span class="comment">(THREAD_GETMEM</span> <span class="comment">(self</span><span class="string">,</span> <span class="comment">tid)</span> <span class="comment">!=</span> <span class="comment">ppid);</span>

    <span class="comment">/*</span> <span class="string">.</span><span class="string">.</span><span class="string">.</span> <span class="comment">stuff</span> <span class="comment">left</span> <span class="comment">out</span> <span class="string">.</span><span class="string">.</span><span class="string">.</span> <span class="comment">*/</span>

    <span class="comment">/*</span> <span class="comment">Reset</span> <span class="comment">locks</span> <span class="comment">in</span> <span class="comment">the</span> <span class="comment">I/O</span> <span class="comment">code</span><span class="string">.</span>  <span class="comment">*/</span>
    <span class="comment">_IO_list_resetlock</span> <span class="comment">();</span>
<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
</pre></td></tr></table></figure>

<h3 id="-95ee-9898-">问题</h3>
<p>当服务器大量调用lxc-attach时，将出现lxc-attach进程处于D（TASK_UNINTERRUPTABLE）状态，原因即在于以上的glibc中的fork库函数：fork库函数出于线程安全的考虑将首先调用_IO_list_lock()函数锁住标准的输入输出，进而获得当前进程的pid，随后调用fork()系统调用，在其返回时，对返回值为0的,即在子进程的上下文中获得其thread id，单进程中的thread_id即为pid，此前缓存的父进程的pid值仍处于子进程的地址空间中，对子进程可见，与其对比，若一样则assert()断言生效。<br>通常情况下在同一命名空间下父子进程的pid不会一样，但对lxc-attach而言其执行过程如下：<br>fork() //gp<br>    setns() //p<br>    fork()<br>        execv() //child<br>由于对p而言其调用了setns()，由此开辟了一块新的pid命名空间，在新的命名空间下将从0 开始分配，由此当lxc-attach调用频繁时，将有可能出现子进程的pid与宿主上的父进程pid一样的情况，由此assert（）断言生效。<br>而当断言生效时，fork()库函数将尝试通过printf()输出error信息，而此前已经将标准的输入输出锁住，由此出现了死锁的情况，由此导致进程无法退出，始终处于等待IO的D（TASK_UNINTERRUPTABLE）状态。</p>
<p>而操作系统loadavg在计算时将同时考虑正在运行的以及等待IO的进程，当有大量的处于D状态的lxc-attach进程时，系统的loadavg将非常的高，但实际的CPU利用率却不高。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>/proc/loadavg
The  <span class="keyword">first</span>  <span class="constant">three</span>  fields <span class="operator">in</span> this <span class="built_in">file</span> are <span class="built_in">load</span> <span class="built_in">average</span> figures giving <span class="operator">the</span> <span class="built_in">number</span> <span class="operator">of</span> jobs <span class="operator">in</span> <span class="operator">the</span> run queue (state R) <span class="operator">or</span> waiting <span class="keyword">for</span> disk I/O (state D) averaged over <span class="number">1</span>, <span class="number">5</span>, <span class="operator">and</span> <span class="number">15</span> minutes.
</pre></td></tr></table></figure>

<p>参考：<br><a href="https://lists.linuxcontainers.org/pipermail/lxc-devel/2013-April/004152.html" target="_blank">setns/fork(glibc) weird interaction, lxc-attach may hang sporadically</a><br><a href="https://lists.linuxcontainers.org/pipermail/lxc-devel/2013-April/004203.html" target="_blank">lxc_attach: Use clone() instead of second  fork()</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-04-14T09:07:18.000Z"><a href="/2014/04/14/宏/">4月 14 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/04/14/宏/">宏</a></h1>
  

    </header>
    <div class="entry">
      
        <p>细节体现技术，这点在kernel中宏的设计上体现的淋漓尽致。看下kernel中提供的最基本的工具宏：</p>
<p>kernel.h:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">#define min(x, y) ({				\
</span>	typeof(x) <span class="title">_min1</span> = (x);			\
	typeof(y) <span class="title">_min2</span> = (y);			\
	(void) (&<span class="title">_min1</span> == &<span class="title">_min2</span>);		\
	<span class="title">_min1</span> &lt; <span class="title">_min2</span> ? <span class="title">_min1</span> : <span class="title">_min2</span>; })
</pre></td></tr></table></figure>

<p>定义一个min() 宏来返回二者中较小的一个。很直接的想法是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="preprocessor">#<span class="keyword">define</span> min(x, y) ((x) &lt; (y) ? (x) : (y))</span>
</pre></td></tr></table></figure>

<p>但相比较下kernel中却用了四行代码来完成，为什么？<br>试想以下test case：<br>case 1:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="built_in">i</span> = <span class="number">4</span>;
<span class="built_in">j</span> = min(<span class="built_in">i</span>++ , <span class="number">5</span>);
</pre></td></tr></table></figure>

<p>执行后的结果是i = 6 ，j = 5,也即min宏在比较之余还有副作用：因为全展开后i将自增两次</p>
<p>case 2:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>unsigned long i = <span class="number">0xFFFFFFFF</span>ul + <span class="number">1</span>;
unsigned <span class="keyword">int</span> j = <span class="number">0xFFFFFFFF</span>ul;
<span class="keyword">int</span> k = min(i , j);
<span class="keyword">printf</span>(<span class="string">"i = <span class="variable">%#lx</span>  , j = <span class="variable">%#x</span> , k = <span class="variable">%#x</span>\n"</span> , i , j  ,k);
</pre></td></tr></table></figure>

<p>输出结果为：<br>i = 0x100000000  , j = 0xffffffff , k = 0xffffffff<br>当比较的两个参数的数据类型不一样时，会有隐士类型转换，以上的例子中unsigned long会转为unsigned int,而i的低四个字节部分为0，当做为无符号函数比较时，子然小于j，由此会导致与预期结果不一致。</p>
<p>kernel.h中给出定义即很好的解决以上两个问题：</p>
<ul>
<li><p>通过typeof来获取比较双方的数据类型，并定义两个临时的变量保存比较双方的值，注意x,y均加括号保护，由此临时变量将保存的是自增或自减后的值，在后续的比较操作中操作的是两个临时变量，由此可规避第一个问题。<br>typeof 本身亦是一个宏，其为gcc的一个扩展</p>
</li>
<li><p>借助编译器来检查比较双方的数据类型是否一致。在比较地址的时候，会发现地址所存值的类型，假如不同的话就会报警告，而在直接比较值的时候，比如上面的_min1 &lt; _min2 ?的时候，会做强制类型转换，而且不会报警告。可以在编译时加上-Werror选项，提高warnning的警告级别为error。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>(void) (&_min1 == &_min2);

警告：
g++ <span class="transposed_variable">test.</span>cpp
<span class="transposed_variable">test.</span>cpp: In <span class="function"><span class="keyword">function</span> ‘<span class="title">int</span> <span class="title">main</span><span class="params">()</span>’:</span>
<span class="transposed_variable">test.</span>cpp:<span class="number">111</span>: error: comparison between distinct pointer types ‘long unsigned int*’ <span class="built_in">and</span> ‘unsigned int*’ lacks a cast
make: *** <span class="matrix">[all]</span> Error <span class="number">1</span>
</pre></td></tr></table></figure>

</li>
</ul>
<p>kernel.h 中还给出相应的三个元素的比较:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="comment">/*
 * min()/max()/clamp() macros that also do
 * strict type-checking.. See the
 * "unnecessary" pointer comparison.
 */</span>
<span class="comment">#define min(x, y) ({				\
</span>	typeof(x) <span class="title">_min1</span> = (x);			\
	typeof(y) <span class="title">_min2</span> = (y);			\
	(void) (&<span class="title">_min1</span> == &<span class="title">_min2</span>);		\
	<span class="title">_min1</span> &lt; <span class="title">_min2</span> ? <span class="title">_min1</span> : <span class="title">_min2</span>; })

<span class="comment">#define max(x, y) ({				\
</span>	typeof(x) <span class="title">_max1</span> = (x);			\
	typeof(y) <span class="title">_max2</span> = (y);			\
	(void) (&<span class="title">_max1</span> == &<span class="title">_max2</span>);		\
	<span class="title">_max1</span> &gt; <span class="title">_max2</span> ? <span class="title">_max1</span> : <span class="title">_max2</span>; })

<span class="comment">#define min3(x, y, z) ({			\
</span>	typeof(x) <span class="title">_min1</span> = (x);			\
	typeof(y) <span class="title">_min2</span> = (y);			\
	typeof(z) <span class="title">_min3</span> = (z);			\
	(void) (&<span class="title">_min1</span> == &<span class="title">_min2</span>);		\
	(void) (&<span class="title">_min1</span> == &<span class="title">_min3</span>);		\
	<span class="title">_min1</span> &lt; <span class="title">_min2</span> ? (<span class="title">_min1</span> &lt; <span class="title">_min3</span> ? <span class="title">_min1</span> : <span class="title">_min3</span>) : \
		(<span class="title">_min2</span> &lt; <span class="title">_min3</span> ? <span class="title">_min2</span> : <span class="title">_min3</span>); })

<span class="comment">#define max3(x, y, z) ({			\
</span>	typeof(x) <span class="title">_max1</span> = (x);			\
	typeof(y) <span class="title">_max2</span> = (y);			\
	typeof(z) <span class="title">_max3</span> = (z);			\
	(void) (&<span class="title">_max1</span> == &<span class="title">_max2</span>);		\
	(void) (&<span class="title">_max1</span> == &<span class="title">_max3</span>);		\
	<span class="title">_max1</span> &gt; <span class="title">_max2</span> ? (<span class="title">_max1</span> &gt; <span class="title">_max3</span> ? <span class="title">_max1</span> : <span class="title">_max3</span>) : \
		(<span class="title">_max2</span> &gt; <span class="title">_max3</span> ? <span class="title">_max2</span> : <span class="title">_max3</span>); })

<span class="comment">/**
 * min_not_zero - return the minimum that is _not_ zero, unless both are zero
 * @x: value1
 * @y: value2
 */</span>
<span class="comment">#define min_not_zero(x, y) ({			\
</span>	typeof(x) __x = (x);			\
	typeof(y) __y = (y);			\
	__x == <span class="number">0</span> ? __y : ((__y == <span class="number">0</span>) ? __x : <span class="built_in">min</span>(__x, __y)); })
</pre></td></tr></table></figure>

<p>Done.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>






<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:lsmushroom.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/git/">git</a><small>1</small></li>
  
    <li><a href="/categories/hadoop/">hadoop</a><small>1</small></li>
  
    <li><a href="/categories/java/">java</a><small>1</small></li>
  
    <li><a href="/categories/kernel/">kernel</a><small>10</small></li>
  
    <li><a href="/categories/vim/">vim</a><small>1</small></li>
  
    <li><a href="/categories/yarn/">yarn</a><small>15</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/api/">api</a><small>1</small></li>
  
    <li><a href="/tags/chm/">chm</a><small>1</small></li>
  
    <li><a href="/tags/git/">git</a><small>1</small></li>
  
    <li><a href="/tags/hadoop/">hadoop</a><small>6</small></li>
  
    <li><a href="/tags/hexo/">hexo</a><small>1</small></li>
  
    <li><a href="/tags/java/">java</a><small>1</small></li>
  
    <li><a href="/tags/kernel/">kernel</a><small>16</small></li>
  
    <li><a href="/tags/pig/">pig</a><small>1</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>1</small></li>
  
    <li><a href="/tags/storm/">storm</a><small>1</small></li>
  
    <li><a href="/tags/vim/">vim</a><small>1</small></li>
  
    <li><a href="/tags/yarn/">yarn</a><small>19</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/api/" style="font-size: 10.00px;">api</a><a href="/tags/chm/" style="font-size: 10.00px;">chm</a><a href="/tags/git/" style="font-size: 10.00px;">git</a><a href="/tags/hadoop/" style="font-size: 13.33px;">hadoop</a><a href="/tags/hexo/" style="font-size: 10.00px;">hexo</a><a href="/tags/java/" style="font-size: 10.00px;">java</a><a href="/tags/kernel/" style="font-size: 16.67px;">kernel</a><a href="/tags/pig/" style="font-size: 10.00px;">pig</a><a href="/tags/shell/" style="font-size: 10.00px;">shell</a><a href="/tags/storm/" style="font-size: 10.00px;">storm</a><a href="/tags/vim/" style="font-size: 10.00px;">vim</a><a href="/tags/yarn/" style="font-size: 20.00px;">yarn</a>
  </div>
</div>


  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=1&ptype=1&speed=0&skin=5&isTitle=1&noborder=1&isWeibo=1&isFans=0&uid=1632605594&verifier=ff6d468c&dpc=1"></iframe>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 Yuan Linsi
  
</div>
<div class="clearfix"></div>
</footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>